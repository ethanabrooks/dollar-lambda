<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dollar_lambda.parser API documentation</title>
<meta name="description" content="Defines parsing functions and the `Parser` class that they instantiate." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&family=IBM+Plex+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
body {
font-family: 'IBM Plex Sans', sans-serif;
line-height: 1.45;
font-size: 15px;
}
pre, code {
font-family: Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", Monaco, "Courier New", Courier, monospace;
}
p code {
white-space: nowrap;
}
</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:50%;max-height:10em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="file:///Users/ethanbrooks/monad_argparse/docs/dollar_lambda/index.html">
<link rel="icon" href="https://ethanabrooks.github.io/dollar-lambda/logo.png">
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dollar_lambda.parser</code></h1>
<a href="https://github.com/ethanabrooks/dollar-lambda" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
</svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</header>
<section id="section-intro">
<p>Defines parsing functions and the <code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a></code> class that they instantiate.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L1-L1241" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Defines parsing functions and the `Parser` class that they instantiate.
&#34;&#34;&#34;
# pyright: reportGeneralTypeIssues=false
from __future__ import annotations

import operator
import os
import re
import sys
from dataclasses import astuple, dataclass, replace
from functools import lru_cache, partial, reduce
from typing import Any, Callable, Dict, Generic, Optional, Type, TypeVar

from pytypeclass import Monad, MonadPlus, Monoid
from pytypeclass.nonempty_list import NonemptyList

from dollar_lambda.error import (
    ArgumentError,
    BinaryError,
    HelpError,
    MissingError,
    UnequalError,
    UnexpectedError,
)
from dollar_lambda.result import Result
from dollar_lambda.sequence import KeyValue, Output, Sequence

A_co = TypeVar(&#34;A_co&#34;, covariant=True)
A_monoid = TypeVar(&#34;A_monoid&#34;, bound=Monoid)
B_monoid = TypeVar(&#34;B_monoid&#34;, bound=Monoid)
A = TypeVar(&#34;A&#34;)
B = TypeVar(&#34;B&#34;)

global TESTING
TESTING = os.environ.get(&#34;DOLLAR_LAMBDA_TESTING&#34;, False)


@dataclass
class Parse(Generic[A_co]):
    &#34;&#34;&#34;
    A `Parse` is the output of parsing.

    Parameters
    ----------
    parsed : A
        Component parsed by the parsed
    unparsed : Sequence[str]
        Component yet to be parsed
    &#34;&#34;&#34;

    parsed: A_co
    unparsed: Sequence[str]


@dataclass
class SuccessError(ArgumentError, Generic[A_monoid]):
    input: Sequence[str]
    output: NonemptyList[Parse[A_monoid]]


def binary_usage(a: Optional[str], op: str, b: Optional[str], add_brackets=True):
    &#34;&#34;&#34;
    Utility for generating usage strings for binary operators.
    &#34;&#34;&#34;
    no_nones = [x for x in (a, b) if x is not None]
    usage = op.join(no_nones)
    if len(no_nones) &gt; 1 and add_brackets:
        usage = f&#34;[{usage}]&#34;
    return usage or None


@dataclass
class Parser(MonadPlus[A_co]):
    &#34;&#34;&#34;
    Main class powering the argument parser.
    &#34;&#34;&#34;

    f: Callable[[Sequence[str]], Result[Parse[A_co]]]
    usage: Optional[str]
    helps: Dict[str, str]

    def __add__(
        self: &#34;Parser[Output[A_monoid]]&#34;, other: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        &#34;&#34;&#34;
        Parse two arguments in either order.
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
        {&#39;verbose&#39;: True, &#39;debug&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
        {&#39;debug&#39;: True, &#39;verbose&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
        usage: --verbose --debug
        Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

        Note that if more than two arguments are chained together with `+`, some combinations will not parse:
        &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
        {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
        usage: -a -b -c
        Expected &#39;-b&#39;. Got &#39;-c&#39;

        This makes more sense when one supplies the implicit parentheses:
        &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

        In order to chain together more than two arguments, use `nonpositional`:
        &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
        {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
        &#34;&#34;&#34;
        p = (self &gt;&gt; other) | (other.rshift(self))
        usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
        return replace(p, usage=usage)

    def __ge__(self, f: Callable[[A_co], Monad[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[override]
        return self.bind(f)

    def __or__(  # type: ignore[override]
        self: &#34;Parser[A_monoid]&#34;,
        other: &#34;Parser[B_monoid]&#34;,
    ) -&gt; &#34;Parser[A_monoid | B_monoid]&#34;:
        &#34;&#34;&#34;
        Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

        &gt;&gt;&gt; from dollar_lambda import argument, option, flag
        &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
        {&#39;verbose&#39;: True}

        Note that by default, `parse_args` adds `&gt;&gt; Parser.done()` to the end of parsers, causing
        `p` to fail when both arguments are supplied:

        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        usage: [--option OPTION | --verbose]
        Unrecognized argument: --option

        To disable this behavior, use `allow_unparsed`:
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;, allow_unparsed=True)
        {&#39;verbose&#39;: True}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[&#34;A_monoid | B_monoid&#34;]]:
            return self.parse(cs) | other.parse(cs)

        return Parser(
            f,
            usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
            helps={**self.helps, **other.helps},
        )

    def rshift(
        self: &#34;Parser[Output[A_monoid]]&#34;, p: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        return self &gt;&gt; p

    def __rshift__(
        self: &#34;Parser[Output[A_monoid]]&#34;, p: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        &#34;&#34;&#34;
        This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
        gets handed off to the second parser. If either parser fails, the whole thing fails.

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        usage: FIRST SECOND
        The following arguments are required: second
        &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
        usage: FIRST SECOND
        The following arguments are required: second
        &#34;&#34;&#34;

        def f(p1: Output[A_monoid]) -&gt; Parser[Output[A_monoid | B_monoid]]:
            def g(p2: Output[B_monoid]) -&gt; Parser[Output[A_monoid | B_monoid]]:
                # _p1 = p1 if isinstance(p1, Sequence) else Sequence(p1)
                # _p2 = p2 if isinstance(p2, Sequence) else Sequence(p2)
                return Parser.return_(p1 + p2)

            return p &gt;= g

        parser = self &gt;= f
        # parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
        return replace(
            parser,
            usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False),
            helps={**self.helps, **p.helps},
        )

    def __xor__(
        self: &#34;Parser[Output[A_monoid]]&#34;, other: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        &#34;&#34;&#34;
        This is the same as `__or__`, but it succeeds only if one of the two parsers fails.

        &gt;&gt;&gt; p = argument(&#34;int&#34;, type=int) ^ argument(&#34;div&#34;, type=lambda x: 1 / float(x))
        &gt;&gt;&gt; p.parse_args(&#34;inf&#34;)  # succeeds because int(&#34;inf&#34;) fails
        {&#39;div&#39;: 0.0}
        &gt;&gt;&gt; p.parse_args(&#34;0&#34;)  # succeeds because 1 / 0 throws an error
        {&#39;int&#39;: 0}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)  # fails because both parsers succeed
        Both parsers succeeded. This causes ^ to fail.
        &#34;&#34;&#34;
        p = (self.fails() &gt;&gt; other) | (other.fails() &gt;&gt; self)

        def f(error: ArgumentError) -&gt; ArgumentError:
            if isinstance(error, BinaryError):
                return ArgumentError(&#34;Both parsers succeeded. This causes ^ to fail.&#34;)
            return error

        return p.map_error(f)

    def apply(self: &#34;Parser[A_monoid]&#34;, f: Callable[[A_monoid], Result[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        Takes the output of `parser` and applies `f` to it. Convert any errors that arise into `ArgumentError`.

        &gt;&gt;&gt; p1 = flag(&#34;hello&#34;)
        &gt;&gt;&gt; p1.parse_args(&#34;--hello&#34;)
        {&#39;hello&#39;: True}

        This will double `p1`&#39;s output:
        &gt;&gt;&gt; p2 = p1.apply(lambda out: Result.return_(out + out))
        &gt;&gt;&gt; p2.parse_args(&#34;--hello&#34;)
        {&#39;hello&#39;: [True, True]}
        &#34;&#34;&#34;

        def g(a: A_monoid) -&gt; Parser[B_monoid]:
            try:
                y = f(a)
            except Exception as e:
                usage = f&#34;An argument {a}: raised exception {e}&#34;
                y = Result(ArgumentError(usage))
            return Parser(
                lambda cs: y &gt;= (lambda parsed: Result.return_(Parse(parsed, cs))),
                usage=self.usage,
                helps=self.helps,
            )

        p = self &gt;= g
        return replace(p, usage=self.usage, helps=self.helps)

    def bind(self, f: Callable[[A_co], Monad[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[override]
        &#34;&#34;&#34;
        Returns a new parser that

        1. applies `self`;
        2. if this succeeds, applies `f` to the parsed component of the result.

        `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
        avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
        `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

        Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
        and we typically prefer using the infix operator to the spelled out method.

        Let&#39;s start with our simplest parser, `argument`:
        &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

        Now let&#39;s use the `matches` parser to write a function that takes the output of `p1` and fails unless
        the next argument is the same as the first:
        &gt;&gt;&gt; def f(out: Output[Sequence[KeyValue[Any]]]) -&gt; Parser[Output[str]]:
        ...     *_, kv = out.get
        ...     return matches(kv.value)

        &gt;&gt;&gt; p = p1 &gt;= f
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
        {&#39;a&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        Expected &#39;a&#39;. Got &#39;b&#39;
        &#34;&#34;&#34;

        def h(parse: Parse[A_co]) -&gt; Result[Parse[B_monoid]]:
            y = f(parse.parsed)
            assert isinstance(y, Parser), y
            return y.parse(parse.unparsed)

        def g(cs: Sequence[str]) -&gt; Result[Parse[B_monoid]]:
            return self.parse(cs) &gt;= h

        return Parser(g, usage=None, helps=self.helps)

    @classmethod
    def done(
        cls: Type[&#34;Parser[Output[A_monoid]]&#34;], a: Optional[Type[A_monoid]] = None
    ) -&gt; Parser[Output[Any]]:
        &#34;&#34;&#34;
        `done` succeds on the end of input and fails on everything else.
        &gt;&gt;&gt; Parser.done().parse_args()
        {}
        &gt;&gt;&gt; Parser.done().parse_args(&#34;arg&#34;)
        Unrecognized argument: arg

        Without `done` the parser will not complain about leftover (unparsed) input:

        &gt;&gt;&gt; flag(&#34;verbose&#34;).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, allow_unparsed=True)
        {&#39;verbose&#39;: True}

        When `allow_unparsed=False` (the default), `parse_args` adds `&gt;&gt; Parser.done()`
        to the end of the parser:
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[Output[Any]]]:
            if cs:
                c, *_ = cs
                return Result(
                    UnexpectedError(unexpected=c, usage=f&#34;Unrecognized argument: {c}&#34;)
                )
            return Result(NonemptyList(Parse(parsed=Output.zero(a), unparsed=cs)))

        return Parser(f, usage=None, helps={})

    @classmethod
    def empty(
        cls: Type[&#34;Parser[Output[A_monoid]]&#34;], a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
        &gt;&gt;&gt; Parser.empty().parse_args(&#34;any&#34;, &#34;arguments&#34;, allow_unparsed=True)
        {}
        &#34;&#34;&#34;
        return cls.return_(Output.zero(a))

    def fails(
        self: &#34;Parser[Output[A_monoid]]&#34;, a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Succeeds only if self fails. Does not consume any input.

        &gt;&gt;&gt; flag(&#34;x&#34;).fails().parse_args(&#34;not x&#34;, allow_unparsed=True)  # succeeds
        {}
        &gt;&gt;&gt; flag(&#34;x&#34;).fails().parse_args(&#34;-x&#34;, allow_unparsed=True)  # fails
        Parser unexpectedly succeeded.
        &#34;&#34;&#34;

        def g(cs: Sequence[str]) -&gt; Result[Parse[Output[A_monoid]]]:
            parse = self.parse(cs).get
            if isinstance(parse, Exception):
                return Result.return_(Parse(Output.zero(a), cs))
            else:
                return Result.zero(
                    error=SuccessError(
                        &#34;Parser unexpectedly succeeded.&#34;, input=cs, output=parse
                    )
                )

        return Parser(g, usage=None, helps=self.helps)

    def handle_error(self, error: ArgumentError) -&gt; None:
        def print_usage(usage: str):
            print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in usage else &#34; &#34;)
            if &#34;\n&#34; in usage:
                usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in usage.split(&#34;\n&#34;)])
            print(usage)
            if self.helps:
                for k, v in self.helps.items():
                    print(f&#34;{k}: {v}&#34;)

        if isinstance(error, HelpError):
            print_usage(error.usage)
        else:
            if self.usage:
                print_usage(self.usage)
            if error.usage:
                print(error.usage)
        if TESTING:
            return
        else:
            exit()

    def ignore(
        self: &#34;Parser[Output[A_monoid]]&#34;, a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Ignores the output from a parser. This is useful when you expect
        to give arguments to the command line that some other utility will
        handle.

        &gt;&gt;&gt; p = flag(&#34;hello&#34;).ignore()

        This will not bind any value to `&#34;hello&#34;`:
        &gt;&gt;&gt; p.parse_args(&#34;--hello&#34;)
        {}

        But `--hello` is still required:
        &gt;&gt;&gt; p.parse_args()
        The following arguments are required: --hello
        &#34;&#34;&#34;

        def g(keep: Parse[Output[A_monoid]]) -&gt; Result[Parse[Output[A_monoid]]]:
            return Result(NonemptyList(Parse(Output.zero(a), keep.unparsed)))

        def f(cs: Sequence[str]) -&gt; Result[Parse[Output[A_monoid]]]:
            return self.parse(cs) &gt;= g

        return Parser(f, usage=None, helps={})

    def many(
        self: &#34;Parser[Output[A_monoid]]&#34;, max: Optional[int] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Applies `self` zero or more times (like `*` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args()
        {}
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        {&#39;as-many-as-you-like&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;as-many-as-you-like&#39;: [&#39;a&#39;, &#39;b&#39;]}

        Note that if `self` contains `Parser.__or__`, the arguments can be
        heterogenous:
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
        &gt;&gt;&gt; p = p.many()
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;) # mix --verbose and --quiet
        {&#39;verbose&#39;: True, &#39;quiet&#39;: True}
        &#34;&#34;&#34;
        if max == 0:
            p = self.empty()
        else:
            if max is not None:
                max -= 1
                assert max &gt;= 0, max
            p = self.many1(max=max) | self.empty()
        return replace(p, usage=f&#34;[{self.usage} ...]&#34;)

    def many1(
        self: &#34;Parser[Output[A_monoid]]&#34;, max: Optional[int] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Applies `self` one or more times (like `+` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
        {&#39;1-or-more&#39;: &#39;1&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;)
        {&#39;1-or-more&#39;: [&#39;1&#39;, &#39;2&#39;]}
        &gt;&gt;&gt; p.parse_args()
        usage: 1-OR-MORE [1-OR-MORE ...]
        The following arguments are required: 1-or-more
        &#34;&#34;&#34;

        @lru_cache()
        def f(cs: tuple):
            y = self &gt;&gt; self.many(max=max)
            return y.parse(Sequence(list(cs)))

        return Parser(
            lambda cs: f(tuple(cs)),
            usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
            helps=self.helps,
        )

    def map_error(self, f: Callable[[ArgumentError], ArgumentError]) -&gt; &#34;Parser[A_co]&#34;:
        def g(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
            parse = self.parse(cs)
            if isinstance(parse.get, ArgumentError):
                return Result.zero(error=f(parse.get))
            else:
                return parse

        return Parser(g, usage=None, helps=self.helps)

    def optional(self: &#34;Parser[Output[A_monoid]]&#34;) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Allows arguments to be optional:
        &gt;&gt;&gt; p1 = flag(&#34;optional&#34;)
        &gt;&gt;&gt; p = p1.optional()
        &gt;&gt;&gt; p.parse_args(&#34;--optional&#34;)
        {&#39;optional&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--misspelled&#34;, allow_unparsed=True)  # succeeds with no output
        {}
        &gt;&gt;&gt; p1.parse_args(&#34;--misspelled&#34;)
        usage: --optional
        Expected &#39;--optional&#39;. Got &#39;--misspelled&#39;
        &#34;&#34;&#34;
        return self | self.empty()

    def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        &#34;&#34;&#34;
        Applies the parser to the input sequence `cs`.
        &#34;&#34;&#34;
        return self.f(cs)

    def parse_args(
        self: &#34;Parser[Output]&#34;,
        *args: str,
        allow_unparsed: bool = False,
        check_help: bool = True,
    ) -&gt; &#34;Optional[Dict[str, Any]]&#34;:
        &#34;&#34;&#34;
        The main way the user extracts parsed results from the parser.

        Parameters
        ----------
        args : str
            A sequence of strings to parse. If empty, defaults to `sys.argv[1:]`.
        allow_unparsed : bool
            Whether to cause parser to fail if there are unparsed inputs. Note that setting this to false
            may cause unexpected behavior when using `nonpositional` or `Args`.
        check_help : bool
            Before running the parser, checks if the input string is `--help` or `-h`.
            If it is, returns the usage message.

        Examples
        --------

        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
        usage: A
        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
        usage: A
        &#34;&#34;&#34;
        _args = args if args or TESTING else sys.argv[1:]
        if not allow_unparsed:
            return (self &gt;&gt; Parser[Output].done()).parse_args(
                *_args,
                allow_unparsed=True,
                check_help=check_help,
            )
        if check_help:
            return self.wrap_help().parse_args(
                *_args,
                allow_unparsed=allow_unparsed,
                check_help=False,
            )
        result = self.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            self.handle_error(result)
            return None
        return result.head.parsed.get.to_dict()

    @classmethod
    def return_(cls, a: A_co) -&gt; &#34;Parser[A_co]&#34;:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
        and always returns `a` as the result. For the most part, the user will not use
        this method unless building custom parsers.

        &gt;&gt;&gt; Parser.return_(Output.from_dict(some_key=&#34;some_value&#34;)).parse_args()
        {&#39;some_key&#39;: &#39;some_value&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
            return Result.return_(Parse(a, cs))

        return Parser(f, usage=None, helps={})

    def sat(
        self: &#34;Parser[A_monoid]&#34;,
        predicate: Callable[[A_monoid], bool],
        on_fail: Callable[[A_monoid], ArgumentError],
    ) -&gt; &#34;Parser[A_monoid]&#34;:
        &#34;&#34;&#34;
        Applies `parser`, applies a predicate to the result and fails if this returns false.

        &gt;&gt;&gt; p = option(&#34;x&#34;, type=int).many().sat(
        ...     lambda out: sum(out.get.values()) &gt; 0,
        ...     lambda out: ArgumentError(f&#34;The values in {list(out.get.values())} must sum to more than 0.&#34;),
        ... )
        &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;1&#34;)  # fails
        usage: [-x X ...]
        The values in [-1, 1] must sum to more than 0.

        &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;2&#34;)  # succeeds
        {&#39;x&#39;: [-1, 2]}

        Parameters
        ----------
        parser : Parser[A]
            The parser to apply.
        predicate : Callable[[A], bool]
            The predicate to apply to the result of `parser`. `sat` fails if this predicate returns false.
        on_fail : Callable[[A], ArgumentError]
            A function producing an ArgumentError to return if the predicate fails.
            Takes the output of `parser` as an argument.
        &#34;&#34;&#34;

        def f(x: A_monoid) -&gt; Result[A_monoid]:
            return Result(NonemptyList(x) if predicate(x) else on_fail(x))

        return self.apply(f)

    def type(
        self: &#34;Parser[Output[Sequence[KeyValue[str]]]]&#34;, f: Callable[[str], Any]
    ) -&gt; &#34;Parser[Output[Sequence[KeyValue[str]]]]&#34;:
        &#34;&#34;&#34;
        A wrapper around `apply` that simply applies `f` to the value of the most recently parsed input.
        &gt;&gt;&gt; p1 = option(&#34;x&#34;) &gt;&gt; option(&#34;y&#34;)
        &gt;&gt;&gt; p = p1.type(int)
        &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)  # converts &#34;1&#34; but not &#34;2&#34;
        {&#39;x&#39;: &#39;1&#39;, &#39;y&#39;: 2}
        &#34;&#34;&#34;

        def g(out: Output[Sequence[KeyValue[str]]]) -&gt; Result[Output]:
            d = out.get
            if not d:
                raise RuntimeError(&#34;Invoked type on a parser that returns no output.&#34;)
            *tail, head = out.get
            try:
                y = f(head.value)
            except Exception as e:
                usage = f&#34;argument {head.value}: raised exception {e}&#34;
                return Result(ArgumentError(usage))
            return Result.return_(Output(Sequence([*tail, KeyValue(head.key, y)])))

        p = self.apply(g)
        return replace(p, usage=self.usage, helps=self.helps)

    def wrap_error(self, error: ArgumentError) -&gt; &#34;Parser[A_co]&#34;:
        return self.map_error(lambda _: error)

    def wrap_help(
        self: &#34;Parser[A_monoid]&#34;, a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[A_monoid]&#34;:
        &#34;&#34;&#34;
        This checks for the `--help` or `-h` flag before applying `parser`.
        If either of the flags is present, returns the usage message for `parser`.

        &gt;&gt;&gt; p = flag(&#34;help&#34;, help=&#34;Print this help message.&#34;).wrap_help()
        &gt;&gt;&gt; p.parse_args(&#34;--help&#34;)
        usage: --help
        help: Print this help message.
        &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
        usage: --help
        help: Print this help message.

        We can use `wrap_help` to print partial usage messages, e.g. for subcommands:
        &gt;&gt;&gt; subcommand1 = matches(&#34;subcommand1&#34;) &gt;&gt; option(&#34;option1&#34;).wrap_help()
        &gt;&gt;&gt; subcommand2 = matches(&#34;subcommand2&#34;) &gt;&gt; option(&#34;option2&#34;).wrap_help()
        &gt;&gt;&gt; p = subcommand1 | subcommand2
        &gt;&gt;&gt; p.parse_args(&#34;subcommand1&#34;, &#34;-h&#34;)
        usage: --option1 OPTION1
        &gt;&gt;&gt; p.parse_args(&#34;subcommand2&#34;, &#34;-h&#34;)
        usage: --option2 OPTION2
        &#34;&#34;&#34;
        _help_parser: Parser[Output[A_monoid]] = help_parser(self.usage, Output.zero(a))

        p = _help_parser &gt;= (lambda _: self)
        return replace(p, usage=self.usage, helps=self.helps)

    @classmethod
    def zero(cls, error: Optional[ArgumentError] = None) -&gt; &#34;Parser[A_co]&#34;:
        &#34;&#34;&#34;
        This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

        Parameters
        ----------
        error : Optional[ArgumentError]
            Customize the error returned by `zero`.

        &gt;&gt;&gt; Parser.zero().parse_args()
        zero
        &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
        zero
        &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
        This is a test.
        &#34;&#34;&#34;
        return Parser(lambda _: Result.zero(error=error), usage=None, helps={})


def apply(f: Callable[[str], B_monoid], description: str) -&gt; Parser[B_monoid]:
    &#34;&#34;&#34;
    A shortcut for
    ```python
    item(description).apply(f)
    ```
    and spares `f` the trouble of outputting a `Result` object.
    Here is an example of usage. First we define a simple `argument` parser:

    &gt;&gt;&gt; p1 = argument(&#34;foo&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;bar&#34;)
    {&#39;foo&#39;: &#39;bar&#39;}

    Here we use `f` to directly manipulate the binding generated by `item`:
    &gt;&gt;&gt; p2 = apply(lambda bar: Output.from_dict(**{bar + &#34;e&#34;: bar + &#34;f&#34;}), description=&#34;baz&#34;)
    &gt;&gt;&gt; p2.parse_args(&#34;bar&#34;)
    {&#39;bare&#39;: &#39;barf&#39;}
    &#34;&#34;&#34;

    def g(out: Output[Sequence[KeyValue[str]]]) -&gt; Result[B_monoid]:
        *_, (_, v) = map(astuple, out.get)
        assert v is not None  # because item produces output
        try:
            y = f(v)
        except Exception as e:
            usage = f&#34;argument {v} raised exception {e}&#34;
            return Result(ArgumentError(usage))
        return Result.return_(y)

    return item(description).apply(g)


def argument(
    dest: str, help: Optional[str] = None, type: Optional[Callable[[str], Any]] = None
) -&gt; Parser[Output]:
    &#34;&#34;&#34;
    Parses a single word and binds it to `dest`.
    Useful for positional arguments.

    Parameters
    ----------
    dest : str
        The name of variable to bind to:

    help : Optional[str]
        The help message to display for the option:

    type : Optional[Callable[[str], Any]]
        Use the `type` argument to convert the input to a different type:

    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args()
    usage: NAME
    The following arguments are required: name
    &#34;&#34;&#34;
    parser = item(dest)
    _type: Callable[[str], Any] = str if type is None else type  # type: ignore[assignment]
    # Mypy doesn&#39;t know that types also have type Callable[[str], Any]
    if _type is not str:
        parser = parser.type(_type)
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=dest.upper(), helps=helps)
    return parser


def defaults(**kwargs: A) -&gt; Parser[Output[Sequence[KeyValue[A]]]]:
    &#34;&#34;&#34;
    Useful for assigning default values to arguments.
    It ignore the input and always returns `kwargs` converted into `CollisionDict`.
    `defaults` never failsekpoi

    &gt;&gt;&gt; defaults(a=1, b=2).parse_args()
    {&#39;a&#39;: 1, &#39;b&#39;: 2}
    &gt;&gt;&gt; (flag(&#34;fails&#34;) | defaults(fails=&#34;succeeds&#34;)).parse_args()
    {&#39;fails&#39;: &#39;succeeds&#39;}

    Here&#39;s a more complex example derived from the tutorial:
    &gt;&gt;&gt; p = nonpositional(
    ...     (
    ...         flag(&#34;verbose&#34;) + defaults(quiet=False)  # either --verbose and default &#34;quiet&#34; to False
    ...         | flag(&#34;quiet&#34;) + defaults(verbose=False)  # or --quiet and default &#34;verbose&#34; to False
    ...     ),
    ...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
    ...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
    ... )

    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
    {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}
    &#34;&#34;&#34;
    p = Parser[Output[A_monoid]].return_(
        Output[Sequence[KeyValue[A]]].from_dict(**kwargs)
    )
    return replace(p, usage=None)


def matches(
    s: str, peak: bool = False, regex: bool = True
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    &#34;&#34;&#34;
    Checks if the next word is `s`.

    &gt;&gt;&gt; matches(&#34;hello&#34;).parse_args(&#34;hello&#34;)
    {&#39;hello&#39;: &#39;hello&#39;}
    &gt;&gt;&gt; matches(&#34;hello&#34;).parse_args(&#34;goodbye&#34;)
    usage: hello
    Expected &#39;hello&#39;. Got &#39;goodbye&#39;

    Parameters
    ----------
    s: str
        The word to that input will be checked against for equality.
    peak : bool
        If `False`, then the parser will consume the word and return the remaining words as `unparsed`.
        If `True`, then the parser leaves the `unparsed` component unchanged.

    regex : bool
        Whether to treat `s` as a regular expression. If `False`, then the parser will only succeed on
        string equality.

    Examples
    --------

    &gt;&gt;&gt; p = matches(&#34;hello&#34;) &gt;&gt; matches(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    {&#39;hello&#39;: &#39;hello&#39;, &#39;goodbye&#39;: &#39;goodbye&#39;}

    Look what happens when `peak=True`:
    &gt;&gt;&gt; p = matches(&#34;hello&#34;, peak=True) &gt;&gt; matches(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    usage: hello goodbye
    Expected &#39;goodbye&#39;. Got &#39;hello&#39;

    The first parser didn&#39;t consume the word and so &#34;hello&#34; got passed on to `equals(&#34;goodbye&#34;)`.
    But this would work:
    &gt;&gt;&gt; p = matches(&#34;hello&#34;, peak=True) &gt;&gt; matches(&#34;hello&#34;) &gt;&gt; matches(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    {&#39;hello&#39;: [&#39;hello&#39;, &#39;hello&#39;], &#39;goodbye&#39;: &#39;goodbye&#39;}
    &#34;&#34;&#34;

    def predicate(_s: str) -&gt; bool:
        if regex:
            return bool(re.match(s, _s))
        else:
            return s == _s

    if peak:
        return sat_peak(
            predicate=predicate,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )
    else:
        return sat(
            predicate=predicate,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )


def flag(
    dest: str,
    default: Optional[bool] = None,
    help: Optional[str] = None,
    short: bool = True,
    string: Optional[str] = None,
) -&gt; Parser[Output[Sequence[KeyValue[bool]]]]:
    &#34;&#34;&#34;
    Binds a boolean value to a variable.

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}


    Parameters
    ----------
    dest : str
        The variable to which the value will be bound.

    default : Optional[bool]
        An optional default value.

    help : Optional[str]
        An optional help string.

    short : bool
        Whether to check for the short form of the flag, which
        uses a single dash and the first character of `dest`, e.g. `-f` for `foo`.

    string : Optional[str]
        A custom string to use for the flag. Defaults to `--{dest}`.

    Examples
    --------

    Here is an example using the `default` parameter:

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, default=False)
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False}

    By default `flag` fails when it does not receive expected input:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args()
    usage: --verbose
    The following arguments are required: --verbose

    Here is an example using the `help` parameter:

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, help=&#34;Turn on verbose output.&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --verbose
    verbose: Turn on verbose output.

    Here is an example using the `short` parameter:

    &gt;&gt;&gt; flag(&#34;verbose&#34;, short=True).parse_args(&#34;-v&#34;)  # this is the default
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; flag(&#34;verbose&#34;, short=False).parse_args(&#34;-v&#34;)  # fails
    usage: --verbose
    Expected &#39;--verbose&#39;. Got &#39;-v&#39;

    Here is an example using the `string` parameter:

    &gt;&gt;&gt; flag(&#34;value&#34;, string=&#34;v&#34;).parse_args(&#34;v&#34;)  # note that string does not have to start with -
    {&#39;value&#39;: True}
    &#34;&#34;&#34;
    if string is None:
        _string = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _string = string

    def f(
        cs: Sequence[str],
        s: str,
    ) -&gt; Result[Parse[Output[Sequence[KeyValue[bool]]]]]:
        parser = matches(s) &gt;= (lambda _: defaults(**{dest: not default}))
        return parser.parse(cs)

    parser = Parser(partial(f, s=_string), usage=None, helps={})
    if short:
        short_string = f&#34;-{dest[0]}&#34;
        parser2 = flag(dest, short=False, string=short_string, default=default)
        parser = parser | parser2
    if default:
        help = f&#34;{help + &#39; &#39; if help else &#39;&#39;}(default: {default})&#34;
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=_string, helps=helps)
    return parser if default is None else parser | defaults(**{dest: default})


def help_parser(usage: Optional[str], parsed: A_monoid) -&gt; Parser[A_monoid]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[A_monoid]]:
        result = (matches(&#34;--help&#34;, peak=True) | matches(&#34;-h&#34;, peak=True)).parse(cs)
        if isinstance(result.get, ArgumentError):
            return Result.return_(Parse(parsed=parsed, unparsed=cs))
        return Result(HelpError(usage=usage or &#34;Usage not provided.&#34;))

    return Parser(f, usage=None, helps={})


def item(
    name: str,
    help_name: Optional[str] = None,
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    &#34;&#34;&#34;
    Parses a single word and binds it to `dest`.
    One of the lowest level building blocks for parsers.

    Parameters
    ----------
    help_name : Optional[str]
        Used for generating help text

    Examples
    --------

    &gt;&gt;&gt; p = item(&#34;name&#34;, help_name=&#34;Your first name&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; p.parse_args()
    usage: name
    The following arguments are required: Your first name
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[Output[Sequence[KeyValue[str]]]]]:
        if cs:
            head, *tail = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Output[Sequence[KeyValue[str]]].from_dict(
                            **{name: head}
                        ),
                        unparsed=Sequence(tail),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {help_name or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})


def nonpositional(
    *parsers: &#34;Parser[Output[A_monoid]]&#34;,
    repeated: Optional[Parser[Output[A_monoid]]] = None,
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    `nonpositional` takes a sequence of parsers as arguments and attempts all permutations of them,
    returning the first permutations that is successful:

    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
    {&#39;verbose&#39;: True, &#39;quiet&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
    {&#39;quiet&#39;: True, &#39;verbose&#39;: True}

    Parameters
    ----------
    repeated : Optional[Parser[Sequence[A]]]
        If provided, this parser gets applied repeatedly (zero or more times) at all positions.

    Examples
    --------
    &gt;&gt;&gt; p = nonpositional(repeated=flag(&#34;x&#34;))
    &gt;&gt;&gt; p.parse_args()
    {}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;)
    {&#39;x&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-x&#34;)
    {&#39;x&#39;: [True, True]}

    &gt;&gt;&gt; p = nonpositional(flag(&#34;y&#34;), repeated=flag(&#34;x&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;-y&#34;)
    {&#39;y&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-y&#34;, &#34;-x&#34;)
    {&#39;y&#39;: True, &#39;x&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-y&#34;)
    {&#39;x&#39;: True, &#39;y&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-y&#34;, &#34;-x&#34;, &#34;-x&#34;)
    {&#39;y&#39;: True, &#39;x&#39;: [True, True]}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-y&#34;, &#34;-x&#34;)
    {&#39;x&#39;: [True, True], &#39;y&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-x&#34;, &#34;-y&#34;)
    {&#39;x&#39;: [True, True], &#39;y&#39;: True}

    &gt;&gt;&gt; p = nonpositional(flag(&#34;y&#34;), repeated=(flag(&#34;x&#34;) | flag(&#34;z&#34;)).ignore())
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-y&#34;, &#34;-z&#34;)
    {&#39;y&#39;: True}
    &#34;&#34;&#34;
    sep = &#34; &#34; if len(parsers) &lt;= 3 else &#34;\n&#34;
    _parsers = [*parsers] if repeated is None else [*parsers, repeated]
    usage = sep.join([p.usage or &#34;&#34; for p in _parsers])
    repeat_parser = None
    if repeated is not None:
        _repeated = repeated  # for mypy&#39;s benefit

        def f(cs: Sequence[str]):
            p = _repeated &gt;&gt; nonpositional(*parsers, repeated=repeated)
            return p.parse(cs)

        repeat_parser = Parser(f, usage=None, helps={})

    if not parsers:
        if repeat_parser is None:
            return Parser[Output[A_monoid]].empty()
        else:
            return repeat_parser | Parser[Output[A_monoid]].empty()

    def get_alternatives():
        if repeat_parser is not None:
            yield repeat_parser
        for i, head in enumerate(parsers):
            tail = [p for j, p in enumerate(parsers) if j != i]
            yield head &gt;&gt; nonpositional(*tail, repeated=repeated)

    parser = reduce(operator.or_, get_alternatives())
    helps = parser.helps
    if repeated is not None:
        helps = {**helps, **repeated.helps}
    return replace(parser, usage=usage, helps=helps)


def option(
    dest: str,
    flag: Optional[str] = None,
    default: Any = None,
    help: Optional[str] = None,
    short: bool = True,
    type: Callable[[str], Any] = str,
) -&gt; Parser[Output[Sequence[KeyValue[Any]]]]:
    &#34;&#34;&#34;
    Parses two words, binding the second to the first.

    Parameters
    ----------
    dest : str
        The name of variable to bind to:

    flag : Optional[str]
        The flag to use for the option. If not provided, defaults to `--{dest}`.

    default : Optional[Any]
        The default value to bind on failure:

    help : Optional[str]
        The help message to display for the option:

    short : bool
        Whether to check for the short form of the flag, which
        uses a single dash and the first character of `dest`, e.g. `-c` for `count`.

    type : Callable[[str], Any]
        Use the `type` argument to convert the input to a different type:

    Examples
    --------

    &gt;&gt;&gt; option(&#34;count&#34;).parse_args(&#34;--count&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}

    In this example, you can see that the `flag` parameter allows the user to
    specify an arbitrary lead string, including one that doesn&#39;t start with a dash.

    &gt;&gt;&gt; option(&#34;count&#34;, flag=&#34;ct&#34;).parse_args(&#34;ct&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}

    This example demonstrates the use of the `default` parameter:

    &gt;&gt;&gt; option(&#34;count&#34;, default=2).parse_args()
    {&#39;count&#39;: 2}

    Here we specify a help-string using the `help` parameter:

    &gt;&gt;&gt; option(&#34;count&#34;, help=&#34;The number we should count to&#34;).parse_args(&#34;-h&#34;)
    usage: --count COUNT
    count: The number we should count to

    This example demonstrates the difference between `short=True` and `short=False`:

    &gt;&gt;&gt; option(&#34;count&#34;, short=True).parse_args(&#34;-c&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}
    &gt;&gt;&gt; option(&#34;count&#34;, short=False).parse_args(&#34;-c&#34;, &#34;1&#34;)
    usage: --count COUNT
    Expected &#39;--count&#39;. Got &#39;-c&#39;

    As with [argparse](https://docs.python.org/3/library/argparse.html#argument-parsing),
    the `type` argument allows you to convert the input to a different type using a
    function that takes a single string argument:

    &gt;&gt;&gt; option(&#34;x&#34;, type=int).parse_args(&#34;-x&#34;, &#34;1&#34;)  # converts &#34;1&#34; to an int
    {&#39;x&#39;: 1}
    &gt;&gt;&gt; option(&#34;x&#34;, type=lambda x: int(x) + 1).parse_args(&#34;-x&#34;, &#34;1&#34;)
    {&#39;x&#39;: 2}
    &#34;&#34;&#34;

    if flag is None:
        _flag = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _flag = flag

    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Output[Sequence[KeyValue[str]]]]]:
        parser = matches(_flag) &gt;= (lambda _: item(dest, help_name=dest.upper()))
        return parser.parse(cs)

    parser = Parser(f, usage=None, helps={})
    if type is not str:
        parser = parser.type(type)
    if short and len(dest) &gt; 1:
        parser2 = option(dest=dest, short=False, flag=f&#34;-{dest[0]}&#34;, default=None)
        parser = parser | parser2
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=f&#34;{_flag} {dest.upper()}&#34;, helps=helps)
    return parser if default is None else parser | defaults(**{dest: default})


def peak(
    name: str,
    description: Optional[str] = None,
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Output[Sequence[KeyValue[str]]]]]:
        if cs:
            head, *_ = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Output[Sequence[KeyValue[str]]].from_dict(
                            **{name: head}
                        ),
                        unparsed=Sequence(cs),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {description or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})


def sat(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    &#34;&#34;&#34;
    A wrapper around `Parser.sat` that uses `item` to parse the argument and just applies `predicate` to the value output by `item`.

    &gt;&gt;&gt; p = sat(lambda x: len(x) == 1, lambda x: ArgumentError(f&#34;&#39;{x}&#39; must have exactly one character.&#34;), &#34;x&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)  # succeeds
    {&#39;x&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;aa&#34;)  # fails
    usage: x
    &#39;aa&#39; must have exactly one character.

    Parameters
    ----------
    predicate : Callable[[A], bool]
        The predicate to apply to the result of `item`. `sat` fails if this predicate returns false.
    on_fail : Callable[[A], ArgumentError]
        A function producing an ArgumentError to return if the predicate fails.
        Takes the output of `item` as an argument.
    name: str
        The value to bind the result to.
    &#34;&#34;&#34;

    def _predicate(out: Output[Sequence[KeyValue[str]]]) -&gt; bool:
        *_, (_, v) = map(astuple, out.get)
        return predicate(v)

    def _on_fail(out: Output[Sequence[KeyValue[str]]]) -&gt; ArgumentError:
        *_, (_, v) = map(astuple, out.get)
        return on_fail(v)

    return item(name).sat(_predicate, _on_fail)


def sat_peak(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    def _predicate(out: Output[Sequence[KeyValue[str]]]) -&gt; bool:
        *_, (_, v) = map(astuple, out.get)
        return predicate(v)

    def _on_fail(out: Output[Sequence[KeyValue[str]]]) -&gt; ArgumentError:
        *_, (_, v) = map(astuple, out.get)
        return on_fail(v)

    return peak(name).sat(_predicate, _on_fail)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dollar_lambda.parser.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>f:Callable[[str],B_monoid], description:str) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[~B_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>A shortcut for</p>
<pre><code class="language-python">item(description).apply(f)
</code></pre>
<p>and spares <code>f</code> the trouble of outputting a <code>Result</code> object.
Here is an example of usage. First we define a simple <code><a title="dollar_lambda.parser.argument" href="#dollar_lambda.parser.argument">argument()</a></code> parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = argument(&quot;foo&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;bar&quot;)
{'foo': 'bar'}
</code></pre>
<p>Here we use <code>f</code> to directly manipulate the binding generated by <code><a title="dollar_lambda.parser.item" href="#dollar_lambda.parser.item">item()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p2 = apply(lambda bar: Output.from_dict(**{bar + &quot;e&quot;: bar + &quot;f&quot;}), description=&quot;baz&quot;)
&gt;&gt;&gt; p2.parse_args(&quot;bar&quot;)
{'bare': 'barf'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L672-L701" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply(f: Callable[[str], B_monoid], description: str) -&gt; Parser[B_monoid]:
    &#34;&#34;&#34;
    A shortcut for
    ```python
    item(description).apply(f)
    ```
    and spares `f` the trouble of outputting a `Result` object.
    Here is an example of usage. First we define a simple `argument` parser:

    &gt;&gt;&gt; p1 = argument(&#34;foo&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;bar&#34;)
    {&#39;foo&#39;: &#39;bar&#39;}

    Here we use `f` to directly manipulate the binding generated by `item`:
    &gt;&gt;&gt; p2 = apply(lambda bar: Output.from_dict(**{bar + &#34;e&#34;: bar + &#34;f&#34;}), description=&#34;baz&#34;)
    &gt;&gt;&gt; p2.parse_args(&#34;bar&#34;)
    {&#39;bare&#39;: &#39;barf&#39;}
    &#34;&#34;&#34;

    def g(out: Output[Sequence[KeyValue[str]]]) -&gt; Result[B_monoid]:
        *_, (_, v) = map(astuple, out.get)
        assert v is not None  # because item produces output
        try:
            y = f(v)
        except Exception as e:
            usage = f&#34;argument {v} raised exception {e}&#34;
            return Result(ArgumentError(usage))
        return Result.return_(y)

    return item(description).apply(g)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.argument"><code class="name flex">
<span>def <span class="ident">argument</span></span>(<span>dest:str, help:Optional[str]=None, type:Optional[Callable[[str],Any]]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a single word and binds it to <code>dest</code>.
Useful for positional arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of variable to bind to:</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The help message to display for the option:</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Optional[Callable[[str], Any]]</code></dt>
<dd>Use the <code>type</code> argument to convert the input to a different type:</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;name&quot;).parse_args(&quot;Alice&quot;)
{'name': 'Alice'}
&gt;&gt;&gt; argument(&quot;name&quot;).parse_args()
**```usage```** :&amp;ensp;&lt;code&gt;NAME&lt;/code&gt;
:   &amp;nbsp;


The following arguments are required: name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L704-L735" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def argument(
    dest: str, help: Optional[str] = None, type: Optional[Callable[[str], Any]] = None
) -&gt; Parser[Output]:
    &#34;&#34;&#34;
    Parses a single word and binds it to `dest`.
    Useful for positional arguments.

    Parameters
    ----------
    dest : str
        The name of variable to bind to:

    help : Optional[str]
        The help message to display for the option:

    type : Optional[Callable[[str], Any]]
        Use the `type` argument to convert the input to a different type:

    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args()
    usage: NAME
    The following arguments are required: name
    &#34;&#34;&#34;
    parser = item(dest)
    _type: Callable[[str], Any] = str if type is None else type  # type: ignore[assignment]
    # Mypy doesn&#39;t know that types also have type Callable[[str], Any]
    if _type is not str:
        parser = parser.type(_type)
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=dest.upper(), helps=helps)
    return parser</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.binary_usage"><code class="name flex">
<span>def <span class="ident">binary_usage</span></span>(<span>a:Optional[str], op:str, b:Optional[str], add_brackets=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility for generating usage strings for binary operators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L62-L70" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def binary_usage(a: Optional[str], op: str, b: Optional[str], add_brackets=True):
    &#34;&#34;&#34;
    Utility for generating usage strings for binary operators.
    &#34;&#34;&#34;
    no_nones = [x for x in (a, b) if x is not None]
    usage = op.join(no_nones)
    if len(no_nones) &gt; 1 and add_brackets:
        usage = f&#34;[{usage}]&#34;
    return usage or None</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.defaults"><code class="name flex">
<span>def <span class="ident">defaults</span></span>(<span>**kwargs:A) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[~A]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Useful for assigning default values to arguments.
It ignore the input and always returns <code>kwargs</code> converted into <code>CollisionDict</code>.
<code><a title="dollar_lambda.parser.defaults" href="#dollar_lambda.parser.defaults">defaults()</a></code> never failsekpoi</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; defaults(a=1, b=2).parse_args()
{'a': 1, 'b': 2}
&gt;&gt;&gt; (flag(&quot;fails&quot;) | defaults(fails=&quot;succeeds&quot;)).parse_args()
{'fails': 'succeeds'}
</code></pre>
<p>Here's a more complex example derived from the tutorial:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (
...         flag(&quot;verbose&quot;) + defaults(quiet=False)  # either --verbose and default &quot;quiet&quot; to False
...         | flag(&quot;quiet&quot;) + defaults(verbose=False)  # or --quiet and default &quot;verbose&quot; to False
...     ),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... )
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'quiet': False}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L738-L765" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def defaults(**kwargs: A) -&gt; Parser[Output[Sequence[KeyValue[A]]]]:
    &#34;&#34;&#34;
    Useful for assigning default values to arguments.
    It ignore the input and always returns `kwargs` converted into `CollisionDict`.
    `defaults` never failsekpoi

    &gt;&gt;&gt; defaults(a=1, b=2).parse_args()
    {&#39;a&#39;: 1, &#39;b&#39;: 2}
    &gt;&gt;&gt; (flag(&#34;fails&#34;) | defaults(fails=&#34;succeeds&#34;)).parse_args()
    {&#39;fails&#39;: &#39;succeeds&#39;}

    Here&#39;s a more complex example derived from the tutorial:
    &gt;&gt;&gt; p = nonpositional(
    ...     (
    ...         flag(&#34;verbose&#34;) + defaults(quiet=False)  # either --verbose and default &#34;quiet&#34; to False
    ...         | flag(&#34;quiet&#34;) + defaults(verbose=False)  # or --quiet and default &#34;verbose&#34; to False
    ...     ),
    ...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
    ...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
    ... )

    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
    {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}
    &#34;&#34;&#34;
    p = Parser[Output[A_monoid]].return_(
        Output[Sequence[KeyValue[A]]].from_dict(**kwargs)
    )
    return replace(p, usage=None)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.flag"><code class="name flex">
<span>def <span class="ident">flag</span></span>(<span>dest:str, default:Optional[bool]=None, help:Optional[str]=None, short:bool=True, string:Optional[str]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[bool]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Binds a boolean value to a variable.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>The variable to which the value will be bound.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>An optional default value.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>An optional help string.</dd>
<dt><strong><code>short</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to check for the short form of the flag, which
uses a single dash and the first character of <code>dest</code>, e.g. <code>-f</code> for <code>foo</code>.</dd>
<dt><strong><code>string</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>A custom string to use for the flag. Defaults to <code>--{dest}</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Here is an example using the <code>default</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;, default=False)
&gt;&gt;&gt; p.parse_args()
{'verbose': False}
</code></pre>
<p>By default <code><a title="dollar_lambda.parser.flag" href="#dollar_lambda.parser.flag">flag()</a></code> fails when it does not receive expected input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose
</code></pre>
<p>Here is an example using the <code>help</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;, help=&quot;Turn on verbose output.&quot;)
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: --verbose
verbose: Turn on verbose output.
</code></pre>
<p>Here is an example using the <code>short</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;, short=True).parse_args(&quot;-v&quot;)  # this is the default
{'verbose': True}
&gt;&gt;&gt; flag(&quot;verbose&quot;, short=False).parse_args(&quot;-v&quot;)  # fails
usage: --verbose
Expected '--verbose'. Got '-v'
</code></pre>
<p>Here is an example using the <code>string</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;value&quot;, string=&quot;v&quot;).parse_args(&quot;v&quot;)  # note that string does not have to start with -
{'value': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L836-L925" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flag(
    dest: str,
    default: Optional[bool] = None,
    help: Optional[str] = None,
    short: bool = True,
    string: Optional[str] = None,
) -&gt; Parser[Output[Sequence[KeyValue[bool]]]]:
    &#34;&#34;&#34;
    Binds a boolean value to a variable.

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}


    Parameters
    ----------
    dest : str
        The variable to which the value will be bound.

    default : Optional[bool]
        An optional default value.

    help : Optional[str]
        An optional help string.

    short : bool
        Whether to check for the short form of the flag, which
        uses a single dash and the first character of `dest`, e.g. `-f` for `foo`.

    string : Optional[str]
        A custom string to use for the flag. Defaults to `--{dest}`.

    Examples
    --------

    Here is an example using the `default` parameter:

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, default=False)
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False}

    By default `flag` fails when it does not receive expected input:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args()
    usage: --verbose
    The following arguments are required: --verbose

    Here is an example using the `help` parameter:

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, help=&#34;Turn on verbose output.&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --verbose
    verbose: Turn on verbose output.

    Here is an example using the `short` parameter:

    &gt;&gt;&gt; flag(&#34;verbose&#34;, short=True).parse_args(&#34;-v&#34;)  # this is the default
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; flag(&#34;verbose&#34;, short=False).parse_args(&#34;-v&#34;)  # fails
    usage: --verbose
    Expected &#39;--verbose&#39;. Got &#39;-v&#39;

    Here is an example using the `string` parameter:

    &gt;&gt;&gt; flag(&#34;value&#34;, string=&#34;v&#34;).parse_args(&#34;v&#34;)  # note that string does not have to start with -
    {&#39;value&#39;: True}
    &#34;&#34;&#34;
    if string is None:
        _string = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _string = string

    def f(
        cs: Sequence[str],
        s: str,
    ) -&gt; Result[Parse[Output[Sequence[KeyValue[bool]]]]]:
        parser = matches(s) &gt;= (lambda _: defaults(**{dest: not default}))
        return parser.parse(cs)

    parser = Parser(partial(f, s=_string), usage=None, helps={})
    if short:
        short_string = f&#34;-{dest[0]}&#34;
        parser2 = flag(dest, short=False, string=short_string, default=default)
        parser = parser | parser2
    if default:
        help = f&#34;{help + &#39; &#39; if help else &#39;&#39;}(default: {default})&#34;
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=_string, helps=helps)
    return parser if default is None else parser | defaults(**{dest: default})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.help_parser"><code class="name flex">
<span>def <span class="ident">help_parser</span></span>(<span>usage:Optional[str], parsed:A_monoid) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[~A_monoid]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L928-L937" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def help_parser(usage: Optional[str], parsed: A_monoid) -&gt; Parser[A_monoid]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[A_monoid]]:
        result = (matches(&#34;--help&#34;, peak=True) | matches(&#34;-h&#34;, peak=True)).parse(cs)
        if isinstance(result.get, ArgumentError):
            return Result.return_(Parse(parsed=parsed, unparsed=cs))
        return Result(HelpError(usage=usage or &#34;Usage not provided.&#34;))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.item"><code class="name flex">
<span>def <span class="ident">item</span></span>(<span>name:str, help_name:Optional[str]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[str]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a single word and binds it to <code>dest</code>.
One of the lowest level building blocks for parsers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>help_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Used for generating help text</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = item(&quot;name&quot;, help_name=&quot;Your first name&quot;)
&gt;&gt;&gt; p.parse_args(&quot;Alice&quot;)
{'name': 'Alice'}
&gt;&gt;&gt; p.parse_args()
usage: name
The following arguments are required: Your first name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L940-L984" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def item(
    name: str,
    help_name: Optional[str] = None,
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    &#34;&#34;&#34;
    Parses a single word and binds it to `dest`.
    One of the lowest level building blocks for parsers.

    Parameters
    ----------
    help_name : Optional[str]
        Used for generating help text

    Examples
    --------

    &gt;&gt;&gt; p = item(&#34;name&#34;, help_name=&#34;Your first name&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; p.parse_args()
    usage: name
    The following arguments are required: Your first name
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[Output[Sequence[KeyValue[str]]]]]:
        if cs:
            head, *tail = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Output[Sequence[KeyValue[str]]].from_dict(
                            **{name: head}
                        ),
                        unparsed=Sequence(tail),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {help_name or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.matches"><code class="name flex">
<span>def <span class="ident">matches</span></span>(<span>s:str, peak:bool=False, regex:bool=True) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[str]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the next word is <code>s</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; matches(&quot;hello&quot;).parse_args(&quot;hello&quot;)
{'hello': 'hello'}
&gt;&gt;&gt; matches(&quot;hello&quot;).parse_args(&quot;goodbye&quot;)
usage: hello
Expected 'hello'. Got 'goodbye'
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>The word to that input will be checked against for equality.</dd>
<dt><strong><code>peak</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>False</code>, then the parser will consume the word and return the remaining words as <code>unparsed</code>.
If <code>True</code>, then the parser leaves the <code>unparsed</code> component unchanged.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat <code>s</code> as a regular expression. If <code>False</code>, then the parser will only succeed on
string equality.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = matches(&quot;hello&quot;) &gt;&gt; matches(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
{'hello': 'hello', 'goodbye': 'goodbye'}
</code></pre>
<p>Look what happens when <code>peak=True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = matches(&quot;hello&quot;, peak=True) &gt;&gt; matches(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
usage: hello goodbye
Expected 'goodbye'. Got 'hello'
</code></pre>
<p>The first parser didn't consume the word and so "hello" got passed on to <code>equals("goodbye")</code>.
But this would work:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = matches(&quot;hello&quot;, peak=True) &gt;&gt; matches(&quot;hello&quot;) &gt;&gt; matches(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
{'hello': ['hello', 'hello'], 'goodbye': 'goodbye'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L768-L833" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def matches(
    s: str, peak: bool = False, regex: bool = True
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    &#34;&#34;&#34;
    Checks if the next word is `s`.

    &gt;&gt;&gt; matches(&#34;hello&#34;).parse_args(&#34;hello&#34;)
    {&#39;hello&#39;: &#39;hello&#39;}
    &gt;&gt;&gt; matches(&#34;hello&#34;).parse_args(&#34;goodbye&#34;)
    usage: hello
    Expected &#39;hello&#39;. Got &#39;goodbye&#39;

    Parameters
    ----------
    s: str
        The word to that input will be checked against for equality.
    peak : bool
        If `False`, then the parser will consume the word and return the remaining words as `unparsed`.
        If `True`, then the parser leaves the `unparsed` component unchanged.

    regex : bool
        Whether to treat `s` as a regular expression. If `False`, then the parser will only succeed on
        string equality.

    Examples
    --------

    &gt;&gt;&gt; p = matches(&#34;hello&#34;) &gt;&gt; matches(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    {&#39;hello&#39;: &#39;hello&#39;, &#39;goodbye&#39;: &#39;goodbye&#39;}

    Look what happens when `peak=True`:
    &gt;&gt;&gt; p = matches(&#34;hello&#34;, peak=True) &gt;&gt; matches(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    usage: hello goodbye
    Expected &#39;goodbye&#39;. Got &#39;hello&#39;

    The first parser didn&#39;t consume the word and so &#34;hello&#34; got passed on to `equals(&#34;goodbye&#34;)`.
    But this would work:
    &gt;&gt;&gt; p = matches(&#34;hello&#34;, peak=True) &gt;&gt; matches(&#34;hello&#34;) &gt;&gt; matches(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    {&#39;hello&#39;: [&#39;hello&#39;, &#39;hello&#39;], &#39;goodbye&#39;: &#39;goodbye&#39;}
    &#34;&#34;&#34;

    def predicate(_s: str) -&gt; bool:
        if regex:
            return bool(re.match(s, _s))
        else:
            return s == _s

    if peak:
        return sat_peak(
            predicate=predicate,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )
    else:
        return sat(
            predicate=predicate,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.nonpositional"><code class="name flex">
<span>def <span class="ident">nonpositional</span></span>(<span>*parsers:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output[A_monoid]]'", repeated:Optional[<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output[A_monoid]]]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.parser.nonpositional" href="#dollar_lambda.parser.nonpositional">nonpositional()</a></code> takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>repeated</code></strong> :&ensp;<code>Optional[<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[A]]]</code></dt>
<dd>If provided, this parser gets applied repeatedly (zero or more times) at all positions.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(repeated=flag(&quot;x&quot;))
&gt;&gt;&gt; p.parse_args()
{}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;)
{'x': True}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-x&quot;)
{'x': [True, True]}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;y&quot;), repeated=flag(&quot;x&quot;))
&gt;&gt;&gt; p.parse_args(&quot;-y&quot;)
{'y': True}
&gt;&gt;&gt; p.parse_args(&quot;-y&quot;, &quot;-x&quot;)
{'y': True, 'x': True}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-y&quot;)
{'x': True, 'y': True}
&gt;&gt;&gt; p.parse_args(&quot;-y&quot;, &quot;-x&quot;, &quot;-x&quot;)
{'y': True, 'x': [True, True]}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-y&quot;, &quot;-x&quot;)
{'x': [True, True], 'y': True}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-x&quot;, &quot;-y&quot;)
{'x': [True, True], 'y': True}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;y&quot;), repeated=(flag(&quot;x&quot;) | flag(&quot;z&quot;)).ignore())
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-y&quot;, &quot;-z&quot;)
{'y': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L987-L1064" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nonpositional(
    *parsers: &#34;Parser[Output[A_monoid]]&#34;,
    repeated: Optional[Parser[Output[A_monoid]]] = None,
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    `nonpositional` takes a sequence of parsers as arguments and attempts all permutations of them,
    returning the first permutations that is successful:

    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
    {&#39;verbose&#39;: True, &#39;quiet&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
    {&#39;quiet&#39;: True, &#39;verbose&#39;: True}

    Parameters
    ----------
    repeated : Optional[Parser[Sequence[A]]]
        If provided, this parser gets applied repeatedly (zero or more times) at all positions.

    Examples
    --------
    &gt;&gt;&gt; p = nonpositional(repeated=flag(&#34;x&#34;))
    &gt;&gt;&gt; p.parse_args()
    {}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;)
    {&#39;x&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-x&#34;)
    {&#39;x&#39;: [True, True]}

    &gt;&gt;&gt; p = nonpositional(flag(&#34;y&#34;), repeated=flag(&#34;x&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;-y&#34;)
    {&#39;y&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-y&#34;, &#34;-x&#34;)
    {&#39;y&#39;: True, &#39;x&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-y&#34;)
    {&#39;x&#39;: True, &#39;y&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-y&#34;, &#34;-x&#34;, &#34;-x&#34;)
    {&#39;y&#39;: True, &#39;x&#39;: [True, True]}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-y&#34;, &#34;-x&#34;)
    {&#39;x&#39;: [True, True], &#39;y&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-x&#34;, &#34;-y&#34;)
    {&#39;x&#39;: [True, True], &#39;y&#39;: True}

    &gt;&gt;&gt; p = nonpositional(flag(&#34;y&#34;), repeated=(flag(&#34;x&#34;) | flag(&#34;z&#34;)).ignore())
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-y&#34;, &#34;-z&#34;)
    {&#39;y&#39;: True}
    &#34;&#34;&#34;
    sep = &#34; &#34; if len(parsers) &lt;= 3 else &#34;\n&#34;
    _parsers = [*parsers] if repeated is None else [*parsers, repeated]
    usage = sep.join([p.usage or &#34;&#34; for p in _parsers])
    repeat_parser = None
    if repeated is not None:
        _repeated = repeated  # for mypy&#39;s benefit

        def f(cs: Sequence[str]):
            p = _repeated &gt;&gt; nonpositional(*parsers, repeated=repeated)
            return p.parse(cs)

        repeat_parser = Parser(f, usage=None, helps={})

    if not parsers:
        if repeat_parser is None:
            return Parser[Output[A_monoid]].empty()
        else:
            return repeat_parser | Parser[Output[A_monoid]].empty()

    def get_alternatives():
        if repeat_parser is not None:
            yield repeat_parser
        for i, head in enumerate(parsers):
            tail = [p for j, p in enumerate(parsers) if j != i]
            yield head &gt;&gt; nonpositional(*tail, repeated=repeated)

    parser = reduce(operator.or_, get_alternatives())
    helps = parser.helps
    if repeated is not None:
        helps = {**helps, **repeated.helps}
    return replace(parser, usage=usage, helps=helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.option"><code class="name flex">
<span>def <span class="ident">option</span></span>(<span>dest:str, flag:Optional[str]=None, default:Any=None, help:Optional[str]=None, short:bool=True, type:Callable[[str],Any]=builtins.str) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[typing.Any]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses two words, binding the second to the first.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of variable to bind to:</dd>
<dt><strong><code>flag</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The flag to use for the option. If not provided, defaults to <code>--{dest}</code>.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>The default value to bind on failure:</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The help message to display for the option:</dd>
<dt><strong><code>short</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to check for the short form of the flag, which
uses a single dash and the first character of <code>dest</code>, e.g. <code>-c</code> for <code>count</code>.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Callable[[str], Any]</code></dt>
<dd>Use the <code>type</code> argument to convert the input to a different type:</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;).parse_args(&quot;--count&quot;, &quot;1&quot;)
{'count': '1'}
</code></pre>
<p>In this example, you can see that the <code><a title="dollar_lambda.parser.flag" href="#dollar_lambda.parser.flag">flag()</a></code> parameter allows the user to
specify an arbitrary lead string, including one that doesn't start with a dash.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, flag=&quot;ct&quot;).parse_args(&quot;ct&quot;, &quot;1&quot;)
{'count': '1'}
</code></pre>
<p>This example demonstrates the use of the <code>default</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, default=2).parse_args()
{'count': 2}
</code></pre>
<p>Here we specify a help-string using the <code>help</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, help=&quot;The number we should count to&quot;).parse_args(&quot;-h&quot;)
usage: --count COUNT
count: The number we should count to
</code></pre>
<p>This example demonstrates the difference between <code>short=True</code> and <code>short=False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, short=True).parse_args(&quot;-c&quot;, &quot;1&quot;)
{'count': '1'}
&gt;&gt;&gt; option(&quot;count&quot;, short=False).parse_args(&quot;-c&quot;, &quot;1&quot;)
usage: --count COUNT
Expected '--count'. Got '-c'
</code></pre>
<p>As with <a href="https://docs.python.org/3/library/argparse.html#argument-parsing">argparse</a>,
the <code>type</code> argument allows you to convert the input to a different type using a
function that takes a single string argument:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;, type=int).parse_args(&quot;-x&quot;, &quot;1&quot;)  # converts &quot;1&quot; to an int
{'x': 1}
&gt;&gt;&gt; option(&quot;x&quot;, type=lambda x: int(x) + 1).parse_args(&quot;-x&quot;, &quot;1&quot;)
{'x': 2}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L1067-L1159" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def option(
    dest: str,
    flag: Optional[str] = None,
    default: Any = None,
    help: Optional[str] = None,
    short: bool = True,
    type: Callable[[str], Any] = str,
) -&gt; Parser[Output[Sequence[KeyValue[Any]]]]:
    &#34;&#34;&#34;
    Parses two words, binding the second to the first.

    Parameters
    ----------
    dest : str
        The name of variable to bind to:

    flag : Optional[str]
        The flag to use for the option. If not provided, defaults to `--{dest}`.

    default : Optional[Any]
        The default value to bind on failure:

    help : Optional[str]
        The help message to display for the option:

    short : bool
        Whether to check for the short form of the flag, which
        uses a single dash and the first character of `dest`, e.g. `-c` for `count`.

    type : Callable[[str], Any]
        Use the `type` argument to convert the input to a different type:

    Examples
    --------

    &gt;&gt;&gt; option(&#34;count&#34;).parse_args(&#34;--count&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}

    In this example, you can see that the `flag` parameter allows the user to
    specify an arbitrary lead string, including one that doesn&#39;t start with a dash.

    &gt;&gt;&gt; option(&#34;count&#34;, flag=&#34;ct&#34;).parse_args(&#34;ct&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}

    This example demonstrates the use of the `default` parameter:

    &gt;&gt;&gt; option(&#34;count&#34;, default=2).parse_args()
    {&#39;count&#39;: 2}

    Here we specify a help-string using the `help` parameter:

    &gt;&gt;&gt; option(&#34;count&#34;, help=&#34;The number we should count to&#34;).parse_args(&#34;-h&#34;)
    usage: --count COUNT
    count: The number we should count to

    This example demonstrates the difference between `short=True` and `short=False`:

    &gt;&gt;&gt; option(&#34;count&#34;, short=True).parse_args(&#34;-c&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}
    &gt;&gt;&gt; option(&#34;count&#34;, short=False).parse_args(&#34;-c&#34;, &#34;1&#34;)
    usage: --count COUNT
    Expected &#39;--count&#39;. Got &#39;-c&#39;

    As with [argparse](https://docs.python.org/3/library/argparse.html#argument-parsing),
    the `type` argument allows you to convert the input to a different type using a
    function that takes a single string argument:

    &gt;&gt;&gt; option(&#34;x&#34;, type=int).parse_args(&#34;-x&#34;, &#34;1&#34;)  # converts &#34;1&#34; to an int
    {&#39;x&#39;: 1}
    &gt;&gt;&gt; option(&#34;x&#34;, type=lambda x: int(x) + 1).parse_args(&#34;-x&#34;, &#34;1&#34;)
    {&#39;x&#39;: 2}
    &#34;&#34;&#34;

    if flag is None:
        _flag = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _flag = flag

    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Output[Sequence[KeyValue[str]]]]]:
        parser = matches(_flag) &gt;= (lambda _: item(dest, help_name=dest.upper()))
        return parser.parse(cs)

    parser = Parser(f, usage=None, helps={})
    if type is not str:
        parser = parser.type(type)
    if short and len(dest) &gt; 1:
        parser2 = option(dest=dest, short=False, flag=f&#34;-{dest[0]}&#34;, default=None)
        parser = parser | parser2
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=f&#34;{_flag} {dest.upper()}&#34;, helps=helps)
    return parser if default is None else parser | defaults(**{dest: default})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.peak"><code class="name flex">
<span>def <span class="ident">peak</span></span>(<span>name:str, description:Optional[str]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[str]]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L1162-L1188" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def peak(
    name: str,
    description: Optional[str] = None,
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Output[Sequence[KeyValue[str]]]]]:
        if cs:
            head, *_ = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Output[Sequence[KeyValue[str]]].from_dict(
                            **{name: head}
                        ),
                        unparsed=Sequence(cs),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {description or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.sat"><code class="name flex">
<span>def <span class="ident">sat</span></span>(<span>predicate:Callable[[str],bool], on_fail:Callable[[str],ArgumentError], name:str) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[str]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code><a title="dollar_lambda.parser.Parser.sat" href="#dollar_lambda.parser.Parser.sat">Parser.sat()</a></code> that uses <code><a title="dollar_lambda.parser.item" href="#dollar_lambda.parser.item">item()</a></code> to parse the argument and just applies <code>predicate</code> to the value output by <code><a title="dollar_lambda.parser.item" href="#dollar_lambda.parser.item">item()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = sat(lambda x: len(x) == 1, lambda x: ArgumentError(f&quot;'{x}' must have exactly one character.&quot;), &quot;x&quot;)
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)  # succeeds
{'x': 'a'}
&gt;&gt;&gt; p.parse_args(&quot;aa&quot;)  # fails
usage: x
'aa' must have exactly one character.
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Callable[[A], bool]</code></dt>
<dd>The predicate to apply to the result of <code><a title="dollar_lambda.parser.item" href="#dollar_lambda.parser.item">item()</a></code>. <code><a title="dollar_lambda.parser.sat" href="#dollar_lambda.parser.sat">sat()</a></code> fails if this predicate returns false.</dd>
<dt><strong><code>on_fail</code></strong> :&ensp;<code>Callable[[A], ArgumentError]</code></dt>
<dd>A function producing an ArgumentError to return if the predicate fails.
Takes the output of <code><a title="dollar_lambda.parser.item" href="#dollar_lambda.parser.item">item()</a></code> as an argument.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The value to bind the result to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L1191-L1225" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sat(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    &#34;&#34;&#34;
    A wrapper around `Parser.sat` that uses `item` to parse the argument and just applies `predicate` to the value output by `item`.

    &gt;&gt;&gt; p = sat(lambda x: len(x) == 1, lambda x: ArgumentError(f&#34;&#39;{x}&#39; must have exactly one character.&#34;), &#34;x&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)  # succeeds
    {&#39;x&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;aa&#34;)  # fails
    usage: x
    &#39;aa&#39; must have exactly one character.

    Parameters
    ----------
    predicate : Callable[[A], bool]
        The predicate to apply to the result of `item`. `sat` fails if this predicate returns false.
    on_fail : Callable[[A], ArgumentError]
        A function producing an ArgumentError to return if the predicate fails.
        Takes the output of `item` as an argument.
    name: str
        The value to bind the result to.
    &#34;&#34;&#34;

    def _predicate(out: Output[Sequence[KeyValue[str]]]) -&gt; bool:
        *_, (_, v) = map(astuple, out.get)
        return predicate(v)

    def _on_fail(out: Output[Sequence[KeyValue[str]]]) -&gt; ArgumentError:
        *_, (_, v) = map(astuple, out.get)
        return on_fail(v)

    return item(name).sat(_predicate, _on_fail)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.sat_peak"><code class="name flex">
<span>def <span class="ident">sat_peak</span></span>(<span>predicate:Callable[[str],bool], on_fail:Callable[[str],ArgumentError], name:str) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[str]]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L1228-L1241" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sat_peak(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    def _predicate(out: Output[Sequence[KeyValue[str]]]) -&gt; bool:
        *_, (_, v) = map(astuple, out.get)
        return predicate(v)

    def _on_fail(out: Output[Sequence[KeyValue[str]]]) -&gt; ArgumentError:
        *_, (_, v) = map(astuple, out.get)
        return on_fail(v)

    return peak(name).sat(_predicate, _on_fail)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dollar_lambda.parser.Parse"><code class="flex name class">
<span>class <span class="ident">Parse</span></span>
<span>(</span><span>parsed:A_co, unparsed:Sequence[str])</span>
</code></dt>
<dd>
<div class="desc"><p>A <code><a title="dollar_lambda.parser.Parse" href="#dollar_lambda.parser.Parse">Parse</a></code> is the output of parsing.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parsed</code></strong> :&ensp;<code>A</code></dt>
<dd>Component parsed by the parsed</dd>
<dt><strong><code>unparsed</code></strong> :&ensp;<code>Sequence[str]</code></dt>
<dd>Component yet to be parsed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L39-L53" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class Parse(Generic[A_co]):
    &#34;&#34;&#34;
    A `Parse` is the output of parsing.

    Parameters
    ----------
    parsed : A
        Component parsed by the parsed
    unparsed : Sequence[str]
        Component yet to be parsed
    &#34;&#34;&#34;

    parsed: A_co
    unparsed: Sequence[str]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.parser.Parse.parsed"><code class="name">var <span class="ident">parsed</span> :+A_co</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.parser.Parse.unparsed"><code class="name">var <span class="ident">unparsed</span> :<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.parser.Parser"><code class="flex name class">
<span>class <span class="ident">Parser</span></span>
<span>(</span><span>f:Callable[[Sequence[str]],Result[<a title="dollar_lambda.parser.Parse" href="#dollar_lambda.parser.Parse">Parse</a>[A_co]]], usage:Optional[str], helps:Dict[str,str])</span>
</code></dt>
<dd>
<div class="desc"><p>Main class powering the argument parser.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L73-L669" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class Parser(MonadPlus[A_co]):
    &#34;&#34;&#34;
    Main class powering the argument parser.
    &#34;&#34;&#34;

    f: Callable[[Sequence[str]], Result[Parse[A_co]]]
    usage: Optional[str]
    helps: Dict[str, str]

    def __add__(
        self: &#34;Parser[Output[A_monoid]]&#34;, other: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        &#34;&#34;&#34;
        Parse two arguments in either order.
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
        {&#39;verbose&#39;: True, &#39;debug&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
        {&#39;debug&#39;: True, &#39;verbose&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
        usage: --verbose --debug
        Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

        Note that if more than two arguments are chained together with `+`, some combinations will not parse:
        &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
        {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
        usage: -a -b -c
        Expected &#39;-b&#39;. Got &#39;-c&#39;

        This makes more sense when one supplies the implicit parentheses:
        &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

        In order to chain together more than two arguments, use `nonpositional`:
        &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
        {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
        &#34;&#34;&#34;
        p = (self &gt;&gt; other) | (other.rshift(self))
        usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
        return replace(p, usage=usage)

    def __ge__(self, f: Callable[[A_co], Monad[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[override]
        return self.bind(f)

    def __or__(  # type: ignore[override]
        self: &#34;Parser[A_monoid]&#34;,
        other: &#34;Parser[B_monoid]&#34;,
    ) -&gt; &#34;Parser[A_monoid | B_monoid]&#34;:
        &#34;&#34;&#34;
        Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

        &gt;&gt;&gt; from dollar_lambda import argument, option, flag
        &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
        {&#39;verbose&#39;: True}

        Note that by default, `parse_args` adds `&gt;&gt; Parser.done()` to the end of parsers, causing
        `p` to fail when both arguments are supplied:

        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        usage: [--option OPTION | --verbose]
        Unrecognized argument: --option

        To disable this behavior, use `allow_unparsed`:
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;, allow_unparsed=True)
        {&#39;verbose&#39;: True}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[&#34;A_monoid | B_monoid&#34;]]:
            return self.parse(cs) | other.parse(cs)

        return Parser(
            f,
            usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
            helps={**self.helps, **other.helps},
        )

    def rshift(
        self: &#34;Parser[Output[A_monoid]]&#34;, p: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        return self &gt;&gt; p

    def __rshift__(
        self: &#34;Parser[Output[A_monoid]]&#34;, p: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        &#34;&#34;&#34;
        This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
        gets handed off to the second parser. If either parser fails, the whole thing fails.

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        usage: FIRST SECOND
        The following arguments are required: second
        &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
        usage: FIRST SECOND
        The following arguments are required: second
        &#34;&#34;&#34;

        def f(p1: Output[A_monoid]) -&gt; Parser[Output[A_monoid | B_monoid]]:
            def g(p2: Output[B_monoid]) -&gt; Parser[Output[A_monoid | B_monoid]]:
                # _p1 = p1 if isinstance(p1, Sequence) else Sequence(p1)
                # _p2 = p2 if isinstance(p2, Sequence) else Sequence(p2)
                return Parser.return_(p1 + p2)

            return p &gt;= g

        parser = self &gt;= f
        # parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
        return replace(
            parser,
            usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False),
            helps={**self.helps, **p.helps},
        )

    def __xor__(
        self: &#34;Parser[Output[A_monoid]]&#34;, other: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        &#34;&#34;&#34;
        This is the same as `__or__`, but it succeeds only if one of the two parsers fails.

        &gt;&gt;&gt; p = argument(&#34;int&#34;, type=int) ^ argument(&#34;div&#34;, type=lambda x: 1 / float(x))
        &gt;&gt;&gt; p.parse_args(&#34;inf&#34;)  # succeeds because int(&#34;inf&#34;) fails
        {&#39;div&#39;: 0.0}
        &gt;&gt;&gt; p.parse_args(&#34;0&#34;)  # succeeds because 1 / 0 throws an error
        {&#39;int&#39;: 0}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)  # fails because both parsers succeed
        Both parsers succeeded. This causes ^ to fail.
        &#34;&#34;&#34;
        p = (self.fails() &gt;&gt; other) | (other.fails() &gt;&gt; self)

        def f(error: ArgumentError) -&gt; ArgumentError:
            if isinstance(error, BinaryError):
                return ArgumentError(&#34;Both parsers succeeded. This causes ^ to fail.&#34;)
            return error

        return p.map_error(f)

    def apply(self: &#34;Parser[A_monoid]&#34;, f: Callable[[A_monoid], Result[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        Takes the output of `parser` and applies `f` to it. Convert any errors that arise into `ArgumentError`.

        &gt;&gt;&gt; p1 = flag(&#34;hello&#34;)
        &gt;&gt;&gt; p1.parse_args(&#34;--hello&#34;)
        {&#39;hello&#39;: True}

        This will double `p1`&#39;s output:
        &gt;&gt;&gt; p2 = p1.apply(lambda out: Result.return_(out + out))
        &gt;&gt;&gt; p2.parse_args(&#34;--hello&#34;)
        {&#39;hello&#39;: [True, True]}
        &#34;&#34;&#34;

        def g(a: A_monoid) -&gt; Parser[B_monoid]:
            try:
                y = f(a)
            except Exception as e:
                usage = f&#34;An argument {a}: raised exception {e}&#34;
                y = Result(ArgumentError(usage))
            return Parser(
                lambda cs: y &gt;= (lambda parsed: Result.return_(Parse(parsed, cs))),
                usage=self.usage,
                helps=self.helps,
            )

        p = self &gt;= g
        return replace(p, usage=self.usage, helps=self.helps)

    def bind(self, f: Callable[[A_co], Monad[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[override]
        &#34;&#34;&#34;
        Returns a new parser that

        1. applies `self`;
        2. if this succeeds, applies `f` to the parsed component of the result.

        `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
        avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
        `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

        Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
        and we typically prefer using the infix operator to the spelled out method.

        Let&#39;s start with our simplest parser, `argument`:
        &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

        Now let&#39;s use the `matches` parser to write a function that takes the output of `p1` and fails unless
        the next argument is the same as the first:
        &gt;&gt;&gt; def f(out: Output[Sequence[KeyValue[Any]]]) -&gt; Parser[Output[str]]:
        ...     *_, kv = out.get
        ...     return matches(kv.value)

        &gt;&gt;&gt; p = p1 &gt;= f
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
        {&#39;a&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        Expected &#39;a&#39;. Got &#39;b&#39;
        &#34;&#34;&#34;

        def h(parse: Parse[A_co]) -&gt; Result[Parse[B_monoid]]:
            y = f(parse.parsed)
            assert isinstance(y, Parser), y
            return y.parse(parse.unparsed)

        def g(cs: Sequence[str]) -&gt; Result[Parse[B_monoid]]:
            return self.parse(cs) &gt;= h

        return Parser(g, usage=None, helps=self.helps)

    @classmethod
    def done(
        cls: Type[&#34;Parser[Output[A_monoid]]&#34;], a: Optional[Type[A_monoid]] = None
    ) -&gt; Parser[Output[Any]]:
        &#34;&#34;&#34;
        `done` succeds on the end of input and fails on everything else.
        &gt;&gt;&gt; Parser.done().parse_args()
        {}
        &gt;&gt;&gt; Parser.done().parse_args(&#34;arg&#34;)
        Unrecognized argument: arg

        Without `done` the parser will not complain about leftover (unparsed) input:

        &gt;&gt;&gt; flag(&#34;verbose&#34;).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, allow_unparsed=True)
        {&#39;verbose&#39;: True}

        When `allow_unparsed=False` (the default), `parse_args` adds `&gt;&gt; Parser.done()`
        to the end of the parser:
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[Output[Any]]]:
            if cs:
                c, *_ = cs
                return Result(
                    UnexpectedError(unexpected=c, usage=f&#34;Unrecognized argument: {c}&#34;)
                )
            return Result(NonemptyList(Parse(parsed=Output.zero(a), unparsed=cs)))

        return Parser(f, usage=None, helps={})

    @classmethod
    def empty(
        cls: Type[&#34;Parser[Output[A_monoid]]&#34;], a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
        &gt;&gt;&gt; Parser.empty().parse_args(&#34;any&#34;, &#34;arguments&#34;, allow_unparsed=True)
        {}
        &#34;&#34;&#34;
        return cls.return_(Output.zero(a))

    def fails(
        self: &#34;Parser[Output[A_monoid]]&#34;, a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Succeeds only if self fails. Does not consume any input.

        &gt;&gt;&gt; flag(&#34;x&#34;).fails().parse_args(&#34;not x&#34;, allow_unparsed=True)  # succeeds
        {}
        &gt;&gt;&gt; flag(&#34;x&#34;).fails().parse_args(&#34;-x&#34;, allow_unparsed=True)  # fails
        Parser unexpectedly succeeded.
        &#34;&#34;&#34;

        def g(cs: Sequence[str]) -&gt; Result[Parse[Output[A_monoid]]]:
            parse = self.parse(cs).get
            if isinstance(parse, Exception):
                return Result.return_(Parse(Output.zero(a), cs))
            else:
                return Result.zero(
                    error=SuccessError(
                        &#34;Parser unexpectedly succeeded.&#34;, input=cs, output=parse
                    )
                )

        return Parser(g, usage=None, helps=self.helps)

    def handle_error(self, error: ArgumentError) -&gt; None:
        def print_usage(usage: str):
            print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in usage else &#34; &#34;)
            if &#34;\n&#34; in usage:
                usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in usage.split(&#34;\n&#34;)])
            print(usage)
            if self.helps:
                for k, v in self.helps.items():
                    print(f&#34;{k}: {v}&#34;)

        if isinstance(error, HelpError):
            print_usage(error.usage)
        else:
            if self.usage:
                print_usage(self.usage)
            if error.usage:
                print(error.usage)
        if TESTING:
            return
        else:
            exit()

    def ignore(
        self: &#34;Parser[Output[A_monoid]]&#34;, a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Ignores the output from a parser. This is useful when you expect
        to give arguments to the command line that some other utility will
        handle.

        &gt;&gt;&gt; p = flag(&#34;hello&#34;).ignore()

        This will not bind any value to `&#34;hello&#34;`:
        &gt;&gt;&gt; p.parse_args(&#34;--hello&#34;)
        {}

        But `--hello` is still required:
        &gt;&gt;&gt; p.parse_args()
        The following arguments are required: --hello
        &#34;&#34;&#34;

        def g(keep: Parse[Output[A_monoid]]) -&gt; Result[Parse[Output[A_monoid]]]:
            return Result(NonemptyList(Parse(Output.zero(a), keep.unparsed)))

        def f(cs: Sequence[str]) -&gt; Result[Parse[Output[A_monoid]]]:
            return self.parse(cs) &gt;= g

        return Parser(f, usage=None, helps={})

    def many(
        self: &#34;Parser[Output[A_monoid]]&#34;, max: Optional[int] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Applies `self` zero or more times (like `*` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args()
        {}
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        {&#39;as-many-as-you-like&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;as-many-as-you-like&#39;: [&#39;a&#39;, &#39;b&#39;]}

        Note that if `self` contains `Parser.__or__`, the arguments can be
        heterogenous:
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
        &gt;&gt;&gt; p = p.many()
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;) # mix --verbose and --quiet
        {&#39;verbose&#39;: True, &#39;quiet&#39;: True}
        &#34;&#34;&#34;
        if max == 0:
            p = self.empty()
        else:
            if max is not None:
                max -= 1
                assert max &gt;= 0, max
            p = self.many1(max=max) | self.empty()
        return replace(p, usage=f&#34;[{self.usage} ...]&#34;)

    def many1(
        self: &#34;Parser[Output[A_monoid]]&#34;, max: Optional[int] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Applies `self` one or more times (like `+` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
        {&#39;1-or-more&#39;: &#39;1&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;)
        {&#39;1-or-more&#39;: [&#39;1&#39;, &#39;2&#39;]}
        &gt;&gt;&gt; p.parse_args()
        usage: 1-OR-MORE [1-OR-MORE ...]
        The following arguments are required: 1-or-more
        &#34;&#34;&#34;

        @lru_cache()
        def f(cs: tuple):
            y = self &gt;&gt; self.many(max=max)
            return y.parse(Sequence(list(cs)))

        return Parser(
            lambda cs: f(tuple(cs)),
            usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
            helps=self.helps,
        )

    def map_error(self, f: Callable[[ArgumentError], ArgumentError]) -&gt; &#34;Parser[A_co]&#34;:
        def g(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
            parse = self.parse(cs)
            if isinstance(parse.get, ArgumentError):
                return Result.zero(error=f(parse.get))
            else:
                return parse

        return Parser(g, usage=None, helps=self.helps)

    def optional(self: &#34;Parser[Output[A_monoid]]&#34;) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Allows arguments to be optional:
        &gt;&gt;&gt; p1 = flag(&#34;optional&#34;)
        &gt;&gt;&gt; p = p1.optional()
        &gt;&gt;&gt; p.parse_args(&#34;--optional&#34;)
        {&#39;optional&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--misspelled&#34;, allow_unparsed=True)  # succeeds with no output
        {}
        &gt;&gt;&gt; p1.parse_args(&#34;--misspelled&#34;)
        usage: --optional
        Expected &#39;--optional&#39;. Got &#39;--misspelled&#39;
        &#34;&#34;&#34;
        return self | self.empty()

    def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        &#34;&#34;&#34;
        Applies the parser to the input sequence `cs`.
        &#34;&#34;&#34;
        return self.f(cs)

    def parse_args(
        self: &#34;Parser[Output]&#34;,
        *args: str,
        allow_unparsed: bool = False,
        check_help: bool = True,
    ) -&gt; &#34;Optional[Dict[str, Any]]&#34;:
        &#34;&#34;&#34;
        The main way the user extracts parsed results from the parser.

        Parameters
        ----------
        args : str
            A sequence of strings to parse. If empty, defaults to `sys.argv[1:]`.
        allow_unparsed : bool
            Whether to cause parser to fail if there are unparsed inputs. Note that setting this to false
            may cause unexpected behavior when using `nonpositional` or `Args`.
        check_help : bool
            Before running the parser, checks if the input string is `--help` or `-h`.
            If it is, returns the usage message.

        Examples
        --------

        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
        usage: A
        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
        usage: A
        &#34;&#34;&#34;
        _args = args if args or TESTING else sys.argv[1:]
        if not allow_unparsed:
            return (self &gt;&gt; Parser[Output].done()).parse_args(
                *_args,
                allow_unparsed=True,
                check_help=check_help,
            )
        if check_help:
            return self.wrap_help().parse_args(
                *_args,
                allow_unparsed=allow_unparsed,
                check_help=False,
            )
        result = self.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            self.handle_error(result)
            return None
        return result.head.parsed.get.to_dict()

    @classmethod
    def return_(cls, a: A_co) -&gt; &#34;Parser[A_co]&#34;:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
        and always returns `a` as the result. For the most part, the user will not use
        this method unless building custom parsers.

        &gt;&gt;&gt; Parser.return_(Output.from_dict(some_key=&#34;some_value&#34;)).parse_args()
        {&#39;some_key&#39;: &#39;some_value&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
            return Result.return_(Parse(a, cs))

        return Parser(f, usage=None, helps={})

    def sat(
        self: &#34;Parser[A_monoid]&#34;,
        predicate: Callable[[A_monoid], bool],
        on_fail: Callable[[A_monoid], ArgumentError],
    ) -&gt; &#34;Parser[A_monoid]&#34;:
        &#34;&#34;&#34;
        Applies `parser`, applies a predicate to the result and fails if this returns false.

        &gt;&gt;&gt; p = option(&#34;x&#34;, type=int).many().sat(
        ...     lambda out: sum(out.get.values()) &gt; 0,
        ...     lambda out: ArgumentError(f&#34;The values in {list(out.get.values())} must sum to more than 0.&#34;),
        ... )
        &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;1&#34;)  # fails
        usage: [-x X ...]
        The values in [-1, 1] must sum to more than 0.

        &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;2&#34;)  # succeeds
        {&#39;x&#39;: [-1, 2]}

        Parameters
        ----------
        parser : Parser[A]
            The parser to apply.
        predicate : Callable[[A], bool]
            The predicate to apply to the result of `parser`. `sat` fails if this predicate returns false.
        on_fail : Callable[[A], ArgumentError]
            A function producing an ArgumentError to return if the predicate fails.
            Takes the output of `parser` as an argument.
        &#34;&#34;&#34;

        def f(x: A_monoid) -&gt; Result[A_monoid]:
            return Result(NonemptyList(x) if predicate(x) else on_fail(x))

        return self.apply(f)

    def type(
        self: &#34;Parser[Output[Sequence[KeyValue[str]]]]&#34;, f: Callable[[str], Any]
    ) -&gt; &#34;Parser[Output[Sequence[KeyValue[str]]]]&#34;:
        &#34;&#34;&#34;
        A wrapper around `apply` that simply applies `f` to the value of the most recently parsed input.
        &gt;&gt;&gt; p1 = option(&#34;x&#34;) &gt;&gt; option(&#34;y&#34;)
        &gt;&gt;&gt; p = p1.type(int)
        &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)  # converts &#34;1&#34; but not &#34;2&#34;
        {&#39;x&#39;: &#39;1&#39;, &#39;y&#39;: 2}
        &#34;&#34;&#34;

        def g(out: Output[Sequence[KeyValue[str]]]) -&gt; Result[Output]:
            d = out.get
            if not d:
                raise RuntimeError(&#34;Invoked type on a parser that returns no output.&#34;)
            *tail, head = out.get
            try:
                y = f(head.value)
            except Exception as e:
                usage = f&#34;argument {head.value}: raised exception {e}&#34;
                return Result(ArgumentError(usage))
            return Result.return_(Output(Sequence([*tail, KeyValue(head.key, y)])))

        p = self.apply(g)
        return replace(p, usage=self.usage, helps=self.helps)

    def wrap_error(self, error: ArgumentError) -&gt; &#34;Parser[A_co]&#34;:
        return self.map_error(lambda _: error)

    def wrap_help(
        self: &#34;Parser[A_monoid]&#34;, a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[A_monoid]&#34;:
        &#34;&#34;&#34;
        This checks for the `--help` or `-h` flag before applying `parser`.
        If either of the flags is present, returns the usage message for `parser`.

        &gt;&gt;&gt; p = flag(&#34;help&#34;, help=&#34;Print this help message.&#34;).wrap_help()
        &gt;&gt;&gt; p.parse_args(&#34;--help&#34;)
        usage: --help
        help: Print this help message.
        &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
        usage: --help
        help: Print this help message.

        We can use `wrap_help` to print partial usage messages, e.g. for subcommands:
        &gt;&gt;&gt; subcommand1 = matches(&#34;subcommand1&#34;) &gt;&gt; option(&#34;option1&#34;).wrap_help()
        &gt;&gt;&gt; subcommand2 = matches(&#34;subcommand2&#34;) &gt;&gt; option(&#34;option2&#34;).wrap_help()
        &gt;&gt;&gt; p = subcommand1 | subcommand2
        &gt;&gt;&gt; p.parse_args(&#34;subcommand1&#34;, &#34;-h&#34;)
        usage: --option1 OPTION1
        &gt;&gt;&gt; p.parse_args(&#34;subcommand2&#34;, &#34;-h&#34;)
        usage: --option2 OPTION2
        &#34;&#34;&#34;
        _help_parser: Parser[Output[A_monoid]] = help_parser(self.usage, Output.zero(a))

        p = _help_parser &gt;= (lambda _: self)
        return replace(p, usage=self.usage, helps=self.helps)

    @classmethod
    def zero(cls, error: Optional[ArgumentError] = None) -&gt; &#34;Parser[A_co]&#34;:
        &#34;&#34;&#34;
        This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

        Parameters
        ----------
        error : Optional[ArgumentError]
            Customize the error returned by `zero`.

        &gt;&gt;&gt; Parser.zero().parse_args()
        zero
        &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
        zero
        &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
        This is a test.
        &#34;&#34;&#34;
        return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pytypeclass.monoid.MonadPlus</li>
<li>pytypeclass.monad.Monad</li>
<li>pytypeclass.monoid.Monoid</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.parser.Parser.f"><code class="name">var <span class="ident">f</span> :Callable[[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[str]],<a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="#dollar_lambda.parser.Parse">Parse</a>[+A_co]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.parser.Parser.helps"><code class="name">var <span class="ident">helps</span> :Dict[str,str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.parser.Parser.usage"><code class="name">var <span class="ident">usage</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dollar_lambda.parser.Parser.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>a:Optional[Type[A_monoid]]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p><code>done</code> succeds on the end of input and fails on everything else.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.done().parse_args()
{}
&gt;&gt;&gt; Parser.done().parse_args(&quot;arg&quot;)
Unrecognized argument: arg
</code></pre>
<p>Without <code>done</code> the parser will not complain about leftover (unparsed) input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;, allow_unparsed=True)
{'verbose': True}
</code></pre>
<p>When <code>allow_unparsed=False</code> (the default), <code>parse_args</code> adds <code>&gt;&gt; Parser.done()</code>
to the end of the parser:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L288-L316" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def done(
    cls: Type[&#34;Parser[Output[A_monoid]]&#34;], a: Optional[Type[A_monoid]] = None
) -&gt; Parser[Output[Any]]:
    &#34;&#34;&#34;
    `done` succeds on the end of input and fails on everything else.
    &gt;&gt;&gt; Parser.done().parse_args()
    {}
    &gt;&gt;&gt; Parser.done().parse_args(&#34;arg&#34;)
    Unrecognized argument: arg

    Without `done` the parser will not complain about leftover (unparsed) input:

    &gt;&gt;&gt; flag(&#34;verbose&#34;).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, allow_unparsed=True)
    {&#39;verbose&#39;: True}

    When `allow_unparsed=False` (the default), `parse_args` adds `&gt;&gt; Parser.done()`
    to the end of the parser:
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[Output[Any]]]:
        if cs:
            c, *_ = cs
            return Result(
                UnexpectedError(unexpected=c, usage=f&#34;Unrecognized argument: {c}&#34;)
            )
        return Result(NonemptyList(Parse(parsed=Output.zero(a), unparsed=cs)))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>a:Optional[Type[A_monoid]]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Always returns {}, no matter the input. Mostly useful for use in <code><a title="dollar_lambda.parser.nonpositional" href="#dollar_lambda.parser.nonpositional">nonpositional()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.empty().parse_args(&quot;any&quot;, &quot;arguments&quot;, allow_unparsed=True)
{}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L318-L327" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def empty(
    cls: Type[&#34;Parser[Output[A_monoid]]&#34;], a: Optional[Type[A_monoid]] = None
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
    &gt;&gt;&gt; Parser.empty().parse_args(&#34;any&#34;, &#34;arguments&#34;, allow_unparsed=True)
    {}
    &#34;&#34;&#34;
    return cls.return_(Output.zero(a))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.return_"><code class="name flex">
<span>def <span class="ident">return_</span></span>(<span>a:A_co) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"><p>This method is required to make <code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. It consumes none of the input
and always returns <code>a</code> as the result. For the most part, the user will not use
this method unless building custom parsers.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.return_(Output.from_dict(some_key=&quot;some_value&quot;)).parse_args()
{'some_key': 'some_value'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L542-L557" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def return_(cls, a: A_co) -&gt; &#34;Parser[A_co]&#34;:  # type: ignore[misc]
    # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
    &#34;&#34;&#34;
    This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
    and always returns `a` as the result. For the most part, the user will not use
    this method unless building custom parsers.

    &gt;&gt;&gt; Parser.return_(Output.from_dict(some_key=&#34;some_value&#34;)).parse_args()
    {&#39;some_key&#39;: &#39;some_value&#39;}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        return Result.return_(Parse(a, cs))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.zero"><code class="name flex">
<span>def <span class="ident">zero</span></span>(<span>error:Optional[ArgumentError]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"><p>This parser always fails. This method is necessary to make <code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13"><code>Monoid</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>error</code></strong> :&ensp;<code>Optional[ArgumentError]</code></dt>
<dd>Customize the error returned by <code>zero</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.zero().parse_args()
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero().parse_args(&quot;a&quot;)
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero(error=ArgumentError(&quot;This is a test.&quot;)).parse_args(&quot;a&quot;)
This is a test.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L652-L669" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def zero(cls, error: Optional[ArgumentError] = None) -&gt; &#34;Parser[A_co]&#34;:
    &#34;&#34;&#34;
    This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

    Parameters
    ----------
    error : Optional[ArgumentError]
        Customize the error returned by `zero`.

    &gt;&gt;&gt; Parser.zero().parse_args()
    zero
    &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
    zero
    &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
    This is a test.
    &#34;&#34;&#34;
    return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.parser.Parser.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[A_monoid]'", f:Callable[[A_monoid],Result[B_monoid]]) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[~B_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the output of <code>parser</code> and applies <code>f</code> to it. Convert any errors that arise into <code>ArgumentError</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;hello&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;--hello&quot;)
{'hello': True}
</code></pre>
<p>This will double <code>p1</code>'s output:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p2 = p1.apply(lambda out: Result.return_(out + out))
&gt;&gt;&gt; p2.parse_args(&quot;--hello&quot;)
{'hello': [True, True]}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L218-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply(self: &#34;Parser[A_monoid]&#34;, f: Callable[[A_monoid], Result[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[misc]
    # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
    &#34;&#34;&#34;
    Takes the output of `parser` and applies `f` to it. Convert any errors that arise into `ArgumentError`.

    &gt;&gt;&gt; p1 = flag(&#34;hello&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;--hello&#34;)
    {&#39;hello&#39;: True}

    This will double `p1`&#39;s output:
    &gt;&gt;&gt; p2 = p1.apply(lambda out: Result.return_(out + out))
    &gt;&gt;&gt; p2.parse_args(&#34;--hello&#34;)
    {&#39;hello&#39;: [True, True]}
    &#34;&#34;&#34;

    def g(a: A_monoid) -&gt; Parser[B_monoid]:
        try:
            y = f(a)
        except Exception as e:
            usage = f&#34;An argument {a}: raised exception {e}&#34;
            y = Result(ArgumentError(usage))
        return Parser(
            lambda cs: y &gt;= (lambda parsed: Result.return_(Parse(parsed, cs))),
            usage=self.usage,
            helps=self.helps,
        )

    p = self &gt;= g
    return replace(p, usage=self.usage, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.bind"><code class="name flex">
<span>def <span class="ident">bind</span></span>(<span>self, f:Callable[[A_co],Monad[B_monoid]]) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[~B_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new parser that</p>
<ol>
<li>applies <code>self</code>;</li>
<li>if this succeeds, applies <code>f</code> to the parsed component of the result.</li>
</ol>
<p><code>bind</code> is one of the functions that makes <code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. But most users will
avoid using it directly, preferring higher level combinators like <code>&gt;&gt;</code> (<code>Parser.__rshift__</code>),
<code>|</code> (<code>Parser.__or__</code>) and <code>+</code> (<code>Parser.__add__</code>).</p>
<p>Note that <code>&gt;=</code> as a synonym for <code>bind</code> (as defined in <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26"><code>pytypeclass</code></a>)
and we typically prefer using the infix operator to the spelled out method.</p>
<p>Let's start with our simplest parser, <code><a title="dollar_lambda.parser.argument" href="#dollar_lambda.parser.argument">argument()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = argument(&quot;some_dest&quot;)
</code></pre>
<p>Now let's use the <code><a title="dollar_lambda.parser.matches" href="#dollar_lambda.parser.matches">matches()</a></code> parser to write a function that takes the output of <code>p1</code> and fails unless
the next argument is the same as the first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(out: Output[Sequence[KeyValue[Any]]]) -&gt; Parser[Output[str]]:
...     *_, kv = out.get
...     return matches(kv.value)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = p1 &gt;= f
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;a&quot;)
{'a': 'a'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
Expected 'a'. Got 'b'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L248-L286" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bind(self, f: Callable[[A_co], Monad[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[override]
    &#34;&#34;&#34;
    Returns a new parser that

    1. applies `self`;
    2. if this succeeds, applies `f` to the parsed component of the result.

    `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
    avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
    `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

    Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
    and we typically prefer using the infix operator to the spelled out method.

    Let&#39;s start with our simplest parser, `argument`:
    &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

    Now let&#39;s use the `matches` parser to write a function that takes the output of `p1` and fails unless
    the next argument is the same as the first:
    &gt;&gt;&gt; def f(out: Output[Sequence[KeyValue[Any]]]) -&gt; Parser[Output[str]]:
    ...     *_, kv = out.get
    ...     return matches(kv.value)

    &gt;&gt;&gt; p = p1 &gt;= f
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
    {&#39;a&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    Expected &#39;a&#39;. Got &#39;b&#39;
    &#34;&#34;&#34;

    def h(parse: Parse[A_co]) -&gt; Result[Parse[B_monoid]]:
        y = f(parse.parsed)
        assert isinstance(y, Parser), y
        return y.parse(parse.unparsed)

    def g(cs: Sequence[str]) -&gt; Result[Parse[B_monoid]]:
        return self.parse(cs) &gt;= h

    return Parser(g, usage=None, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.fails"><code class="name flex">
<span>def <span class="ident">fails</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output[A_monoid]]'", a:Optional[Type[A_monoid]]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Succeeds only if self fails. Does not consume any input.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;x&quot;).fails().parse_args(&quot;not x&quot;, allow_unparsed=True)  # succeeds
{}
&gt;&gt;&gt; flag(&quot;x&quot;).fails().parse_args(&quot;-x&quot;, allow_unparsed=True)  # fails
Parser unexpectedly succeeded.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L329-L352" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fails(
    self: &#34;Parser[Output[A_monoid]]&#34;, a: Optional[Type[A_monoid]] = None
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Succeeds only if self fails. Does not consume any input.

    &gt;&gt;&gt; flag(&#34;x&#34;).fails().parse_args(&#34;not x&#34;, allow_unparsed=True)  # succeeds
    {}
    &gt;&gt;&gt; flag(&#34;x&#34;).fails().parse_args(&#34;-x&#34;, allow_unparsed=True)  # fails
    Parser unexpectedly succeeded.
    &#34;&#34;&#34;

    def g(cs: Sequence[str]) -&gt; Result[Parse[Output[A_monoid]]]:
        parse = self.parse(cs).get
        if isinstance(parse, Exception):
            return Result.return_(Parse(Output.zero(a), cs))
        else:
            return Result.zero(
                error=SuccessError(
                    &#34;Parser unexpectedly succeeded.&#34;, input=cs, output=parse
                )
            )

    return Parser(g, usage=None, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.handle_error"><code class="name flex">
<span>def <span class="ident">handle_error</span></span>(<span>self, error:ArgumentError) <span style="white-space: nowrap;">-></span>None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L354-L374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def handle_error(self, error: ArgumentError) -&gt; None:
    def print_usage(usage: str):
        print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in usage else &#34; &#34;)
        if &#34;\n&#34; in usage:
            usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in usage.split(&#34;\n&#34;)])
        print(usage)
        if self.helps:
            for k, v in self.helps.items():
                print(f&#34;{k}: {v}&#34;)

    if isinstance(error, HelpError):
        print_usage(error.usage)
    else:
        if self.usage:
            print_usage(self.usage)
        if error.usage:
            print(error.usage)
    if TESTING:
        return
    else:
        exit()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.ignore"><code class="name flex">
<span>def <span class="ident">ignore</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output[A_monoid]]'", a:Optional[Type[A_monoid]]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Ignores the output from a parser. This is useful when you expect
to give arguments to the command line that some other utility will
handle.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;hello&quot;).ignore()
</code></pre>
<p>This will not bind any value to <code>"hello"</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--hello&quot;)
{}
</code></pre>
<p>But <code>--hello</code> is still required:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args()
The following arguments are required: --hello
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L376-L401" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ignore(
    self: &#34;Parser[Output[A_monoid]]&#34;, a: Optional[Type[A_monoid]] = None
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Ignores the output from a parser. This is useful when you expect
    to give arguments to the command line that some other utility will
    handle.

    &gt;&gt;&gt; p = flag(&#34;hello&#34;).ignore()

    This will not bind any value to `&#34;hello&#34;`:
    &gt;&gt;&gt; p.parse_args(&#34;--hello&#34;)
    {}

    But `--hello` is still required:
    &gt;&gt;&gt; p.parse_args()
    The following arguments are required: --hello
    &#34;&#34;&#34;

    def g(keep: Parse[Output[A_monoid]]) -&gt; Result[Parse[Output[A_monoid]]]:
        return Result(NonemptyList(Parse(Output.zero(a), keep.unparsed)))

    def f(cs: Sequence[str]) -&gt; Result[Parse[Output[A_monoid]]]:
        return self.parse(cs) &gt;= g

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.many"><code class="name flex">
<span>def <span class="ident">many</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output[A_monoid]]'", max:Optional[int]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> zero or more times (like <code>*</code> in regexes).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args()
{}
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)
{'as-many-as-you-like': 'a'}
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
{'as-many-as-you-like': ['a', 'b']}
</code></pre>
<p>Note that if <code>self</code> contains <code>Parser.__or__</code>, the arguments can be
heterogenous:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p = p.many()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;) # mix --verbose and --quiet
{'verbose': True, 'quiet': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L403-L434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def many(
    self: &#34;Parser[Output[A_monoid]]&#34;, max: Optional[int] = None
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Applies `self` zero or more times (like `*` in regexes).

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args()
    {}
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
    {&#39;as-many-as-you-like&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    {&#39;as-many-as-you-like&#39;: [&#39;a&#39;, &#39;b&#39;]}

    Note that if `self` contains `Parser.__or__`, the arguments can be
    heterogenous:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
    &gt;&gt;&gt; p = p.many()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;) # mix --verbose and --quiet
    {&#39;verbose&#39;: True, &#39;quiet&#39;: True}
    &#34;&#34;&#34;
    if max == 0:
        p = self.empty()
    else:
        if max is not None:
            max -= 1
            assert max &gt;= 0, max
        p = self.many1(max=max) | self.empty()
    return replace(p, usage=f&#34;[{self.usage} ...]&#34;)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.many1"><code class="name flex">
<span>def <span class="ident">many1</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output[A_monoid]]'", max:Optional[int]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> one or more times (like <code>+</code> in regexes).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;1-or-more&quot;).many1()
&gt;&gt;&gt; p.parse_args(&quot;1&quot;)
{'1-or-more': '1'}
&gt;&gt;&gt; p.parse_args(&quot;1&quot;, &quot;2&quot;)
{'1-or-more': ['1', '2']}
&gt;&gt;&gt; p.parse_args()
usage: 1-OR-MORE [1-OR-MORE ...]
The following arguments are required: 1-or-more
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L436-L462" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def many1(
    self: &#34;Parser[Output[A_monoid]]&#34;, max: Optional[int] = None
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Applies `self` one or more times (like `+` in regexes).

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
    {&#39;1-or-more&#39;: &#39;1&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;)
    {&#39;1-or-more&#39;: [&#39;1&#39;, &#39;2&#39;]}
    &gt;&gt;&gt; p.parse_args()
    usage: 1-OR-MORE [1-OR-MORE ...]
    The following arguments are required: 1-or-more
    &#34;&#34;&#34;

    @lru_cache()
    def f(cs: tuple):
        y = self &gt;&gt; self.many(max=max)
        return y.parse(Sequence(list(cs)))

    return Parser(
        lambda cs: f(tuple(cs)),
        usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
        helps=self.helps,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.map_error"><code class="name flex">
<span>def <span class="ident">map_error</span></span>(<span>self, f:Callable[[ArgumentError],ArgumentError]) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L464-L472" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def map_error(self, f: Callable[[ArgumentError], ArgumentError]) -&gt; &#34;Parser[A_co]&#34;:
    def g(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        parse = self.parse(cs)
        if isinstance(parse.get, ArgumentError):
            return Result.zero(error=f(parse.get))
        else:
            return parse

    return Parser(g, usage=None, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.optional"><code class="name flex">
<span>def <span class="ident">optional</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output[A_monoid]]'") <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Allows arguments to be optional:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;optional&quot;)
&gt;&gt;&gt; p = p1.optional()
&gt;&gt;&gt; p.parse_args(&quot;--optional&quot;)
{'optional': True}
&gt;&gt;&gt; p.parse_args(&quot;--misspelled&quot;, allow_unparsed=True)  # succeeds with no output
{}
&gt;&gt;&gt; p1.parse_args(&quot;--misspelled&quot;)
usage: --optional
Expected '--optional'. Got '--misspelled'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L474-L487" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def optional(self: &#34;Parser[Output[A_monoid]]&#34;) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Allows arguments to be optional:
    &gt;&gt;&gt; p1 = flag(&#34;optional&#34;)
    &gt;&gt;&gt; p = p1.optional()
    &gt;&gt;&gt; p.parse_args(&#34;--optional&#34;)
    {&#39;optional&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--misspelled&#34;, allow_unparsed=True)  # succeeds with no output
    {}
    &gt;&gt;&gt; p1.parse_args(&#34;--misspelled&#34;)
    usage: --optional
    Expected &#39;--optional&#39;. Got &#39;--misspelled&#39;
    &#34;&#34;&#34;
    return self | self.empty()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, cs:Sequence[str]) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="#dollar_lambda.parser.Parse">Parse</a>[+A_co]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the parser to the input sequence <code>cs</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L489-L493" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
    &#34;&#34;&#34;
    Applies the parser to the input sequence `cs`.
    &#34;&#34;&#34;
    return self.f(cs)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output]'", *args:str, allow_unparsed:bool=False, check_help:bool=True) <span style="white-space: nowrap;">-></span>Optional[Dict[str,Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>The main way the user extracts parsed results from the parser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>str</code></dt>
<dd>A sequence of strings to parse. If empty, defaults to <code>sys.argv[1:]</code>.</dd>
<dt><strong><code>allow_unparsed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to cause parser to fail if there are unparsed inputs. Note that setting this to false
may cause unexpected behavior when using <code><a title="dollar_lambda.parser.nonpositional" href="#dollar_lambda.parser.nonpositional">nonpositional()</a></code> or <code>Args</code>.</dd>
<dt><strong><code>check_help</code></strong> :&ensp;<code>bool</code></dt>
<dd>Before running the parser, checks if the input string is <code>--help</code> or <code>-h</code>.
If it is, returns the usage message.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;-h&quot;)
usage: A
&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;--help&quot;)
usage: A
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L495-L540" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_args(
    self: &#34;Parser[Output]&#34;,
    *args: str,
    allow_unparsed: bool = False,
    check_help: bool = True,
) -&gt; &#34;Optional[Dict[str, Any]]&#34;:
    &#34;&#34;&#34;
    The main way the user extracts parsed results from the parser.

    Parameters
    ----------
    args : str
        A sequence of strings to parse. If empty, defaults to `sys.argv[1:]`.
    allow_unparsed : bool
        Whether to cause parser to fail if there are unparsed inputs. Note that setting this to false
        may cause unexpected behavior when using `nonpositional` or `Args`.
    check_help : bool
        Before running the parser, checks if the input string is `--help` or `-h`.
        If it is, returns the usage message.

    Examples
    --------

    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
    usage: A
    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
    usage: A
    &#34;&#34;&#34;
    _args = args if args or TESTING else sys.argv[1:]
    if not allow_unparsed:
        return (self &gt;&gt; Parser[Output].done()).parse_args(
            *_args,
            allow_unparsed=True,
            check_help=check_help,
        )
    if check_help:
        return self.wrap_help().parse_args(
            *_args,
            allow_unparsed=allow_unparsed,
            check_help=False,
        )
    result = self.parse(Sequence(list(_args))).get
    if isinstance(result, ArgumentError):
        self.handle_error(result)
        return None
    return result.head.parsed.get.to_dict()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.rshift"><code class="name flex">
<span>def <span class="ident">rshift</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output[A_monoid]]'", p:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output[B_monoid]]'") <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[typing.Union[~A_monoid,~B_monoid]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L155-L158" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rshift(
    self: &#34;Parser[Output[A_monoid]]&#34;, p: &#34;Parser[Output[B_monoid]]&#34;
) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
    return self &gt;&gt; p</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.sat"><code class="name flex">
<span>def <span class="ident">sat</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[A_monoid]'", predicate:Callable[[A_monoid],bool], on_fail:Callable[[A_monoid],ArgumentError]) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[~A_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>parser</code>, applies a predicate to the result and fails if this returns false.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = option(&quot;x&quot;, type=int).many().sat(
...     lambda out: sum(out.get.values()) &gt; 0,
...     lambda out: ArgumentError(f&quot;The values in {list(out.get.values())} must sum to more than 0.&quot;),
... )
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-1&quot;, &quot;-x&quot;, &quot;1&quot;)  # fails
usage: [-x X ...]
The values in [-1, 1] must sum to more than 0.
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-1&quot;, &quot;-x&quot;, &quot;2&quot;)  # succeeds
{'x': [-1, 2]}
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parser</code></strong> :&ensp;<code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[A]</code></dt>
<dd>The parser to apply.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Callable[[A], bool]</code></dt>
<dd>The predicate to apply to the result of <code>parser</code>. <code><a title="dollar_lambda.parser.sat" href="#dollar_lambda.parser.sat">sat()</a></code> fails if this predicate returns false.</dd>
<dt><strong><code>on_fail</code></strong> :&ensp;<code>Callable[[A], ArgumentError]</code></dt>
<dd>A function producing an ArgumentError to return if the predicate fails.
Takes the output of <code>parser</code> as an argument.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L559-L592" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sat(
    self: &#34;Parser[A_monoid]&#34;,
    predicate: Callable[[A_monoid], bool],
    on_fail: Callable[[A_monoid], ArgumentError],
) -&gt; &#34;Parser[A_monoid]&#34;:
    &#34;&#34;&#34;
    Applies `parser`, applies a predicate to the result and fails if this returns false.

    &gt;&gt;&gt; p = option(&#34;x&#34;, type=int).many().sat(
    ...     lambda out: sum(out.get.values()) &gt; 0,
    ...     lambda out: ArgumentError(f&#34;The values in {list(out.get.values())} must sum to more than 0.&#34;),
    ... )
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;1&#34;)  # fails
    usage: [-x X ...]
    The values in [-1, 1] must sum to more than 0.

    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;2&#34;)  # succeeds
    {&#39;x&#39;: [-1, 2]}

    Parameters
    ----------
    parser : Parser[A]
        The parser to apply.
    predicate : Callable[[A], bool]
        The predicate to apply to the result of `parser`. `sat` fails if this predicate returns false.
    on_fail : Callable[[A], ArgumentError]
        A function producing an ArgumentError to return if the predicate fails.
        Takes the output of `parser` as an argument.
    &#34;&#34;&#34;

    def f(x: A_monoid) -&gt; Result[A_monoid]:
        return Result(NonemptyList(x) if predicate(x) else on_fail(x))

    return self.apply(f)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Output[Sequence[KeyValue[str]]]]'", f:Callable[[str],Any]) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[str]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code><a title="dollar_lambda.parser.apply" href="#dollar_lambda.parser.apply">apply()</a></code> that simply applies <code>f</code> to the value of the most recently parsed input.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = option(&quot;x&quot;) &gt;&gt; option(&quot;y&quot;)
&gt;&gt;&gt; p = p1.type(int)
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)  # converts &quot;1&quot; but not &quot;2&quot;
{'x': '1', 'y': 2}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L594-L618" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def type(
    self: &#34;Parser[Output[Sequence[KeyValue[str]]]]&#34;, f: Callable[[str], Any]
) -&gt; &#34;Parser[Output[Sequence[KeyValue[str]]]]&#34;:
    &#34;&#34;&#34;
    A wrapper around `apply` that simply applies `f` to the value of the most recently parsed input.
    &gt;&gt;&gt; p1 = option(&#34;x&#34;) &gt;&gt; option(&#34;y&#34;)
    &gt;&gt;&gt; p = p1.type(int)
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)  # converts &#34;1&#34; but not &#34;2&#34;
    {&#39;x&#39;: &#39;1&#39;, &#39;y&#39;: 2}
    &#34;&#34;&#34;

    def g(out: Output[Sequence[KeyValue[str]]]) -&gt; Result[Output]:
        d = out.get
        if not d:
            raise RuntimeError(&#34;Invoked type on a parser that returns no output.&#34;)
        *tail, head = out.get
        try:
            y = f(head.value)
        except Exception as e:
            usage = f&#34;argument {head.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        return Result.return_(Output(Sequence([*tail, KeyValue(head.key, y)])))

    p = self.apply(g)
    return replace(p, usage=self.usage, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.wrap_error"><code class="name flex">
<span>def <span class="ident">wrap_error</span></span>(<span>self, error:ArgumentError) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L620-L621" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrap_error(self, error: ArgumentError) -&gt; &#34;Parser[A_co]&#34;:
    return self.map_error(lambda _: error)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.wrap_help"><code class="name flex">
<span>def <span class="ident">wrap_help</span></span>(<span>self:"'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[A_monoid]'", a:Optional[Type[A_monoid]]=None) <span style="white-space: nowrap;">-></span><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[~A_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>This checks for the <code>--help</code> or <code>-h</code> flag before applying <code>parser</code>.
If either of the flags is present, returns the usage message for <code>parser</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;help&quot;, help=&quot;Print this help message.&quot;).wrap_help()
&gt;&gt;&gt; p.parse_args(&quot;--help&quot;)
usage: --help
help: Print this help message.
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: --help
help: Print this help message.
</code></pre>
<p>We can use <code>wrap_help</code> to print partial usage messages, e.g. for subcommands:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; subcommand1 = matches(&quot;subcommand1&quot;) &gt;&gt; option(&quot;option1&quot;).wrap_help()
&gt;&gt;&gt; subcommand2 = matches(&quot;subcommand2&quot;) &gt;&gt; option(&quot;option2&quot;).wrap_help()
&gt;&gt;&gt; p = subcommand1 | subcommand2
&gt;&gt;&gt; p.parse_args(&quot;subcommand1&quot;, &quot;-h&quot;)
usage: --option1 OPTION1
&gt;&gt;&gt; p.parse_args(&quot;subcommand2&quot;, &quot;-h&quot;)
usage: --option2 OPTION2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L623-L650" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrap_help(
    self: &#34;Parser[A_monoid]&#34;, a: Optional[Type[A_monoid]] = None
) -&gt; &#34;Parser[A_monoid]&#34;:
    &#34;&#34;&#34;
    This checks for the `--help` or `-h` flag before applying `parser`.
    If either of the flags is present, returns the usage message for `parser`.

    &gt;&gt;&gt; p = flag(&#34;help&#34;, help=&#34;Print this help message.&#34;).wrap_help()
    &gt;&gt;&gt; p.parse_args(&#34;--help&#34;)
    usage: --help
    help: Print this help message.
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --help
    help: Print this help message.

    We can use `wrap_help` to print partial usage messages, e.g. for subcommands:
    &gt;&gt;&gt; subcommand1 = matches(&#34;subcommand1&#34;) &gt;&gt; option(&#34;option1&#34;).wrap_help()
    &gt;&gt;&gt; subcommand2 = matches(&#34;subcommand2&#34;) &gt;&gt; option(&#34;option2&#34;).wrap_help()
    &gt;&gt;&gt; p = subcommand1 | subcommand2
    &gt;&gt;&gt; p.parse_args(&#34;subcommand1&#34;, &#34;-h&#34;)
    usage: --option1 OPTION1
    &gt;&gt;&gt; p.parse_args(&#34;subcommand2&#34;, &#34;-h&#34;)
    usage: --option2 OPTION2
    &#34;&#34;&#34;
    _help_parser: Parser[Output[A_monoid]] = help_parser(self.usage, Output.zero(a))

    p = _help_parser &gt;= (lambda _: self)
    return replace(p, usage=self.usage, helps=self.helps)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.parser.SuccessError"><code class="flex name class">
<span>class <span class="ident">SuccessError</span></span>
<span>(</span><span>usage:str, input:Sequence[str], output:NonemptyList[<a title="dollar_lambda.parser.Parse" href="#dollar_lambda.parser.Parse">Parse</a>[A_monoid]])</span>
</code></dt>
<dd>
<div class="desc"><p>SuccessError(usage: str, input: 'Sequence[str]', output: 'NonemptyList[Parse[A_monoid]]')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/4066c7d2415ecb512067a38b36b9792262b69229/dollar_lambda/parser.py#L56-L59" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class SuccessError(ArgumentError, Generic[A_monoid]):
    input: Sequence[str]
    output: NonemptyList[Parse[A_monoid]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dollar_lambda.error.ArgumentError" href="error.html#dollar_lambda.error.ArgumentError">ArgumentError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.parser.SuccessError.input"><code class="name">var <span class="ident">input</span> :<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.parser.SuccessError.output"><code class="name">var <span class="ident">output</span> :pytypeclass.nonempty_list.NonemptyList[<a title="dollar_lambda.parser.Parse" href="#dollar_lambda.parser.Parse">Parse</a>[~A_monoid]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="dollar-lambda home" href="https://ethanabrooks.github.io/dollar-lambda">
<img src="https://ethanabrooks.github.io/dollar-lambda/logo.png" alt="">
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dollar_lambda" href="index.html">dollar_lambda</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="dollar_lambda.parser.apply" href="#dollar_lambda.parser.apply">apply</a></code></li>
<li><code><a title="dollar_lambda.parser.argument" href="#dollar_lambda.parser.argument">argument</a></code></li>
<li><code><a title="dollar_lambda.parser.binary_usage" href="#dollar_lambda.parser.binary_usage">binary_usage</a></code></li>
<li><code><a title="dollar_lambda.parser.defaults" href="#dollar_lambda.parser.defaults">defaults</a></code></li>
<li><code><a title="dollar_lambda.parser.flag" href="#dollar_lambda.parser.flag">flag</a></code></li>
<li><code><a title="dollar_lambda.parser.help_parser" href="#dollar_lambda.parser.help_parser">help_parser</a></code></li>
<li><code><a title="dollar_lambda.parser.item" href="#dollar_lambda.parser.item">item</a></code></li>
<li><code><a title="dollar_lambda.parser.matches" href="#dollar_lambda.parser.matches">matches</a></code></li>
<li><code><a title="dollar_lambda.parser.nonpositional" href="#dollar_lambda.parser.nonpositional">nonpositional</a></code></li>
<li><code><a title="dollar_lambda.parser.option" href="#dollar_lambda.parser.option">option</a></code></li>
<li><code><a title="dollar_lambda.parser.peak" href="#dollar_lambda.parser.peak">peak</a></code></li>
<li><code><a title="dollar_lambda.parser.sat" href="#dollar_lambda.parser.sat">sat</a></code></li>
<li><code><a title="dollar_lambda.parser.sat_peak" href="#dollar_lambda.parser.sat_peak">sat_peak</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dollar_lambda.parser.Parse" href="#dollar_lambda.parser.Parse">Parse</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.parser.Parse.parsed" href="#dollar_lambda.parser.Parse.parsed">parsed</a></code></li>
<li><code><a title="dollar_lambda.parser.Parse.unparsed" href="#dollar_lambda.parser.Parse.unparsed">unparsed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a></code></h4>
<ul class="two-column">
<li><code><a title="dollar_lambda.parser.Parser.apply" href="#dollar_lambda.parser.Parser.apply">apply</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.bind" href="#dollar_lambda.parser.Parser.bind">bind</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.done" href="#dollar_lambda.parser.Parser.done">done</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.empty" href="#dollar_lambda.parser.Parser.empty">empty</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.f" href="#dollar_lambda.parser.Parser.f">f</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.fails" href="#dollar_lambda.parser.Parser.fails">fails</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.handle_error" href="#dollar_lambda.parser.Parser.handle_error">handle_error</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.helps" href="#dollar_lambda.parser.Parser.helps">helps</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.ignore" href="#dollar_lambda.parser.Parser.ignore">ignore</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.many" href="#dollar_lambda.parser.Parser.many">many</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.many1" href="#dollar_lambda.parser.Parser.many1">many1</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.map_error" href="#dollar_lambda.parser.Parser.map_error">map_error</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.optional" href="#dollar_lambda.parser.Parser.optional">optional</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.parse" href="#dollar_lambda.parser.Parser.parse">parse</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.parse_args" href="#dollar_lambda.parser.Parser.parse_args">parse_args</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.return_" href="#dollar_lambda.parser.Parser.return_">return_</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.rshift" href="#dollar_lambda.parser.Parser.rshift">rshift</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.sat" href="#dollar_lambda.parser.Parser.sat">sat</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.type" href="#dollar_lambda.parser.Parser.type">type</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.usage" href="#dollar_lambda.parser.Parser.usage">usage</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.wrap_error" href="#dollar_lambda.parser.Parser.wrap_error">wrap_error</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.wrap_help" href="#dollar_lambda.parser.Parser.wrap_help">wrap_help</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.zero" href="#dollar_lambda.parser.Parser.zero">zero</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.parser.SuccessError" href="#dollar_lambda.parser.SuccessError">SuccessError</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.parser.SuccessError.input" href="#dollar_lambda.parser.SuccessError.input">input</a></code></li>
<li><code><a title="dollar_lambda.parser.SuccessError.output" href="#dollar_lambda.parser.SuccessError.output">output</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</html>
