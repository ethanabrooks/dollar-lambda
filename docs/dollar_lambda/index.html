<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dollar_lambda API documentation</title>
<meta name="description" content="This package provides an alternative to [`argparse`](https://docs.python.org/3/library/argparse.html)
based on parser combinators and functional first …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&family=IBM+Plex+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
body {
font-family: 'IBM Plex Sans', sans-serif;
line-height: 1.45;
font-size: 15px;
}
pre, code {
font-family: 'Fira Code', monospace;
}
p code {
white-space: nowrap;
}
</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>dollar_lambda</code></h1>
<a href="https://github.com/ethanabrooks/dollar-lambda" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
</svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</header>
<section id="section-intro">
<p>This package provides an alternative to <a href="https://docs.python.org/3/library/argparse.html"><code>argparse</code></a>
based on parser combinators and functional first principles. Arguably, <code>$λ</code> is way more expressive than any reasonable
person would ever need&hellip; but even if it's not the parser that we need, it's the parser we deserve.</p>
<h1 id="installation">Installation</h1>
<pre><code>pip install dollar-lambda
</code></pre>
<h1 id="highlights">Highlights</h1>
<p><code>$λ</code> comes with syntactic sugar that came make building parsers completely boilerplate-free.
However, with more concise syntax comes less flexibility. For more complex parsing situations,
there are modular building blocks that lie behind the syntactic sugar which enable parsers to
handle any reasonable amount of logical complexity.</p>
<h2 id="the-command-decorator">The <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> decorator</h2>
<p>This syntax is best for simple parsers that take a set of unordered arguments:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command()
... def main(x: int, y: int, verbose: bool = False, quiet: bool = False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
</code></pre>
<p>Here is the help text generated by this parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-h&quot;)
usage:
    -x X
    -y Y
    --verbose
    --quiet
</code></pre>
<p>And here it is in action:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'quiet': False}
</code></pre>
<p>Note that the supplied string arguments are for demonstration only:</p>
<pre><code>main() # this would get arguments from the command line / sys.argv[1:]
</code></pre>
<p><code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> takes arguments that allow you to supply
help strings and custom types:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(types=dict(x=lambda x: int(x) + 1, help=dict(x=&quot;A number that gets incremented.&quot;)))
... def main(x: int, y: int, verbose: bool = False, quiet: bool = False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
...
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-h&quot;)
usage:
    -x X
    -y Y
    --verbose
    --quiet
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 2, 'y': 2, 'verbose': True, 'quiet': False}
</code></pre>
<h3 id="equivalent-syntax">Equivalent <code>$λ</code> syntax</h3>
<p>Under the syntactic sugar, this is how <code>$λ</code> expresses the first parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     option(&quot;x&quot;, type=lambda x: int(x) + 1, help=&quot;A number that gets incremented.&quot;),
...     option(&quot;y&quot;, type=int),
...     flag(&quot;verbose&quot;, default=False),
...     flag(&quot;quiet&quot;, default=False),
... ) &gt;&gt; done()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage:
    -x X
    -y Y
    --verbose
    --quiet
x: A number that gets incremented.
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 2, 'y': 2, 'verbose': True, 'quiet': False}
</code></pre>
<p>As you can see, <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> denotes boolean-valued command-line arguments and <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> denotes command-line
arguments that take explicit parameters. <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> allows these parsers to be applied in any order
&ndash; i.e. it takes command-line arguments nonpositionally. <code>&gt;&gt;</code> allows parsers to be sequenced and <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code>
succeeds only at the end of input. For more details on all these functions, see the
<a href="#parser-combinators">Parser Combinators section</a> of the <a href="#tutorial">tutorial</a>.</p>
<p>This logic will cover many common use cases. But let's consider a more complex example:
What if you want <code>--verbose</code> and <code>--quiet</code> to be mutually exclusive?</p>
<h2 id="for-alternatives"><code>|</code> for alternatives</h2>
<p>In order to force a choice between two parsers, you can use <code>|</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     option(&quot;x&quot;, type=lambda x: int(x) + 1, help=&quot;A number that gets incremented.&quot;),
...     option(&quot;y&quot;, type=int),
...     flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
... ) &gt;&gt; done()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: -x X -y Y [--verbose | --quiet]
x: A number that gets incremented.
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 2, 'y': 2, 'verbose': True}
</code></pre>
<p>This will fail if both <code>--verbose</code> and <code>--quiet</code> are given:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--quiet&quot;)
usage: -x X -y Y [--verbose | --quiet]
x: A number that gets incremented.
Unrecognized argument: --quiet
</code></pre>
<p>It will also fail if neither is given:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)
usage: -x X -y Y [--verbose | --quiet]
x: A number that gets incremented.
The following arguments are required: --verbose
</code></pre>
<h2 id="commandtree-for-dynamic-dispatch"><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> for dynamic dispatch</h2>
<p><code>$λ</code> offers a special syntax for a common use case with alternative
command line inputs.
Often, we want a program to do one thing when a user
enters one set of command line arguments and another thing for another set.
Returning to our earlier example, what if we wanted to execute one
function if the user gave the <code>--verbose</code> flag and another if they gave <code>--quiet</code> flag?</p>
<p>Meet <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def base_function(x: int, y: int):
...     raise RuntimeError(&quot;Does not execute because children are required.&quot;)
...
&gt;&gt;&gt; @base_function.command()
... def verbose_function(x: int, y: int, verbose: bool):
...     print(dict(x=x, y=y, verbose=verbose))
...
&gt;&gt;&gt; @base_function.command()
... def quiet_function(x: int, y: int, quiet: bool):
...     print(dict(x=x, y=y, quiet=quiet))
</code></pre>
<p>Let's see how this parser handles different inputs.
If we provide the <code>--verbose</code> flag, <code>$λ</code> automatically invokes
the <code>verbose_function</code> with the parsed arguments:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True}
</code></pre>
<p>If we provide the <code>--quiet</code> flag, <code>$λ</code> invokes the <code>quiet_function</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;)  # execute quiet_function
{'x': 1, 'y': 2, 'quiet': True}
</code></pre>
<p>With this configuration, the parser will fail if neither
<code>--verbose</code> or <code>--quiet</code> is given:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)  # fails
usage: -x X -y Y [--verbose | --quiet]
The following arguments are required: --verbose
</code></pre>
<p>However, there are many other ways to use <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code>,
including some that make use of the <code>base_function</code>.
To learn more, we recommend the <a href="#commandtree-tutorial"><code>CommandTree</code> tutorial</a>.</p>
<h1 id="tutorial">Tutorial</h1>
<p>We've already seen many of the concepts that power <code>$λ</code> in the
<a href="#highlights">Highlights</a> section. This tutorial will address
these concepts one at a time and expose the reader to some
nuances of usage.</p>
<h2 id="an-example-from-argparse">An example from <code>argparse</code></h2>
<p>Many of you are already familiar with <code>argparse</code>.
You may even recognize this example from the <code>argparse</code> docs:</p>
<pre><code>import argparse
parser = argparse.ArgumentParser(description=&quot;calculate X to the power of Y&quot;)
group = parser.add_mutually_exclusive_group()
group.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;)
group.add_argument(&quot;-q&quot;, &quot;--quiet&quot;, action=&quot;store_true&quot;)
parser.add_argument(&quot;x&quot;, type=int, help=&quot;the base&quot;)
parser.add_argument(&quot;y&quot;, type=int, help=&quot;the exponent&quot;)
args = parser.parse_args()
</code></pre>
<p>Here is the exact equivalent in this package:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;) | empty()),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
</code></pre>
<p>This is similar to what we saw in the
<a href="##for-alternatives">earlier section on alternatives</a>,
except that now we use <code>| empty()</code> to allow both
<code>--verbose</code> and <code>--quiet</code> to be omitted:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(**p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;))
{'x': 1, 'y': 2, 'verbose': False, 'quiet': False}
</code></pre>
<p>Let's walk through this step by step.</p>
<h2 id="high-level-parsers">High-Level Parsers</h2>
<p>So far we've seen a few different parser constructors.
<code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> binds a boolean value to a variable whereas <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> binds an arbitrary value to a variable.
<code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty()</a></code> and <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> do not bind any values to variables, but <code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty()</a></code> always succeeds whereas <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> only
succeeds on the end of input.</p>
<h3 id="flag"><code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code></h3>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<p>By default <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> fails when it does not receive expected input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose
</code></pre>
<p>Alternately, you can set a default value:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;, default=False).parse_args()
{'verbose': False}
</code></pre>
<h3 id="option"><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code></h3>
<p><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> is similar but takes an argument:
By default, <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> expects a single <code>-</code> for single-character variable names (as in <code>-x</code>),
as opposed to <code>--</code> for longer names (as in <code>--xenophon</code>):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;).parse_args(&quot;-x&quot;, &quot;1&quot;)
{'x': '1'}
&gt;&gt;&gt; option(&quot;xenophon&quot;).parse_args(&quot;--xenophon&quot;, &quot;1&quot;)
{'xenophon': '1'}
</code></pre>
<p>Use the <code>type</code> argument to convert the input to a different type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;, type=int).parse_args(&quot;-x&quot;, &quot;1&quot;)  # converts &quot;1&quot; to an int
{'x': 1}
</code></pre>
<h3 id="empty"><code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty()</a></code></h3>
<p>As we've said, <code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty()</a></code> always succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; empty().parse_args(&quot;any&quot;, &quot;arguments&quot;)
{}
</code></pre>
<p>For a more type-safe version, you can use <code><a title="dollar_lambda.Parser.empty" href="#dollar_lambda.Parser.empty">Parser.empty()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = Parser[int].empty()
</code></pre>
<p><code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty()</a></code> is useful when you want to make an argument optional &ndash;
the definition of <code><a title="dollar_lambda.Parser.optional" href="#dollar_lambda.Parser.optional">Parser.optional()</a></code> is:</p>
<pre><code>def optional(self):
    return self | self.empty()
</code></pre>
<h3 id="done"><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code></h3>
<p>Without <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> the parser will not complain about leftover (unparsed) input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True}
</code></pre>
<p><code>--quiet</code> is not parsed here but this does not cause the parser to fail.
If we want to prevent leftover inputs, we can use <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) &gt;&gt; done()).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
usage: --verbose
Unrecognized argument: --quiet
</code></pre>
<p><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> is usually necessary to get <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> to behave in the way that you expect,
but more on that later.</p>
<h2 id="parser-combinators">Parser Combinators</h2>
<p>Parser combinators are functions that combine multiple parsers into new, more complex parsers.
Our example uses three such functions: <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>, <code>|</code> or <code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>,
and <code>&gt;&gt;</code> or <code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code>.</p>
<h3 id="parser__or__"><code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code></h3>
<p>The <code>|</code> operator is used for alternatives. Specifically, it will try the first parser,
and if that fails, try the second:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;) # flag(&quot;verbose&quot;) fails
{'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;) # flag(&quot;verbose&quot;) succeeds
{'verbose': True}
</code></pre>
<p>By default one of the two flags would be required to prevent failure:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args() # neither flag is provided so this fails
usage: [--verbose | --quiet]
The following arguments are required: --verbose
</code></pre>
<p>We can permit the omission of both flags
by using <code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty()</a></code>, as we saw earlier, or we can supply a default value:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;) | empty()).parse_args() # flags fail, but empty() succeeds
{}
&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;, default=False)).parse_args() # flag(&quot;verbose&quot;) fails but flag(&quot;quiet&quot;, default=False) succeeds
{'quiet': False}
</code></pre>
<p>This is just sugar for</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;) | defaults(quiet=False)).parse_args() # flag(&quot;verbose&quot;) fails but flag(&quot;quiet&quot;, default=False) succeeds
{'quiet': False}
</code></pre>
<h3 id="parser__rshift__"><code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code></h3>
<p>The <code>&gt;&gt;</code> operator is used for sequential composition. It applies the first parser and then
hands the output of the first parser to the second parser. If either parser fails, the composition fails:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--something-else&quot;)  # first parser will fail
usage: --verbose
Expected '--verbose'. Got '--something-else'
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--something-else&quot;)  # second parser will fail
usage: --verbose
Unrecognized argument: --something-else
</code></pre>
<h3 id="nonpositional-and-parser__add__"><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> and <code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code></h3>
<p><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<p>For just two parsers you can use <code>+</code>, or <code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code>, instead of <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<p>This will not cover all permutations for more than two parsers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;) + option(&quot;x&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;--quiet&quot;)
usage: --verbose --quiet -x X
Expected '--quiet'. Got '-x'
</code></pre>
<p>To see why note the implicit parentheses:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;)) + option(&quot;x&quot;)
</code></pre>
<p>In order to cover the case where <code>-x</code> comes between <code>--verbose</code> and <code>--quiet</code>,
use <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;), option(&quot;x&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;--quiet&quot;)  # works
{'verbose': True, 'x': '1', 'quiet': True}
</code></pre>
<p>If alternatives or defaults appear among the arguments to <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>, you will probably want
to add <code>&gt;&gt;</code> followed by <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> (or another parser) after <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>. Otherwise,
the parser will not behave as expected:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # you expect this to set verbose to True, but it doesn't
{'verbose': False, 'quiet': True}
</code></pre>
<p>Why is happening? There are two permutions:</p>
<ul>
<li><code>flag("verbose", default=False) &gt;&gt; flag("quiet")</code> and</li>
<li><code>flag("quiet") &gt;&gt; flag("verbose", default=False)</code></li>
</ul>
<p>In our example, both permutations are actually succeeding. This first succeeds by falling
back to the default, and leaving the last word of the input, <code>--verbose</code>, unparsed.
Either interpretation is valid, and <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> returns one arbitrarily &ndash; just not the one we expected.</p>
<p>Now let's add <code>&gt;&gt; done()</code> to the end:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;quiet&quot;)) &gt;&gt; done()
</code></pre>
<p>This ensures that the first permutation will fail because the leftover <code>--verbose</code> input will
cause the <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> parser to fail:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)
{'quiet': True, 'verbose': True}
</code></pre>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>Let's recall the original example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;) | empty()),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
</code></pre>
<p>As we've seen, <code>flag("verbose") | flag("quiet") | empty()</code> succeeds on either <code>--verbose</code> or <code>--quiet</code>
or neither.</p>
<p><code>option("x", type=int)</code> succeeds on <code>-x X</code>, where <code>X</code> is
some integer, binding that integer to the variable <code>"x"</code>. Similarly for <code>option("y", type=int)</code>.</p>
<p><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> takes the three parsers:</p>
<ul>
<li><code>flag("verbose") | flag("quiet") | empty()</code></li>
<li><code>option("x", type=int)</code></li>
<li><code>option("y", type=int)</code></li>
</ul>
<p>and applies them in every order, until some order succeeds.
Finally <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> ensures that only one of these parser permutations will succeed, preventing ambiguity.</p>
<h2 id="variations-on-the-example">Variations on the example</h2>
<h3 id="variable-numbers-of-arguments">Variable numbers of arguments</h3>
<p>What if there was a special argument, <code>verbosity</code>,
that only makes sense if the user chooses <code>--verbose</code>?</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&quot;verbose&quot;) + option(&quot;verbosity&quot;, type=int)) | flag(&quot;quiet&quot;)),
...         option(&quot;x&quot;, type=int),
...         option(&quot;y&quot;, type=int),
...     )
...     &gt;&gt; done()
... )
</code></pre>
<p>Remember that <code>+</code> or <code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code> evaluates two parsers in both orders
and stopping at the first order that succeeds. So this allows us to
supply <code>--verbose</code> and <code>--verbosity</code> in any order.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;)
{'x': 1, 'y': 2, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbosity&quot;, &quot;3&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
usage: [--verbose --verbosity VERBOSITY | --quiet] -x X -y Y
Expected '--verbose'. Got '-x'
</code></pre>
<p>This is also a case where you might want to use <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(help=dict(x=&quot;the base&quot;, y=&quot;the exponent&quot;))
... def base_function(x: int, y: int):
...     raise RuntimeError(&quot;This function will not execute.&quot;)
...
&gt;&gt;&gt; @base_function.command()
... def verbose_function(x: int, y: int, verbose: bool, verbosity: int):
...     print(dict(x=x, y=y, verbose=verbose, verbosity=verbosity))
...
&gt;&gt;&gt; @base_function.command()
... def quiet_function(x: int, y: int, quiet: bool):
...     print(dict(x=x, y=y, quiet=quiet))
...
&gt;&gt;&gt; tree(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbosity&quot;, &quot;3&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3}
</code></pre>
<h3 id="parsermany"><code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code></h3>
<p>What if we want to specify verbosity by the number of times that <code>--verbose</code> appears?
For this we need <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code>. Before showing how we could use <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> in this setting,
let's look at how it works.</p>
<p><code>parser.many</code> takes <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> and tries to apply it as many times as possible.
<code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> is a bit like the <code>*</code> pattern, if you are familiar with regexes.
<code>parser.many</code> always succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p.parse_args(&quot;blah&quot;)  # still succeeds
{}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;blah&quot;)  # still succeeds
{'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--verbose&quot;, return_dict=False)
[('verbose', True), ('verbose', True)]
</code></pre>
<p>As you can see, <code>return_dict=False</code> returns a list of tuples instead of a dict, so that you
can have duplicate keys.</p>
<p>Now returning to the original example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (
...     nonpositional(
...         flag(&quot;verbose&quot;).many(),
...         option(&quot;x&quot;, type=int),
...         option(&quot;y&quot;, type=int),
...     )
...     &gt;&gt; done()
... )
&gt;&gt;&gt; args = p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbose&quot;, return_dict=False)
&gt;&gt;&gt; args
[('x', 1), ('y', 2), ('verbose', True), ('verbose', True)]
&gt;&gt;&gt; verbosity = args.count(('verbose', True))
&gt;&gt;&gt; verbosity
2
</code></pre>
<h3 id="parsermany1"><code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">Parser.many1()</a></code></h3>
<p>In the previous example, the parse will default to <code>verbosity=0</code> if no <code>--verbose</code> flags
are given.
What if we wanted users to be explicit about choosing a "quiet" setting?
In other words, what if the user actually had to provide an explicit <code>--quiet</code> flag when
no <code>--verbose</code> flags were given?</p>
<p>For this, we use <code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">Parser.many1()</a></code>. This method is like <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> except that it fails
when on zero successes (recall that <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> always succeeds). So if <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code>
is like regex <code>*</code>, <code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">Parser.many1()</a></code> is like <code>+</code>. Take a look:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p = flag(&quot;verbose&quot;).many1()
&gt;&gt;&gt; p.parse_args()  # fails
usage: --verbose [--verbose ...]
The following arguments are required: --verbose
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)  # succeeds
{'verbose': True}
</code></pre>
<p>To compell that <code>--quiet</code> flag from our users, we can do the following:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&quot;verbose&quot;).many1()) | flag(&quot;quiet&quot;)),
...         option(&quot;x&quot;, type=int),
...         option(&quot;y&quot;, type=int),
...     )
...     &gt;&gt; done()
... )
</code></pre>
<p>Now omitting both <code>--verbose</code> and <code>--quiet</code> will fail:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)
usage: [--verbose [--verbose ...] | --quiet] -x X -y Y
Expected '--verbose'. Got '-x'
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;) # this succeeds
{'verbose': True, 'x': 1, 'y': 2}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;) # and this succeeds
{'quiet': True, 'x': 1, 'y': 2}
</code></pre>
<h1 id="commandtree-tutorial"><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> Tutorial</h1>
<p><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> has already shown up in the
<a href="#commandtree-for-dynamic-dispatch">Highlights section</a>
and in the earlier <a href="#variations-on-the-example">tutorial</a>.
In this section we will give a more thorough treatment,
exposing some of the underlying logic and covering all
the variations in functionality that <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code>
offers.</p>
<h2 id="commandtreecommand"><code><a title="dollar_lambda.CommandTree.command" href="#dollar_lambda.CommandTree.command">CommandTree.command()</a></code></h2>
<p>First let's walk through the use of the <code><a title="dollar_lambda.CommandTree.command" href="#dollar_lambda.CommandTree.command">CommandTree.command()</a></code> decorator, one step
at a time. First we define the object:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
</code></pre>
<p>Now we define at least one child function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
</code></pre>
<p>At this point <code>tree</code> is just a parser that takes a single option <code>-a</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A
</code></pre>
<p>Now let's add a second child function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command()
... def f2(b: bool):
...     return dict(f2=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: [-a A | -b]
</code></pre>
<p><code>tree</code> will execute either <code>f1</code> or <code>f2</code> based on which of the parsers succeeds.
This will execute <code>f1</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
</code></pre>
<p>This will execute <code>f2</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-b&quot;)
{'f2': {'b': True}}
</code></pre>
<p>This fails:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree()
usage: [-a A | -b]
The following arguments are required: -a
</code></pre>
<p>Often in cases where there are alternative sets of argument like this,
there is also a set of shared arguments. It would be cumbersome to have to
repeat these for both child functions. Instead we can define a parent function
as follows:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     raise RuntimeError(&quot;This function will not execute.&quot;)
</code></pre>
<p>And a child function, <code>g1</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @f1.command()  # note f1, not tree
... def g1(a:int, b: bool):
...     return dict(g1=dict(b=b))
</code></pre>
<p>Make sure to include all the arguments of <code>f1</code> in <code>g1</code> or else
<code>g1</code> will fail when it is invoked. In its current state, <code>tree</code> sequences
the arguments of <code>f1</code> and <code>g1</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A -b
</code></pre>
<p>As before we can define an additional child function to induce alternative
argument sets:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @f1.command()  # note f1, not tree
... def g2(a: int, c: str):
...     return dict(g2=dict(c=c))
</code></pre>
<p>Note that our usage message shows <code>-a A</code> preceding the brackets:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A [-b | -c C]
</code></pre>
<p>To execute <code>g1</code>, we give the <code>-b</code> flag:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;, &quot;-b&quot;)
{'g1': {'b': True}}
</code></pre>
<p>To execute <code>g2</code>, we give the <code>-c</code> flag:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;, &quot;-c&quot;, &quot;foo&quot;)
{'g2': {'c': 'foo'}}
</code></pre>
<p>Also, note that <code>tree</code> can have arbitrary depth:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @g1.command()  # h1 is a child of g1
... def h1(a: int, b: bool, d: float):
...    return dict(h1=dict(d=d))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A [-b -d D | -c C]
</code></pre>
<h2 id="commandtreesubcommand"><code><a title="dollar_lambda.CommandTree.subcommand" href="#dollar_lambda.CommandTree.subcommand">CommandTree.subcommand()</a></code></h2>
<p>Often we want to explicitly specify which function to execute by naming it on the command line.
This would implement functionality similar to
<a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers"><code>ArgumentParser.add_subparsers</code></a></p>
<p>For this we would use the <code><a title="dollar_lambda.CommandTree.subcommand" href="#dollar_lambda.CommandTree.subcommand">CommandTree.subcommand()</a></code> decorator:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     raise RuntimeError(&quot;This function should not be called&quot;)
...
&gt;&gt;&gt; @f1.subcommand()  # note subcommand, not command
... def g1(a:int, b: bool):
...     return dict(g1=dict(b=b))
...
&gt;&gt;&gt; @f1.subcommand()  # again, subcommand, not command
... def g2(a: int, c: str):
...     return dict(g2=dict(c=c))
</code></pre>
<p>Now the usage message indicates that <code>g1</code> and <code>g2</code> are required arguments:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A [g1 -b | g2 -c C]
</code></pre>
<p>Now we would select g1 as follows:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;, &quot;g1&quot;, &quot;-b&quot;)
{'g1': {'b': True}}
</code></pre>
<p>And g2 as follows:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;, &quot;g2&quot;, &quot;-c&quot;, &quot;foo&quot;)
{'g2': {'c': 'foo'}}
</code></pre>
<h1 id="why">Why <code>$λ</code>?</h1>
<p><code>$λ</code> can handle many kinds of argument-parsing patterns
that are either very awkward, difficult, or impossible with other parsing libraries.
In particular, we emphasize the following qualities:</p>
<h3 id="versatile">Versatile</h3>
<p><code>$λ</code> provides high-level functionality equivalent to other parsers. But unlike other parsers,
it permits low-level customization to handle arbitrarily complex parsing patterns.
There are many parsing patterns that <code>$λ</code> can handle which are not possible with other parsing libraries.</p>
<h3 id="type-safe">Type-safe</h3>
<p><code>$λ</code> uses type annotations as much as Python allows. Types are checked using <a href="https://mypy.readthedocs.io/en/stable/index.html#"><code>MyPy</code></a> and exported with the package so that users can also benefit from
the type system. Furthermore, with rare exceptions, <code>$λ</code> avoids mutations and side-effects and preserves <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential
transparency</a>. This makes it easier for the type-checker <em>and
for the user</em> to reason about the code.</p>
<h3 id="concise">Concise</h3>
<p><code>$λ</code> provides many syntactic shortcuts for cutting down boilerplate:</p>
<ul>
<li>operators like <code>&gt;&gt;</code>, <code>|</code>, and <code>+</code> (and <code>&gt;=</code> if you want to get fancy)</li>
<li>the <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> decorator and the <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> object for building tree-shaped parsers</li>
<li>the <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> syntax built on top of python <code>dataclasses</code>.</li>
</ul>
<p>As a rule, <code>$λ</code> avoids reproducing python functionality and focuses on the main job of
an argument parser: parsing.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/__init__.py#L1-L756" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This package provides an alternative to [`argparse`](https://docs.python.org/3/library/argparse.html)
based on parser combinators and functional first principles. Arguably, `$λ` is way more expressive than any reasonable
person would ever need... but even if it&#39;s not the parser that we need, it&#39;s the parser we deserve.

# Installation
```
pip install dollar-lambda
```

# Highlights
`$λ` comes with syntactic sugar that came make building parsers completely boilerplate-free.
However, with more concise syntax comes less flexibility. For more complex parsing situations,
there are modular building blocks that lie behind the syntactic sugar which enable parsers to
handle any reasonable amount of logical complexity.

## The `command` decorator
This syntax is best for simple parsers that take a set of unordered arguments:

&gt;&gt;&gt; @command()
... def main(x: int, y: int, verbose: bool = False, quiet: bool = False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)

Here is the help text generated by this parser:

&gt;&gt;&gt; main(&#34;-h&#34;)
usage:
    -x X
    -y Y
    --verbose
    --quiet

And here it is in action:

&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}

Note that the supplied string arguments are for demonstration only:
```
main() # this would get arguments from the command line / sys.argv[1:]
```

`command` takes arguments that allow you to supply
help strings and custom types:

&gt;&gt;&gt; @command(types=dict(x=lambda x: int(x) + 1, help=dict(x=&#34;A number that gets incremented.&#34;)))
... def main(x: int, y: int, verbose: bool = False, quiet: bool = False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
...

&gt;&gt;&gt; main(&#34;-h&#34;)
usage:
    -x X
    -y Y
    --verbose
    --quiet

&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
{&#39;x&#39;: 2, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}

### Equivalent `$λ` syntax

Under the syntactic sugar, this is how `$λ` expresses the first parser:

&gt;&gt;&gt; p = nonpositional(
...     option(&#34;x&#34;, type=lambda x: int(x) + 1, help=&#34;A number that gets incremented.&#34;),
...     option(&#34;y&#34;, type=int),
...     flag(&#34;verbose&#34;, default=False),
...     flag(&#34;quiet&#34;, default=False),
... ) &gt;&gt; done()

&gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
usage:
    -x X
    -y Y
    --verbose
    --quiet
x: A number that gets incremented.

&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
{&#39;x&#39;: 2, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}

As you can see, `flag` denotes boolean-valued command-line arguments and `option` denotes command-line
arguments that take explicit parameters. `nonpositional` allows these parsers to be applied in any order
-- i.e. it takes command-line arguments nonpositionally. `&gt;&gt;` allows parsers to be sequenced and `done`
 succeeds only at the end of input. For more details on all these functions, see the
  [Parser Combinators section](#parser-combinators) of the [tutorial](#tutorial).

This logic will cover many common use cases. But let&#39;s consider a more complex example:
What if you want `--verbose` and `--quiet` to be mutually exclusive?

## `|` for alternatives
In order to force a choice between two parsers, you can use `|`:

&gt;&gt;&gt; p = nonpositional(
...     option(&#34;x&#34;, type=lambda x: int(x) + 1, help=&#34;A number that gets incremented.&#34;),
...     option(&#34;y&#34;, type=int),
...     flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
... ) &gt;&gt; done()

&gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
usage: -x X -y Y [--verbose | --quiet]
x: A number that gets incremented.

&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
{&#39;x&#39;: 2, &#39;y&#39;: 2, &#39;verbose&#39;: True}

This will fail if both `--verbose` and `--quiet` are given:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--quiet&#34;)
usage: -x X -y Y [--verbose | --quiet]
x: A number that gets incremented.
Unrecognized argument: --quiet

It will also fail if neither is given:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)
usage: -x X -y Y [--verbose | --quiet]
x: A number that gets incremented.
The following arguments are required: --verbose

## `CommandTree` for dynamic dispatch
`$λ` offers a special syntax for a common use case with alternative
command line inputs.  Often, we want a program to do one thing when a user
enters one set of command line arguments and another thing for another set.
Returning to our earlier example, what if we wanted to execute one
function if the user gave the `--verbose` flag and another if they gave `--quiet` flag?

Meet `CommandTree`:
&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def base_function(x: int, y: int):
...     raise RuntimeError(&#34;Does not execute because children are required.&#34;)
...
&gt;&gt;&gt; @base_function.command()
... def verbose_function(x: int, y: int, verbose: bool):
...     print(dict(x=x, y=y, verbose=verbose))
...
&gt;&gt;&gt; @base_function.command()
... def quiet_function(x: int, y: int, quiet: bool):
...     print(dict(x=x, y=y, quiet=quiet))

Let&#39;s see how this parser handles different inputs.
If we provide the `--verbose` flag, `$λ` automatically invokes
the `verbose_function` with the parsed arguments:

&gt;&gt;&gt; tree(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True}

If we provide the `--quiet` flag, `$λ` invokes the `quiet_function`:

&gt;&gt;&gt; tree(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;)  # execute quiet_function
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;quiet&#39;: True}

With this configuration, the parser will fail if neither
`--verbose` or `--quiet` is given:

&gt;&gt;&gt; tree(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)  # fails
usage: -x X -y Y [--verbose | --quiet]
The following arguments are required: --verbose

However, there are many other ways to use `CommandTree`,
including some that make use of the `base_function`.
To learn more, we recommend the [`CommandTree` tutorial](#commandtree-tutorial).

# Tutorial

We&#39;ve already seen many of the concepts that power `$λ` in the
[Highlights](#highlights) section. This tutorial will address
these concepts one at a time and expose the reader to some
nuances of usage.

## An example from `argparse`

Many of you are already familiar with `argparse`.
You may even recognize this example from the `argparse` docs:

```
import argparse
parser = argparse.ArgumentParser(description=&#34;calculate X to the power of Y&#34;)
group = parser.add_mutually_exclusive_group()
group.add_argument(&#34;-v&#34;, &#34;--verbose&#34;, action=&#34;store_true&#34;)
group.add_argument(&#34;-q&#34;, &#34;--quiet&#34;, action=&#34;store_true&#34;)
parser.add_argument(&#34;x&#34;, type=int, help=&#34;the base&#34;)
parser.add_argument(&#34;y&#34;, type=int, help=&#34;the exponent&#34;)
args = parser.parse_args()
```

Here is the exact equivalent in this package:

&gt;&gt;&gt; p = nonpositional(
...     (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | empty()),
...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)

This is similar to what we saw in the
[earlier section on alternatives](##for-alternatives),
 except that now we use `| empty()` to allow both
`--verbose` and `--quiet` to be omitted:

&gt;&gt;&gt; main(**p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;))
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: False, &#39;quiet&#39;: False}

Let&#39;s walk through this step by step.

## High-Level Parsers
So far we&#39;ve seen a few different parser constructors.
`flag` binds a boolean value to a variable whereas `option` binds an arbitrary value to a variable.
`empty` and `done` do not bind any values to variables, but `empty` always succeeds whereas `done` only
succeeds on the end of input.

### `flag`
&gt;&gt;&gt; p = flag(&#34;verbose&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
{&#39;verbose&#39;: True}

By default `flag` fails when it does not receive expected input:
&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose

Alternately, you can set a default value:
&gt;&gt;&gt; flag(&#34;verbose&#34;, default=False).parse_args()
{&#39;verbose&#39;: False}

### `option`
`option` is similar but takes an argument:
By default, `option` expects a single `-` for single-character variable names (as in `-x`),
as opposed to `--` for longer names (as in `--xenophon`):

&gt;&gt;&gt; option(&#34;x&#34;).parse_args(&#34;-x&#34;, &#34;1&#34;)
{&#39;x&#39;: &#39;1&#39;}
&gt;&gt;&gt; option(&#34;xenophon&#34;).parse_args(&#34;--xenophon&#34;, &#34;1&#34;)
{&#39;xenophon&#39;: &#39;1&#39;}

Use the `type` argument to convert the input to a different type:
&gt;&gt;&gt; option(&#34;x&#34;, type=int).parse_args(&#34;-x&#34;, &#34;1&#34;)  # converts &#34;1&#34; to an int
{&#39;x&#39;: 1}

### `empty`
As we&#39;ve said, `empty` always succeeds:

&gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
{}

For a more type-safe version, you can use `Parser.empty`:

&gt;&gt;&gt; p = Parser[int].empty()

`empty` is useful when you want to make an argument optional --
the definition of `Parser.optional` is:

```
def optional(self):
    return self | self.empty()
```

### `done`
Without `done` the parser will not complain about leftover (unparsed) input:

&gt;&gt;&gt; flag(&#34;verbose&#34;).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True}

`--quiet` is not parsed here but this does not cause the parser to fail.
If we want to prevent leftover inputs, we can use `done`:

&gt;&gt;&gt; (flag(&#34;verbose&#34;) &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
usage: --verbose
Unrecognized argument: --quiet

`done` is usually necessary to get `nonpositional` to behave in the way that you expect,
but more on that later.

## Parser Combinators
Parser combinators are functions that combine multiple parsers into new, more complex parsers.
Our example uses three such functions: `nonpositional`, `|` or `Parser.__or__`,
and `&gt;&gt;` or `Parser.__rshift__`.

### `Parser.__or__`

The `|` operator is used for alternatives. Specifically, it will try the first parser,
and if that fails, try the second:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;) # flag(&#34;verbose&#34;) fails
{&#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;) # flag(&#34;verbose&#34;) succeeds
{&#39;verbose&#39;: True}

By default one of the two flags would be required to prevent failure:
&gt;&gt;&gt; p.parse_args() # neither flag is provided so this fails
usage: [--verbose | --quiet]
The following arguments are required: --verbose

We can permit the omission of both flags
by using `empty`, as we saw earlier, or we can supply a default value:

&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | empty()).parse_args() # flags fail, but empty() succeeds
{}
&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;, default=False)).parse_args() # flag(&#34;verbose&#34;) fails but flag(&#34;quiet&#34;, default=False) succeeds
{&#39;quiet&#39;: False}

This is just sugar for

&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | defaults(quiet=False)).parse_args() # flag(&#34;verbose&#34;) fails but flag(&#34;quiet&#34;, default=False) succeeds
{&#39;quiet&#39;: False}

### `Parser.__rshift__`

The `&gt;&gt;` operator is used for sequential composition. It applies the first parser and then
hands the output of the first parser to the second parser. If either parser fails, the composition fails:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
{&#39;verbose&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--something-else&#34;)  # first parser will fail
usage: --verbose
Expected &#39;--verbose&#39;. Got &#39;--something-else&#39;
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--something-else&#34;)  # second parser will fail
usage: --verbose
Unrecognized argument: --something-else

### `nonpositional` and `Parser.__add__`
`nonpositional` takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:

&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

For just two parsers you can use `+`, or `Parser.__add__`, instead of `nonpositional`:
&gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

This will not cover all permutations for more than two parsers:
&gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;) + option(&#34;x&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;--quiet&#34;)
usage: --verbose --quiet -x X
Expected &#39;--quiet&#39;. Got &#39;-x&#39;

To see why note the implicit parentheses:
&gt;&gt;&gt; p = (flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;)) + option(&#34;x&#34;)

In order to cover the case where `-x` comes between `--verbose` and `--quiet`,
use `nonpositional`:
&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;), option(&#34;x&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;--quiet&#34;)  # works
{&#39;verbose&#39;: True, &#39;x&#39;: &#39;1&#39;, &#39;quiet&#39;: True}

If alternatives or defaults appear among the arguments to `nonpositional`, you will probably want
to add `&gt;&gt;` followed by `done` (or another parser) after `nonpositional`. Otherwise,
the parser will not behave as expected:

&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;quiet&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # you expect this to set verbose to True, but it doesn&#39;t
{&#39;verbose&#39;: False, &#39;quiet&#39;: True}

Why is happening? There are two permutions:

- `flag(&#34;verbose&#34;, default=False) &gt;&gt; flag(&#34;quiet&#34;)` and
- `flag(&#34;quiet&#34;) &gt;&gt; flag(&#34;verbose&#34;, default=False)`

In our example, both permutations are actually succeeding. This first succeeds by falling
back to the default, and leaving the last word of the input, `--verbose`, unparsed.
Either interpretation is valid, and `nonpositional` returns one arbitrarily -- just not the one we expected.

Now let&#39;s add `&gt;&gt; done()` to the end:
&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;quiet&#34;)) &gt;&gt; done()

This ensures that the first permutation will fail because the leftover `--verbose` input will
cause the `done` parser to fail:
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

## Putting it all together
Let&#39;s recall the original example:

&gt;&gt;&gt; p = nonpositional(
...     (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | empty()),
...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)

As we&#39;ve seen, `flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | empty()` succeeds on either `--verbose` or `--quiet`
or neither.

`option(&#34;x&#34;, type=int)` succeeds on `-x X`, where `X` is
some integer, binding that integer to the variable `&#34;x&#34;`. Similarly for `option(&#34;y&#34;, type=int)`.

`nonpositional` takes the three parsers:

- `flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | empty()`
- `option(&#34;x&#34;, type=int)`
- `option(&#34;y&#34;, type=int)`

and applies them in every order, until some order succeeds.
Finally `done()` ensures that only one of these parser permutations will succeed, preventing ambiguity.

## Variations on the example
### Variable numbers of arguments

What if there was a special argument, `verbosity`,
that only makes sense if the user chooses `--verbose`?

&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&#34;verbose&#34;) + option(&#34;verbosity&#34;, type=int)) | flag(&#34;quiet&#34;)),
...         option(&#34;x&#34;, type=int),
...         option(&#34;y&#34;, type=int),
...     )
...     &gt;&gt; done()
... )

Remember that `+` or `Parser.__add__` evaluates two parsers in both orders
and stopping at the first order that succeeds. So this allows us to
supply `--verbose` and `--verbosity` in any order.

&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbosity&#34;, &#34;3&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;verbosity&#39;: 3}
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
usage: [--verbose --verbosity VERBOSITY | --quiet] -x X -y Y
Expected &#39;--verbose&#39;. Got &#39;-x&#39;

This is also a case where you might want to use `CommandTree`:

&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(help=dict(x=&#34;the base&#34;, y=&#34;the exponent&#34;))
... def base_function(x: int, y: int):
...     raise RuntimeError(&#34;This function will not execute.&#34;)
...
&gt;&gt;&gt; @base_function.command()
... def verbose_function(x: int, y: int, verbose: bool, verbosity: int):
...     print(dict(x=x, y=y, verbose=verbose, verbosity=verbosity))
...
&gt;&gt;&gt; @base_function.command()
... def quiet_function(x: int, y: int, quiet: bool):
...     print(dict(x=x, y=y, quiet=quiet))
...
&gt;&gt;&gt; tree(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbosity&#34;, &#34;3&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;verbosity&#39;: 3}

### `Parser.many`

What if we want to specify verbosity by the number of times that `--verbose` appears?
For this we need `Parser.many`. Before showing how we could use `Parser.many` in this setting,
let&#39;s look at how it works.

`parser.many` takes `parser` and tries to apply it as many times as possible.
`Parser.many` is a bit like the `*` pattern, if you are familiar with regexes.
`parser.many` always succeeds:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p.parse_args(&#34;blah&#34;)  # still succeeds
{}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;blah&#34;)  # still succeeds
{&#39;verbose&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--verbose&#34;, return_dict=False)
[(&#39;verbose&#39;, True), (&#39;verbose&#39;, True)]

As you can see, `return_dict=False` returns a list of tuples instead of a dict, so that you
can have duplicate keys.

Now returning to the original example:

&gt;&gt;&gt; p = (
...     nonpositional(
...         flag(&#34;verbose&#34;).many(),
...         option(&#34;x&#34;, type=int),
...         option(&#34;y&#34;, type=int),
...     )
...     &gt;&gt; done()
... )
&gt;&gt;&gt; args = p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbose&#34;, return_dict=False)
&gt;&gt;&gt; args
[(&#39;x&#39;, 1), (&#39;y&#39;, 2), (&#39;verbose&#39;, True), (&#39;verbose&#39;, True)]
&gt;&gt;&gt; verbosity = args.count((&#39;verbose&#39;, True))
&gt;&gt;&gt; verbosity
2

### `Parser.many1`

In the previous example, the parse will default to `verbosity=0` if no `--verbose` flags
are given.  What if we wanted users to be explicit about choosing a &#34;quiet&#34; setting?
In other words, what if the user actually had to provide an explicit `--quiet` flag when
no `--verbose` flags were given?

For this, we use `Parser.many1`. This method is like `Parser.many` except that it fails
when on zero successes (recall that `Parser.many` always succeeds). So if `Parser.many`
is like regex `*`, `Parser.many1` is like `+`. Take a look:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p = flag(&#34;verbose&#34;).many1()
&gt;&gt;&gt; p.parse_args()  # fails
usage: --verbose [--verbose ...]
The following arguments are required: --verbose
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)  # succeeds
{&#39;verbose&#39;: True}

To compell that `--quiet` flag from our users, we can do the following:

&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&#34;verbose&#34;).many1()) | flag(&#34;quiet&#34;)),
...         option(&#34;x&#34;, type=int),
...         option(&#34;y&#34;, type=int),
...     )
...     &gt;&gt; done()
... )

Now omitting both `--verbose` and `--quiet` will fail:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)
usage: [--verbose [--verbose ...] | --quiet] -x X -y Y
Expected &#39;--verbose&#39;. Got &#39;-x&#39;
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;) # this succeeds
{&#39;verbose&#39;: True, &#39;x&#39;: 1, &#39;y&#39;: 2}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;) # and this succeeds
{&#39;quiet&#39;: True, &#39;x&#39;: 1, &#39;y&#39;: 2}

# `CommandTree` Tutorial
`CommandTree` has already shown up in the
[Highlights section](#commandtree-for-dynamic-dispatch)
and in the earlier [tutorial](#variations-on-the-example).
In this section we will give a more thorough treatment,
exposing some of the underlying logic and covering all
the variations in functionality that `CommandTree`
offers.

## `CommandTree.command`

First let&#39;s walk through the use of the `CommandTree.command` decorator, one step
at a time. First we define the object:

&gt;&gt;&gt; tree = CommandTree()

Now we define at least one child function:

&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))

At this point `tree` is just a parser that takes a single option `-a`:

&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A

Now let&#39;s add a second child function:

&gt;&gt;&gt; @tree.command()
... def f2(b: bool):
...     return dict(f2=dict(b=b))
...
&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: [-a A | -b]

`tree` will execute either `f1` or `f2` based on which of the parsers succeeds.
This will execute `f1`:

&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;)
{&#39;f1&#39;: {&#39;a&#39;: 1}}

This will execute `f2`:

&gt;&gt;&gt; tree(&#34;-b&#34;)
{&#39;f2&#39;: {&#39;b&#39;: True}}

This fails:

&gt;&gt;&gt; tree()
usage: [-a A | -b]
The following arguments are required: -a

Often in cases where there are alternative sets of argument like this,
there is also a set of shared arguments. It would be cumbersome to have to
repeat these for both child functions. Instead we can define a parent function
as follows:

&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     raise RuntimeError(&#34;This function will not execute.&#34;)

And a child function, `g1`:

&gt;&gt;&gt; @f1.command()  # note f1, not tree
... def g1(a:int, b: bool):
...     return dict(g1=dict(b=b))

Make sure to include all the arguments of `f1` in `g1` or else
`g1` will fail when it is invoked. In its current state, `tree` sequences
 the arguments of `f1` and `g1`:

&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A -b

As before we can define an additional child function to induce alternative
argument sets:

&gt;&gt;&gt; @f1.command()  # note f1, not tree
... def g2(a: int, c: str):
...     return dict(g2=dict(c=c))

Note that our usage message shows `-a A` preceding the brackets:
&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A [-b | -c C]

To execute `g1`, we give the `-b` flag:
&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;, &#34;-b&#34;)
{&#39;g1&#39;: {&#39;b&#39;: True}}

To execute `g2`, we give the `-c` flag:
&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;, &#34;-c&#34;, &#34;foo&#34;)
{&#39;g2&#39;: {&#39;c&#39;: &#39;foo&#39;}}

Also, note that `tree` can have arbitrary depth:

&gt;&gt;&gt; @g1.command()  # h1 is a child of g1
... def h1(a: int, b: bool, d: float):
...    return dict(h1=dict(d=d))

&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A [-b -d D | -c C]

## `CommandTree.subcommand`
Often we want to explicitly specify which function to execute by naming it on the command line.
This would implement functionality similar to
[`ArgumentParser.add_subparsers`](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers)

For this we would use the `CommandTree.subcommand` decorator:

&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     raise RuntimeError(&#34;This function should not be called&#34;)
...
&gt;&gt;&gt; @f1.subcommand()  # note subcommand, not command
... def g1(a:int, b: bool):
...     return dict(g1=dict(b=b))
...
&gt;&gt;&gt; @f1.subcommand()  # again, subcommand, not command
... def g2(a: int, c: str):
...     return dict(g2=dict(c=c))

Now the usage message indicates that `g1` and `g2` are required arguments:
&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A [g1 -b | g2 -c C]

Now we would select g1 as follows:
&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;, &#34;g1&#34;, &#34;-b&#34;)
{&#39;g1&#39;: {&#39;b&#39;: True}}

And g2 as follows:
&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;, &#34;g2&#34;, &#34;-c&#34;, &#34;foo&#34;)
{&#39;g2&#39;: {&#39;c&#39;: &#39;foo&#39;}}

# Why `$λ`?

`$λ` can handle many kinds of argument-parsing patterns
that are either very awkward, difficult, or impossible with other parsing libraries.
In particular, we emphasize the following qualities:

### Versatile
`$λ` provides high-level functionality equivalent to other parsers. But unlike other parsers,
it permits low-level customization to handle arbitrarily complex parsing patterns.
There are many parsing patterns that `$λ` can handle which are not possible with other parsing libraries.

### Type-safe
`$λ` uses type annotations as much as Python allows. Types are checked using [`MyPy`](
https://mypy.readthedocs.io/en/stable/index.html#) and exported with the package so that users can also benefit from
the type system. Furthermore, with rare exceptions, `$λ` avoids mutations and side-effects and preserves [referential
transparency](https://en.wikipedia.org/wiki/Referential_transparency). This makes it easier for the type-checker _and
for the user_ to reason about the code.

### Concise
`$λ` provides many syntactic shortcuts for cutting down boilerplate:

- operators like `&gt;&gt;`, `|`, and `+` (and `&gt;=` if you want to get fancy)
- the `command` decorator and the `CommandTree` object for building tree-shaped parsers
- the `Args` syntax built on top of python `dataclasses`.


As a rule, `$λ` avoids reproducing python functionality and focuses on the main job of
an argument parser: parsing.
&#34;&#34;&#34;


__pdoc__ = {}

from dollar_lambda.args import Args, field
from dollar_lambda.decorators import CommandTree, command
from dollar_lambda.parser import (
    Parser,
    apply,
    apply_item,
    argument,
    defaults,
    done,
    empty,
    equals,
    flag,
    item,
    nonpositional,
    option,
    sat,
    sat_item,
    type_,
    wrap_help,
)

__all__ = [
    &#34;Parser&#34;,
    &#34;empty&#34;,
    &#34;apply&#34;,
    &#34;apply_item&#34;,
    &#34;argument&#34;,
    &#34;done&#34;,
    &#34;equals&#34;,
    &#34;flag&#34;,
    &#34;item&#34;,
    &#34;nonpositional&#34;,
    &#34;option&#34;,
    &#34;sat&#34;,
    &#34;sat_item&#34;,
    &#34;type_&#34;,
    &#34;Args&#34;,
    &#34;defaults&#34;,
    &#34;field&#34;,
    &#34;wrap_help&#34;,
    &#34;command&#34;,
    &#34;CommandTree&#34;,
]


__pdoc__[&#34;Parser.__add__&#34;] = True
__pdoc__[&#34;Parser.__or__&#34;] = True
__pdoc__[&#34;Parser.__rshift__&#34;] = True
__pdoc__[&#34;Parser.__ge__&#34;] = True</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="dollar_lambda.args" href="args.html">dollar_lambda.args</a></code></dt>
<dd>
<div class="desc"><p>Defines the <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> dataclass and associated functions.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.decorators" href="decorators.html">dollar_lambda.decorators</a></code></dt>
<dd>
<div class="desc"><p>Defines the <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> decorator and the <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> class.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.error" href="error.html">dollar_lambda.error</a></code></dt>
<dd>
<div class="desc"><p>Defines errors which can be raised by parsers.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.key_value" href="key_value.html">dollar_lambda.key_value</a></code></dt>
<dd>
<div class="desc"><p>Defines <code>KeyValue</code> which stores pairs of variable names (keys) and values.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code></dt>
<dd>
<div class="desc"><p>Defines parsing functions and the <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> class that they instantiate.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.result" href="result.html">dollar_lambda.result</a></code></dt>
<dd>
<div class="desc"><p>Defines the <code>Result</code> dataclass, representing success or failure, output by parsers.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.sequence" href="sequence.html">dollar_lambda.sequence</a></code></dt>
<dd>
<div class="desc"><p>Defines <code>Sequence</code>, a strongly-typed immutable list that implements <code>MonadPlus</code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dollar_lambda.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>f: Callable[[~A], <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[~B]], parser: <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~A]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~B]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the output of <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> and applies <code>f</code> to it. Convert any errors that arise into <code>ArgumentError</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;hello&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;--hello&quot;, return_dict=False)
[('hello', True)]
</code></pre>
<p>This will double <code>p1</code>'s output:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p2 = apply(lambda kv: Result.return_(kv + kv), p1)
&gt;&gt;&gt; p2.parse_args(&quot;--hello&quot;, return_dict=False)
[('hello', True), ('hello', True)]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L425-L454" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply(
    f: Callable[[A], Result[B]], parser: Parser[A]  # type: ignore[misc]
) -&gt; Parser[B]:
    &#34;&#34;&#34;
    Takes the output of `parser` and applies `f` to it. Convert any errors that arise into `ArgumentError`.

    &gt;&gt;&gt; p1 = flag(&#34;hello&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;--hello&#34;, return_dict=False)
    [(&#39;hello&#39;, True)]

    This will double `p1`&#39;s output:
    &gt;&gt;&gt; p2 = apply(lambda kv: Result.return_(kv + kv), p1)
    &gt;&gt;&gt; p2.parse_args(&#34;--hello&#34;, return_dict=False)
    [(&#39;hello&#39;, True), (&#39;hello&#39;, True)]
    &#34;&#34;&#34;

    def g(a: A) -&gt; Parser[B]:
        try:
            y = f(a)
        except Exception as e:
            usage = f&#34;An argument {a}: raised exception {e}&#34;
            y = Result(ArgumentError(usage))
        return Parser(
            lambda cs: y &gt;= (lambda parsed: Result.return_(Parse(parsed, cs))),
            usage=parser.usage,
            helps=parser.helps,
        )

    p = parser &gt;= g
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.apply_item"><code class="name flex">
<span>def <span class="ident">apply_item</span></span>(<span>f: Callable[[str], ~B], description: str) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~B]</span>
</code></dt>
<dd>
<div class="desc"><p>A shortcut for <code><a title="dollar_lambda.apply" href="#dollar_lambda.apply">apply()</a>(f, <a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a>(description))</code>
and spares <code>f</code> the trouble of outputting a <code>Result</code> object.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = argument(&quot;foo&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;bar&quot;, return_dict=False)
[('foo', 'bar')]
</code></pre>
<p>Here we use <code>f</code> to directly manipulate the binding generated by <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p2 = apply_item(lambda bar: [KeyValue(bar + &quot;e&quot;, bar + &quot;f&quot;)], description=&quot;baz&quot;)
&gt;&gt;&gt; p2.parse_args(&quot;bar&quot;, return_dict=False)
[('bare', 'barf')]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L457-L481" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply_item(f: Callable[[str], B], description: str) -&gt; Parser[B]:
    &#34;&#34;&#34;
    A shortcut for `apply(f, item(description))`
    and spares `f` the trouble of outputting a `Result` object.

    &gt;&gt;&gt; p1 = argument(&#34;foo&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;bar&#34;, return_dict=False)
    [(&#39;foo&#39;, &#39;bar&#39;)]

    Here we use `f` to directly manipulate the binding generated by `item`:
    &gt;&gt;&gt; p2 = apply_item(lambda bar: [KeyValue(bar + &#34;e&#34;, bar + &#34;f&#34;)], description=&#34;baz&#34;)
    &gt;&gt;&gt; p2.parse_args(&#34;bar&#34;, return_dict=False)
    [(&#39;bare&#39;, &#39;barf&#39;)]
    &#34;&#34;&#34;

    def g(parsed: Sequence[KeyValue[str]]) -&gt; Result[B]:
        [kv] = parsed
        try:
            y = f(kv.value)
        except Exception as e:
            usage = f&#34;argument {kv.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        return Result.return_(y)

    return apply(g, item(description))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.argument"><code class="name flex">
<span>def <span class="ident">argument</span></span>(<span>dest: str) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a single word and binds it to <code>dest</code>.
Useful for positional arguments.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;name&quot;).parse_args(&quot;Alice&quot;)
{'name': 'Alice'}
&gt;&gt;&gt; argument(&quot;name&quot;).parse_args()
usage: name
The following arguments are required: name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L484-L495" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def argument(dest: str) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    Parses a single word and binds it to `dest`.
    Useful for positional arguments.

    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args()
    usage: name
    The following arguments are required: name
    &#34;&#34;&#34;
    return item(dest)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>flip_bools: bool = True, help: Optional[Dict[str, str]] = None, strings: Optional[Dict[str, str]] = None, types: Optional[Dict[str, Callable[[str], Any]]] = None) <span style="white-space: nowrap;">-></span> Callable[[Callable], Callable]</span>
</code></dt>
<dd>
<div class="desc"><p>A succinct way to generate a simple <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> parser. <code>@command</code> derives the
component parsers from the function's signature and automatically executes the function with
the parsed arguments, if parsing succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(a=&quot;something about a&quot;), types=dict(a=lambda x: int(x) + 1))
... def f(a: int = 1, b: bool = False):
...     return dict(a=a, b=b)
&gt;&gt;&gt; f(&quot;-a&quot;, &quot;2&quot;, &quot;-b&quot;)
{'a': 3, 'b': True}
</code></pre>
<p>If the wrapped function receives no arguments (as in <code>f()</code>), the parser will take
<code>sys.argv[1:]</code> as the input.</p>
<p>Note that <code>@command</code> does not handle mutually exclusive arguments or alternative
arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>For boolean arguments that default to true, this changes the flag from <code>--{dest}</code> to <code>--no-{dest}</code>:</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>A dictionary of help strings for the arguments.</dd>
<dt><strong><code>strings</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>This dictionary maps variable names to the strings that the parser will look for in the input.</dd>
<dt><strong><code>types</code></strong> :&ensp;<code>dict[str, Callable[[str], Any]]</code></dt>
<dd>This dictionary maps variable names to custom type converters.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command()
... def f(cuda: bool = True):
...     return dict(cuda=cuda)
&gt;&gt;&gt; f()
{'cuda': True}
&gt;&gt;&gt; f(&quot;--no-cuda&quot;)  # flip_bools adds --no- to the flag
{'cuda': False}
</code></pre>
<p>As the following example demonstrates, when <code>flip_bools=False</code> output can be somewhat confusing:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(flip_bools=False)
... def f(cuda: bool = True):
...     return dict(cuda=cuda)
&gt;&gt;&gt; f(&quot;--cuda&quot;)
{'cuda': False}
</code></pre>
<p>Here is an example using the <code>help</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(quiet=&quot;Be quiet&quot;))
... def f(quiet: bool):
...     return dict(quiet=quiet)
&gt;&gt;&gt; f(&quot;--help&quot;)
usage: --quiet
quiet: Be quiet
</code></pre>
<p>Here is an example using the <code>strings</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(strings=dict(quiet=&quot;--quiet-mode&quot;))
... def f(quiet: bool):
...     return dict(quiet=quiet)
&gt;&gt;&gt; f(&quot;--quiet-mode&quot;)
{'quiet': True}
&gt;&gt;&gt; f(&quot;--quiet&quot;)
usage: --quiet-mode
Expected '--quiet-mode'. Got '--quiet'
</code></pre>
<p>Here is an example using the <code>type</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(types=dict(x=lambda x: int(x) + 1))
... def f(x: int):
...     return dict(x=x)
&gt;&gt;&gt; f(&quot;-x&quot;, &quot;0&quot;)
{'x': 1}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/decorators.py#L56-L159" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def command(
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    strings: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable[[Callable], Callable]:
    &#34;&#34;&#34;
    A succinct way to generate a simple `nonpositional` parser. `@command` derives the
    component parsers from the function&#39;s signature and automatically executes the function with
    the parsed arguments, if parsing succeeds:

    &gt;&gt;&gt; @command(help=dict(a=&#34;something about a&#34;), types=dict(a=lambda x: int(x) + 1))
    ... def f(a: int = 1, b: bool = False):
    ...     return dict(a=a, b=b)
    &gt;&gt;&gt; f(&#34;-a&#34;, &#34;2&#34;, &#34;-b&#34;)
    {&#39;a&#39;: 3, &#39;b&#39;: True}

    If the wrapped function receives no arguments (as in `f()`), the parser will take
    `sys.argv[1:]` as the input.

    Note that `@command` does not handle mutually exclusive arguments or alternative
    arguments.

    Parameters
    ----------
    flip_bools : bool
        For boolean arguments that default to true, this changes the flag from `--{dest}` to `--no-{dest}`:

    help : dict[str, str]
        A dictionary of help strings for the arguments.

    strings : dict[str, str]
        This dictionary maps variable names to the strings that the parser will look for in the input.

    types: dict[str, Callable[[str], Any]]
        This dictionary maps variable names to custom type converters.

    Examples
    --------

    &gt;&gt;&gt; @command()
    ... def f(cuda: bool = True):
    ...     return dict(cuda=cuda)
    &gt;&gt;&gt; f()
    {&#39;cuda&#39;: True}
    &gt;&gt;&gt; f(&#34;--no-cuda&#34;)  # flip_bools adds --no- to the flag
    {&#39;cuda&#39;: False}

    As the following example demonstrates, when `flip_bools=False` output can be somewhat confusing:

    &gt;&gt;&gt; @command(flip_bools=False)
    ... def f(cuda: bool = True):
    ...     return dict(cuda=cuda)
    &gt;&gt;&gt; f(&#34;--cuda&#34;)
    {&#39;cuda&#39;: False}

    Here is an example using the `help` parameter:

    &gt;&gt;&gt; @command(help=dict(quiet=&#34;Be quiet&#34;))
    ... def f(quiet: bool):
    ...     return dict(quiet=quiet)
    &gt;&gt;&gt; f(&#34;--help&#34;)
    usage: --quiet
    quiet: Be quiet

    Here is an example using the `strings` parameter:

    &gt;&gt;&gt; @command(strings=dict(quiet=&#34;--quiet-mode&#34;))
    ... def f(quiet: bool):
    ...     return dict(quiet=quiet)
    &gt;&gt;&gt; f(&#34;--quiet-mode&#34;)
    {&#39;quiet&#39;: True}
    &gt;&gt;&gt; f(&#34;--quiet&#34;)
    usage: --quiet-mode
    Expected &#39;--quiet-mode&#39;. Got &#39;--quiet&#39;

    Here is an example using the `type` parameter:

    &gt;&gt;&gt; @command(types=dict(x=lambda x: int(x) + 1))
    ... def f(x: int):
    ...     return dict(x=x)
    &gt;&gt;&gt; f(&#34;-x&#34;, &#34;0&#34;)
    {&#39;x&#39;: 1}
    &#34;&#34;&#34;

    def wrapper(func: Callable) -&gt; Callable:
        p = (
            _func_to_parser(
                func, flip_bools=flip_bools, help=help, strings=strings, types=types
            )
            &gt;&gt; done()
        )
        p = wrap_help(p)

        def wrapped(*args) -&gt; Any:
            parsed = p.parse_args(*args)
            if parsed is None:
                return
            assert isinstance(parsed, Dict), parsed
            return func(**parsed)

        return wrapped

    return wrapper</code></pre>
</details>
</dd>
<dt id="dollar_lambda.defaults"><code class="name flex">
<span>def <span class="ident">defaults</span></span>(<span>**kwargs: Any) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Useful for assigning default values to arguments.
It ignore the input and always returns <code>kwargs</code> converted into <code>Sequence[KeyValue]</code>.
<code><a title="dollar_lambda.defaults" href="#dollar_lambda.defaults">defaults()</a></code> never fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; defaults(a=1, b=2).parse_args()
{'a': 1, 'b': 2}
&gt;&gt;&gt; (flag(&quot;fails&quot;) | defaults(fails=&quot;succeeds&quot;)).parse_args()
{'fails': 'succeeds'}
</code></pre>
<p>Here's a more complex example derived from the tutorial:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (
...         flag(&quot;verbose&quot;) + defaults(quiet=False)  # either --verbose and default &quot;quiet&quot; to False
...         | flag(&quot;quiet&quot;) + defaults(verbose=False)  # or --quiet and default &quot;verbose&quot; to False
...     ),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... ) &gt;&gt; done()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'quiet': False}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L498-L523" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def defaults(**kwargs: Any) -&gt; Parser[Sequence[KeyValue[Any]]]:
    &#34;&#34;&#34;
    Useful for assigning default values to arguments.
    It ignore the input and always returns `kwargs` converted into `Sequence[KeyValue]`.
    `defaults` never fails.

    &gt;&gt;&gt; defaults(a=1, b=2).parse_args()
    {&#39;a&#39;: 1, &#39;b&#39;: 2}
    &gt;&gt;&gt; (flag(&#34;fails&#34;) | defaults(fails=&#34;succeeds&#34;)).parse_args()
    {&#39;fails&#39;: &#39;succeeds&#39;}

    Here&#39;s a more complex example derived from the tutorial:
    &gt;&gt;&gt; p = nonpositional(
    ...     (
    ...         flag(&#34;verbose&#34;) + defaults(quiet=False)  # either --verbose and default &#34;quiet&#34; to False
    ...         | flag(&#34;quiet&#34;) + defaults(verbose=False)  # or --quiet and default &#34;verbose&#34; to False
    ...     ),
    ...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
    ...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
    ... ) &gt;&gt; done()

    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
    {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}
    &#34;&#34;&#34;
    p = Parser.return_(Sequence([KeyValue(k, v) for k, v in kwargs.items()]))
    return replace(p, usage=None)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> succeds on the end of input and fails on everything else.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; done().parse_args()
{}
&gt;&gt;&gt; done().parse_args(&quot;arg&quot;)
Unrecognized argument: arg
</code></pre>
<p>Without <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> the parser will not complain about leftover (unparsed) input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True}
</code></pre>
<p><code>--quiet</code> is not parsed here but this does not cause the parser to fail.
If we want to prevent leftover inputs, we can use <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) &gt;&gt; done()).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
usage: --verbose
Unrecognized argument: --quiet
</code></pre>
<p><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> is usually necessary to get <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> to behave in the way that you expect.
See <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> API docs for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L526-L558" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def done() -&gt; Parser[Sequence[A]]:
    &#34;&#34;&#34;
    `done` succeds on the end of input and fails on everything else.
    &gt;&gt;&gt; done().parse_args()
    {}
    &gt;&gt;&gt; done().parse_args(&#34;arg&#34;)
    Unrecognized argument: arg

    Without `done` the parser will not complain about leftover (unparsed) input:

    &gt;&gt;&gt; flag(&#34;verbose&#34;).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
    {&#39;verbose&#39;: True}

    `--quiet` is not parsed here but this does not cause the parser to fail.
    If we want to prevent leftover inputs, we can use `done`:

    &gt;&gt;&gt; (flag(&#34;verbose&#34;) &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
    usage: --verbose
    Unrecognized argument: --quiet

    `done` is usually necessary to get `nonpositional` to behave in the way that you expect.
    See `nonpositional` API docs for details.
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[Sequence[A]]]:
        if cs:
            c, *_ = cs
            return Result(
                UnexpectedError(unexpected=c, usage=f&#34;Unrecognized argument: {c}&#34;)
            )
        return Result(NonemptyList(Parse(parsed=Sequence([]), unparsed=cs)))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Always returns {}, no matter the input. Mostly useful for use in <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; empty().parse_args(&quot;any&quot;, &quot;arguments&quot;)
{}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L52-L58" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def empty() -&gt; &#34;Parser[Sequence]&#34;:
    &#34;&#34;&#34;
    Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
    &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
    {}
    &#34;&#34;&#34;
    return Parser[Sequence[A]].empty()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.equals"><code class="name flex">
<span>def <span class="ident">equals</span></span>(<span>s: str, peak=False) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the next word is <code>s</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; equals(&quot;hello&quot;).parse_args(&quot;hello&quot;)
{'hello': 'hello'}
&gt;&gt;&gt; equals(&quot;hello&quot;).parse_args(&quot;goodbye&quot;)
usage: hello
Expected 'hello'. Got 'goodbye'
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>The word to that input will be checked against for equality.</dd>
<dt><strong><code>peak</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>False</code>, then the parser will consume the word and return the remaining words as <code>unparsed</code>.
If <code>True</code>, then the parser leaves the <code>unparsed</code> component unchanged.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = equals(&quot;hello&quot;) &gt;&gt; equals(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
{'hello': 'hello', 'goodbye': 'goodbye'}
</code></pre>
<p>Look what happens when <code>peak=True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = equals(&quot;hello&quot;, peak=True) &gt;&gt; equals(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
usage: hello goodbye
Expected 'goodbye'. Got 'hello'
</code></pre>
<p>The first parser didn't consume the word and so "hello" got passed on to <code>equals("goodbye")</code>.
But this would work:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = equals(&quot;hello&quot;, peak=True) &gt;&gt; equals(&quot;hello&quot;) &gt;&gt;equals(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
{'hello': 'hello', 'goodbye': 'goodbye'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L561-L613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def equals(s: str, peak=False) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    Checks if the next word is `s`.

    &gt;&gt;&gt; equals(&#34;hello&#34;).parse_args(&#34;hello&#34;)
    {&#39;hello&#39;: &#39;hello&#39;}
    &gt;&gt;&gt; equals(&#34;hello&#34;).parse_args(&#34;goodbye&#34;)
    usage: hello
    Expected &#39;hello&#39;. Got &#39;goodbye&#39;

    Parameters
    ----------
    s: str
        The word to that input will be checked against for equality.
    peak : bool
        If `False`, then the parser will consume the word and return the remaining words as `unparsed`.
        If `True`, then the parser leaves the `unparsed` component unchanged.

    Examples
    --------

    &gt;&gt;&gt; p = equals(&#34;hello&#34;) &gt;&gt; equals(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    {&#39;hello&#39;: &#39;hello&#39;, &#39;goodbye&#39;: &#39;goodbye&#39;}

    Look what happens when `peak=True`:
    &gt;&gt;&gt; p = equals(&#34;hello&#34;, peak=True) &gt;&gt; equals(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    usage: hello goodbye
    Expected &#39;goodbye&#39;. Got &#39;hello&#39;

    The first parser didn&#39;t consume the word and so &#34;hello&#34; got passed on to `equals(&#34;goodbye&#34;)`.
    But this would work:
    &gt;&gt;&gt; p = equals(&#34;hello&#34;, peak=True) &gt;&gt; equals(&#34;hello&#34;) &gt;&gt;equals(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    {&#39;hello&#39;: &#39;hello&#39;, &#39;goodbye&#39;: &#39;goodbye&#39;}
    &#34;&#34;&#34;
    if peak:
        return sat_peak(
            predicate=lambda _s: _s == s,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )
    else:
        return sat_item(
            predicate=lambda _s: _s == s,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.field"><code class="name flex">
<span>def <span class="ident">field</span></span>(<span>help: Optional[str] = None, metadata: Optional[dict] = None, type: Optional[ForwardRef('type | Callable[[str], Any]')] = None, **kwargs) <span style="white-space: nowrap;">-></span> dataclasses.Field</span>
</code></dt>
<dd>
<div class="desc"><p>This is a thin wrapper around <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.field</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>help</code></strong> :&ensp;<code>str</code></dt>
<dd>An optional help string for the argument.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>str</code></dt>
<dd>Identical to the <code>metadata</code> argument for <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.field</code></a>.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Optional[type | Callable[[str], Any]]</code></dt>
<dd>A function that takes a string and returns a value just like the <code>type</code> argument for
<a href="https://docs.python.org/3/library/argparse.html#type"><code>ArgumentParser.add_argument</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>dataclasses.Field</code> object that can be used in place of a default argument as
described in the <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.Field</code> documentation</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/args.py#L14-L45" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def field(
    help: Optional[str] = None,
    metadata: Optional[dict] = None,
    type: Optional[&#34;type | Callable[[str], Any]&#34;] = None,
    **kwargs,
) -&gt; Field:
    &#34;&#34;&#34;
    This is a thin wrapper around [`dataclasses.field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).

    Parameters
    ----------
    help : str
        An optional help string for the argument.
    metadata : str
        Identical to the `metadata` argument for [`dataclasses.field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).
    type : Optional[type | Callable[[str], Any]]
        A function that takes a string and returns a value just like the `type` argument for
        [`ArgumentParser.add_argument`](https://docs.python.org/3/library/argparse.html#type).

    Returns
    -------
    A `dataclasses.Field` object that can be used in place of a default argument as
    described in the [`dataclasses.Field` documentation](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).

    &#34;&#34;&#34;
    if metadata is None:
        metadata = {}
    if type is not None:
        metadata.update(type=type)
    if help is not None:
        metadata.update(help=help)
    return dataclasses.field(metadata=metadata, **kwargs)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.flag"><code class="name flex">
<span>def <span class="ident">flag</span></span>(<span>dest: str, default: Optional[bool] = None, help: Optional[str] = None, short: bool = True, string: Optional[str] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[bool]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Binds a boolean value to a variable.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>The variable to which the value will be bound.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>An optional default value.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>An optional help string.</dd>
<dt><strong><code>short</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to check for the short form of the flag, which
uses a single dash and the first character of <code>dest</code>, e.g. <code>-f</code> for <code>foo</code>.</dd>
<dt><strong><code>string</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>A custom string to use for the flag. Defaults to <code>--{dest}</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Here is an example using the <code>default</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;, default=False)
&gt;&gt;&gt; p.parse_args()
{'verbose': False}
</code></pre>
<p>By default <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> fails when it does not receive expected input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose
</code></pre>
<p>Here is an example using the <code>help</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;, help=&quot;Turn on verbose output.&quot;)
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: --verbose
verbose: Turn on verbose output.
</code></pre>
<p>Here is an example using the <code>short</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;, short=True).parse_args(&quot;-v&quot;)  # this is the default
{'verbose': True}
&gt;&gt;&gt; flag(&quot;verbose&quot;, short=False).parse_args(&quot;-v&quot;)  # fails
usage: --verbose
Expected '--verbose'. Got '-v'
</code></pre>
<p>Here is an example using the <code>string</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;value&quot;, string=&quot;v&quot;).parse_args(&quot;v&quot;)  # note that string does not have to start with -
{'value': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L616-L705" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flag(
    dest: str,
    default: Optional[bool] = None,
    help: Optional[str] = None,
    short: bool = True,
    string: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[bool]]]:
    &#34;&#34;&#34;
    Binds a boolean value to a variable.

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}


    Parameters
    ----------
    dest : str
        The variable to which the value will be bound.

    default : Optional[bool]
        An optional default value.

    help : Optional[str]
        An optional help string.

    short : bool
        Whether to check for the short form of the flag, which
        uses a single dash and the first character of `dest`, e.g. `-f` for `foo`.

    string : Optional[str]
        A custom string to use for the flag. Defaults to `--{dest}`.

    Examples
    --------

    Here is an example using the `default` parameter:

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, default=False)
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False}

    By default `flag` fails when it does not receive expected input:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args()
    usage: --verbose
    The following arguments are required: --verbose

    Here is an example using the `help` parameter:

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, help=&#34;Turn on verbose output.&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --verbose
    verbose: Turn on verbose output.

    Here is an example using the `short` parameter:

    &gt;&gt;&gt; flag(&#34;verbose&#34;, short=True).parse_args(&#34;-v&#34;)  # this is the default
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; flag(&#34;verbose&#34;, short=False).parse_args(&#34;-v&#34;)  # fails
    usage: --verbose
    Expected &#39;--verbose&#39;. Got &#39;-v&#39;

    Here is an example using the `string` parameter:

    &gt;&gt;&gt; flag(&#34;value&#34;, string=&#34;v&#34;).parse_args(&#34;v&#34;)  # note that string does not have to start with -
    {&#39;value&#39;: True}
    &#34;&#34;&#34;
    if string is None:
        _string = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _string = string

    def f(
        cs: Sequence[str],
        s: str,
    ) -&gt; Result[Parse[Sequence[KeyValue[bool]]]]:
        parser = equals(s) &gt;= (lambda _: defaults(**{dest: not default}))
        return parser.parse(cs)

    parser = Parser(partial(f, s=_string), usage=None, helps={})
    if short:
        short_string = f&#34;-{dest[0]}&#34;
        parser2 = flag(dest, short=False, string=short_string, default=default)
        parser = parser | parser2
    if default:
        help = f&#34;{help + &#39; &#39; if help else &#39;&#39;}(default: {default})&#34;
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=_string, helps=helps)
    return parser if default is None else parser | defaults(**{dest: default})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.item"><code class="name flex">
<span>def <span class="ident">item</span></span>(<span>name: str, help_name: Optional[str] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a single word and binds it to <code>dest</code>.
One of the lowest level building blocks for parsers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>help_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Used for generating help text</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = item(&quot;name&quot;, help_name=&quot;Your first name&quot;)
&gt;&gt;&gt; p.parse_args(&quot;Alice&quot;)
{'name': 'Alice'}
&gt;&gt;&gt; p.parse_args()
usage: name
The following arguments are required: Your first name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L748-L792" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def item(
    name: str,
    help_name: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    Parses a single word and binds it to `dest`.
    One of the lowest level building blocks for parsers.

    Parameters
    ----------
    help_name : Optional[str]
        Used for generating help text

    Examples
    --------

    &gt;&gt;&gt; p = item(&#34;name&#34;, help_name=&#34;Your first name&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; p.parse_args()
    usage: name
    The following arguments are required: Your first name
    &#34;&#34;&#34;

    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        if cs:
            head, *tail = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Sequence([KeyValue(name, head)]),
                        unparsed=Sequence(tail),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {help_name or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.nonpositional"><code class="name flex">
<span>def <span class="ident">nonpositional</span></span>(<span>*parsers: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<p>If alternatives or defaults appear among the arguments to <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>, you will probably want
to add <code>&gt;&gt;</code> followed by <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> (or another parser) after <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>. Otherwise,
the parser will not behave as expected:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # you expect this to set verbose to True, but it doesn't
{'verbose': False, 'quiet': True}
</code></pre>
<p>Why is happening? There are two permutions:</p>
<ul>
<li><code>flag("verbose", default=False) &gt;&gt; flag("quiet")</code> and</li>
<li><code>flag("quiet") &gt;&gt; flag("verbose", default=False)</code></li>
</ul>
<p>In our example, both permutations are actually succeeding. This first succeeds by falling
back to the default, and leaving the last word of the input, <code>--verbose</code>, unparsed.
Either interpretation is valid, and <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> returns one arbitrarily &ndash; just not the one we expected.</p>
<p>Now let's add <code>&gt;&gt; done()</code> to the end:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;quiet&quot;)) &gt;&gt; done()
</code></pre>
<p>This ensures that the first permutation will fail because the leftover <code>--verbose</code> input will
cause the <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> parser to fail:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)
{'quiet': True, 'verbose': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L795-L841" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nonpositional(*parsers: &#34;Parser[Sequence[A]]&#34;) -&gt; &#34;Parser[Sequence[A]]&#34;:
    &#34;&#34;&#34;
    `nonpositional` takes a sequence of parsers as arguments and attempts all permutations of them,
    returning the first permutations that is successful:

    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
    {&#39;verbose&#39;: True, &#39;quiet&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
    {&#39;quiet&#39;: True, &#39;verbose&#39;: True}

    If alternatives or defaults appear among the arguments to `nonpositional`, you will probably want
    to add `&gt;&gt;` followed by `done` (or another parser) after `nonpositional`. Otherwise,
    the parser will not behave as expected:

    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;quiet&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # you expect this to set verbose to True, but it doesn&#39;t
    {&#39;verbose&#39;: False, &#39;quiet&#39;: True}

    Why is happening? There are two permutions:

    - `flag(&#34;verbose&#34;, default=False) &gt;&gt; flag(&#34;quiet&#34;)` and
    - `flag(&#34;quiet&#34;) &gt;&gt; flag(&#34;verbose&#34;, default=False)`

    In our example, both permutations are actually succeeding. This first succeeds by falling
    back to the default, and leaving the last word of the input, `--verbose`, unparsed.
    Either interpretation is valid, and `nonpositional` returns one arbitrarily -- just not the one we expected.

    Now let&#39;s add `&gt;&gt; done()` to the end:
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;quiet&#34;)) &gt;&gt; done()

    This ensures that the first permutation will fail because the leftover `--verbose` input will
    cause the `done` parser to fail:
    &gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)
    {&#39;quiet&#39;: True, &#39;verbose&#39;: True}
    &#34;&#34;&#34;
    if not parsers:
        return empty()

    def get_alternatives():
        for i, head in enumerate(parsers):
            tail = [p for j, p in enumerate(parsers) if j != i]
            yield head &gt;&gt; nonpositional(*tail)

    parser = reduce(operator.or_, get_alternatives())
    sep = &#34; &#34; if len(parsers) &lt;= 3 else &#34;\n&#34;
    return replace(parser, usage=sep.join([p.usage or &#34;&#34; for p in parsers]))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.option"><code class="name flex">
<span>def <span class="ident">option</span></span>(<span>dest: str, flag: Optional[str] = None, default: Any = None, help: Optional[str] = None, short: bool = True, type: Callable[[str], Any] = builtins.str) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses two words, binding the second to the first.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of variable to bind to:</dd>
<dt><strong><code>flag</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The flag to use for the option. If not provided, defaults to <code>--{dest}</code>.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>The default value to bind on failure:</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The help message to display for the option:</dd>
<dt><strong><code>short</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to check for the short form of the flag, which
uses a single dash and the first character of <code>dest</code>, e.g. <code>-c</code> for <code>count</code>.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Callable[[str], Any]</code></dt>
<dd>Use the <code>type</code> argument to convert the input to a different type:</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;).parse_args(&quot;--count&quot;, &quot;1&quot;)
{'count': '1'}
</code></pre>
<p>In this example, you can see that the <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> parameter allows the user to
specify an arbitrary lead string, including one that doesn't start with a dash.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, flag=&quot;ct&quot;).parse_args(&quot;ct&quot;, &quot;1&quot;)
{'count': '1'}
</code></pre>
<p>This example demonstrates the use of the <code>default</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, default=2).parse_args()
{'count': 2}
</code></pre>
<p>Here we specify a help-string using the <code>help</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, help=&quot;The number we should count to&quot;).parse_args(&quot;-h&quot;)
usage: --count COUNT
count: The number we should count to
</code></pre>
<p>This example demonstrates the difference between <code>short=True</code> and <code>short=False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, short=True).parse_args(&quot;-c&quot;, &quot;1&quot;)
{'count': '1'}
&gt;&gt;&gt; option(&quot;count&quot;, short=False).parse_args(&quot;-c&quot;, &quot;1&quot;)
usage: --count COUNT
Expected '--count'. Got '-c'
</code></pre>
<p>As with <a href="https://docs.python.org/3/library/argparse.html#argument-parsing">argparse</a>,
the <code>type</code> argument allows you to convert the input to a different type using a
function that takes a single string argument:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;, type=int).parse_args(&quot;-x&quot;, &quot;1&quot;)  # converts &quot;1&quot; to an int
{'x': 1}
&gt;&gt;&gt; option(&quot;x&quot;, type=lambda x: int(x) + 1).parse_args(&quot;-x&quot;, &quot;1&quot;)
{'x': 2}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L844-L936" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def option(
    dest: str,
    flag: Optional[str] = None,
    default: Any = None,
    help: Optional[str] = None,
    short: bool = True,
    type: Callable[[str], Any] = str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    Parses two words, binding the second to the first.

    Parameters
    ----------
    dest : str
        The name of variable to bind to:

    flag : Optional[str]
        The flag to use for the option. If not provided, defaults to `--{dest}`.

    default : Optional[Any]
        The default value to bind on failure:

    help : Optional[str]
        The help message to display for the option:

    short : bool
        Whether to check for the short form of the flag, which
        uses a single dash and the first character of `dest`, e.g. `-c` for `count`.

    type : Callable[[str], Any]
        Use the `type` argument to convert the input to a different type:

    Examples
    --------

    &gt;&gt;&gt; option(&#34;count&#34;).parse_args(&#34;--count&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}

    In this example, you can see that the `flag` parameter allows the user to
    specify an arbitrary lead string, including one that doesn&#39;t start with a dash.

    &gt;&gt;&gt; option(&#34;count&#34;, flag=&#34;ct&#34;).parse_args(&#34;ct&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}

    This example demonstrates the use of the `default` parameter:

    &gt;&gt;&gt; option(&#34;count&#34;, default=2).parse_args()
    {&#39;count&#39;: 2}

    Here we specify a help-string using the `help` parameter:

    &gt;&gt;&gt; option(&#34;count&#34;, help=&#34;The number we should count to&#34;).parse_args(&#34;-h&#34;)
    usage: --count COUNT
    count: The number we should count to

    This example demonstrates the difference between `short=True` and `short=False`:

    &gt;&gt;&gt; option(&#34;count&#34;, short=True).parse_args(&#34;-c&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}
    &gt;&gt;&gt; option(&#34;count&#34;, short=False).parse_args(&#34;-c&#34;, &#34;1&#34;)
    usage: --count COUNT
    Expected &#39;--count&#39;. Got &#39;-c&#39;

    As with [argparse](https://docs.python.org/3/library/argparse.html#argument-parsing),
    the `type` argument allows you to convert the input to a different type using a
    function that takes a single string argument:

    &gt;&gt;&gt; option(&#34;x&#34;, type=int).parse_args(&#34;-x&#34;, &#34;1&#34;)  # converts &#34;1&#34; to an int
    {&#39;x&#39;: 1}
    &gt;&gt;&gt; option(&#34;x&#34;, type=lambda x: int(x) + 1).parse_args(&#34;-x&#34;, &#34;1&#34;)
    {&#39;x&#39;: 2}
    &#34;&#34;&#34;

    if flag is None:
        _flag = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _flag = flag

    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        parser = equals(_flag) &gt;= (lambda _: item(dest, help_name=dest.upper()))
        return parser.parse(cs)

    parser = Parser(f, usage=None, helps={})
    if type is not str:
        parser = type_(type, parser)
    if short and len(dest) &gt; 1:
        parser2 = option(dest=dest, short=False, flag=f&#34;-{dest[0]}&#34;, default=None)
        parser = parser | parser2
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=f&#34;{_flag} {dest.upper()}&#34;, helps=helps)
    return parser if default is None else parser | defaults(**{dest: default})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.sat"><code class="name flex">
<span>def <span class="ident">sat</span></span>(<span>parser: <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~A], predicate: Callable[[~A], bool], on_fail: Callable[[~A], <a title="dollar_lambda.error.ArgumentError" href="error.html#dollar_lambda.error.ArgumentError">ArgumentError</a>]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~A]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>, applies a predicate to the result and fails if this returns false.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = sat(
...     option(&quot;x&quot;, type=int).many(),
...     lambda kvs: sum([kv.value for kv in kvs]) &gt; 0,
...     lambda x: ArgumentError(f&quot;The values in {list(x)} must sum to more than 0.&quot;),
... )
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-1&quot;, &quot;-x&quot;, &quot;1&quot;)  # fails
usage: [-x X ...]
The values in [KeyValue(key='x', value=-1), KeyValue(key='x', value=1)] must sum to more than 0.
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-1&quot;, &quot;-x&quot;, &quot;2&quot;)  # succeeds
{'x': 2}
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parser</code></strong> :&ensp;<code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A]</code></dt>
<dd>The parser to apply.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Callable[[A], bool]</code></dt>
<dd>The predicate to apply to the result of <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>. <code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat()</a></code> fails if this predicate returns false.</dd>
<dt><strong><code>on_fail</code></strong> :&ensp;<code>Callable[[A], ArgumentError]</code></dt>
<dd>A function producing an ArgumentError to return if the predicate fails.
Takes the output of <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> as an argument.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L966-L1000" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sat(
    parser: Parser[A],
    predicate: Callable[[A], bool],
    on_fail: Callable[[A], ArgumentError],
) -&gt; Parser[A]:
    &#34;&#34;&#34;
    Applies `parser`, applies a predicate to the result and fails if this returns false.

    &gt;&gt;&gt; p = sat(
    ...     option(&#34;x&#34;, type=int).many(),
    ...     lambda kvs: sum([kv.value for kv in kvs]) &gt; 0,
    ...     lambda x: ArgumentError(f&#34;The values in {list(x)} must sum to more than 0.&#34;),
    ... )
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;1&#34;)  # fails
    usage: [-x X ...]
    The values in [KeyValue(key=&#39;x&#39;, value=-1), KeyValue(key=&#39;x&#39;, value=1)] must sum to more than 0.

    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;2&#34;)  # succeeds
    {&#39;x&#39;: 2}

    Parameters
    ----------
    parser : Parser[A]
        The parser to apply.
    predicate : Callable[[A], bool]
        The predicate to apply to the result of `parser`. `sat` fails if this predicate returns false.
    on_fail : Callable[[A], ArgumentError]
        A function producing an ArgumentError to return if the predicate fails.
        Takes the output of `parser` as an argument.
    &#34;&#34;&#34;

    def f(x: A) -&gt; Result[A]:
        return Result(NonemptyList(x) if predicate(x) else on_fail(x))

    return apply(f, parser)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.sat_item"><code class="name flex">
<span>def <span class="ident">sat_item</span></span>(<span>predicate: Callable[[str], bool], on_fail: Callable[[str], <a title="dollar_lambda.error.ArgumentError" href="error.html#dollar_lambda.error.ArgumentError">ArgumentError</a>], name: str) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat()</a></code> that uses <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code> to parse the argument and just applies <code>predicate</code> to the value output by <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = sat_item(lambda x: len(x) == 1, lambda x: ArgumentError(f&quot;'{x}' must have exactly one character.&quot;), &quot;x&quot;)
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)  # succeeds
{'x': 'a'}
&gt;&gt;&gt; p.parse_args(&quot;aa&quot;)  # fails
usage: x
'aa' must have exactly one character.
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Callable[[A], bool]</code></dt>
<dd>The predicate to apply to the result of <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code>. <code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat()</a></code> fails if this predicate returns false.</dd>
<dt><strong><code>on_fail</code></strong> :&ensp;<code>Callable[[A], ArgumentError]</code></dt>
<dd>A function producing an ArgumentError to return if the predicate fails.
Takes the output of <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code> as an argument.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The value to bind the result to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L1003-L1037" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sat_item(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    A wrapper around `sat` that uses `item` to parse the argument and just applies `predicate` to the value output by `item`.

    &gt;&gt;&gt; p = sat_item(lambda x: len(x) == 1, lambda x: ArgumentError(f&#34;&#39;{x}&#39; must have exactly one character.&#34;), &#34;x&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)  # succeeds
    {&#39;x&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;aa&#34;)  # fails
    usage: x
    &#39;aa&#39; must have exactly one character.

    Parameters
    ----------
    predicate : Callable[[A], bool]
        The predicate to apply to the result of `item`. `sat` fails if this predicate returns false.
    on_fail : Callable[[A], ArgumentError]
        A function producing an ArgumentError to return if the predicate fails.
        Takes the output of `item` as an argument.
    name: str
        The value to bind the result to.
    &#34;&#34;&#34;

    def _predicate(parsed: Sequence[KeyValue[str]]) -&gt; bool:
        [kv] = parsed
        return predicate(kv.value)

    def _on_fail(parsed: Sequence[KeyValue[str]]) -&gt; ArgumentError:
        [kv] = parsed
        return on_fail(kv.value)

    return sat(item(name), _predicate, _on_fail)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.type_"><code class="name flex">
<span>def <span class="ident">type_</span></span>(<span>f: Callable[[str], Any], parser: <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code><a title="dollar_lambda.apply" href="#dollar_lambda.apply">apply()</a></code> that simply applies <code>f</code> to the value of the most recently parsed input.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = option(&quot;x&quot;) &gt;&gt; option(&quot;y&quot;)
&gt;&gt;&gt; p = type_(int, p1)
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)  # converts &quot;1&quot; but not &quot;2&quot;
{'y': '2', 'x': 1}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L1056-L1080" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def type_(
    f: Callable[[str], Any], parser: Parser[Sequence[KeyValue[str]]]
) -&gt; Parser[Sequence[KeyValue[Any]]]:
    &#34;&#34;&#34;
    A wrapper around `apply` that simply applies `f` to the value of the most recently parsed input.
    &gt;&gt;&gt; p1 = option(&#34;x&#34;) &gt;&gt; option(&#34;y&#34;)
    &gt;&gt;&gt; p = type_(int, p1)
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)  # converts &#34;1&#34; but not &#34;2&#34;
    {&#39;y&#39;: &#39;2&#39;, &#39;x&#39;: 1}
    &#34;&#34;&#34;

    def g(
        kvs: Sequence[KeyValue[str]],
    ) -&gt; Result[Sequence[KeyValue[Any]]]:
        head, *tail = kvs.get
        try:
            y = f(head.value)
        except Exception as e:
            usage = f&#34;argument {head.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        head = replace(head, value=y)
        return Result.return_(Sequence([*tail, head]))

    p = apply(g, parser)
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.wrap_help"><code class="name flex">
<span>def <span class="ident">wrap_help</span></span>(<span>parser: <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~A]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~A]</span>
</code></dt>
<dd>
<div class="desc"><p>This checks for the <code>--help</code> or <code>-h</code> flag before applying <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>.
If either of the flags is present, returns the usage message for <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = wrap_help(flag(&quot;help&quot;, help=&quot;Print this help message.&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--help&quot;)
usage: --help
help: Print this help message.
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: --help
help: Print this help message.
</code></pre>
<p>We can use <code><a title="dollar_lambda.wrap_help" href="#dollar_lambda.wrap_help">wrap_help()</a></code> to print partial usage messages, e.g. for subcommands:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; subcommand1 = equals(&quot;subcommand1&quot;) &gt;&gt; wrap_help(option(&quot;option1&quot;))
&gt;&gt;&gt; subcommand2 = equals(&quot;subcommand2&quot;) &gt;&gt; wrap_help(option(&quot;option2&quot;))
&gt;&gt;&gt; p = subcommand1 | subcommand2
&gt;&gt;&gt; p.parse_args(&quot;subcommand1&quot;, &quot;-h&quot;)
usage: --option1 OPTION1
&gt;&gt;&gt; p.parse_args(&quot;subcommand2&quot;, &quot;-h&quot;)
usage: --option2 OPTION2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L720-L745" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrap_help(parser: Parser[A]) -&gt; Parser[A]:
    &#34;&#34;&#34;
    This checks for the `--help` or `-h` flag before applying `parser`.
    If either of the flags is present, returns the usage message for `parser`.

    &gt;&gt;&gt; p = wrap_help(flag(&#34;help&#34;, help=&#34;Print this help message.&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;--help&#34;)
    usage: --help
    help: Print this help message.
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --help
    help: Print this help message.

    We can use `wrap_help` to print partial usage messages, e.g. for subcommands:
    &gt;&gt;&gt; subcommand1 = equals(&#34;subcommand1&#34;) &gt;&gt; wrap_help(option(&#34;option1&#34;))
    &gt;&gt;&gt; subcommand2 = equals(&#34;subcommand2&#34;) &gt;&gt; wrap_help(option(&#34;option2&#34;))
    &gt;&gt;&gt; p = subcommand1 | subcommand2
    &gt;&gt;&gt; p.parse_args(&#34;subcommand1&#34;, &#34;-h&#34;)
    usage: --option1 OPTION1
    &gt;&gt;&gt; p.parse_args(&#34;subcommand2&#34;, &#34;-h&#34;)
    usage: --option2 OPTION2
    &#34;&#34;&#34;
    _help_parser: Parser[Sequence[A]] = help_parser(parser.usage, Sequence([]))

    p = _help_parser &gt;= (lambda _: parser)
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dollar_lambda.Args"><code class="flex name class">
<span>class <span class="ident">Args</span></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> is sugar for the <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> function and removes much of the boilerplate
from defining parsers with many arguments.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     verbose: bool
...     count: int
&gt;&gt;&gt; MyArgs.parse_args(&quot;--verbose&quot;, &quot;--count&quot;, &quot;1&quot;)
{'verbose': True, 'count': 1}
</code></pre>
<p><code>MyArgs</code> will accept these arguments in any order:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--count&quot;, &quot;1&quot;, &quot;--verbose&quot;)
{'count': 1, 'verbose': True}
</code></pre>
<p>Note that when the default value of an argument is <code>True</code>, <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> will, by default
add <code>--no-</code> to the front of the flag (while still assigning the value to the original key):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     tests: bool = True
&gt;&gt;&gt; MyArgs.parse_args(&quot;--no-tests&quot;)
{'tests': False}
&gt;&gt;&gt; MyArgs.parse_args()
{'tests': True}
</code></pre>
<p>To suppress this behavior, set <code>flip_bools=False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--tests&quot;, flip_bools=False)
{'tests': False}
</code></pre>
<p>By using the <code><a title="dollar_lambda.Args.parser" href="#dollar_lambda.Args.parser">Args.parser()</a></code> method, <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> can take advantage of all the same
combinators as other parsers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument
&gt;&gt;&gt; p = MyArgs.parser()
&gt;&gt;&gt; p1 = p &gt;&gt; argument(&quot;a&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;--no-tests&quot;, &quot;hello&quot;)
{'tests': False, 'a': 'hello'}
</code></pre>
<p>To supply other metadata, like <code>help</code> text and more complex <code>type</code> converters, use <code><a title="dollar_lambda.field" href="#dollar_lambda.field">field()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     n: int = field(default=0, help=&quot;a number to increment&quot;, type=lambda x: 1 + int(x))
&gt;&gt;&gt; MyArgs.parse_args(&quot;-n&quot;, &quot;1&quot;)
{'n': 2}
&gt;&gt;&gt; MyArgs.parse_args()
{'n': 1}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/args.py#L107-L196" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class Args:
    &#34;&#34;&#34;
    `Args` is sugar for the `nonpositional` function and removes much of the boilerplate
    from defining parsers with many arguments.

    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     verbose: bool
    ...     count: int
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--verbose&#34;, &#34;--count&#34;, &#34;1&#34;)
    {&#39;verbose&#39;: True, &#39;count&#39;: 1}

    `MyArgs` will accept these arguments in any order:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--count&#34;, &#34;1&#34;, &#34;--verbose&#34;)
    {&#39;count&#39;: 1, &#39;verbose&#39;: True}

    Note that when the default value of an argument is `True`, `Args` will, by default
    add `--no-` to the front of the flag (while still assigning the value to the original key):
    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     tests: bool = True
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--no-tests&#34;)
    {&#39;tests&#39;: False}
    &gt;&gt;&gt; MyArgs.parse_args()
    {&#39;tests&#39;: True}

    To suppress this behavior, set `flip_bools=False`:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--tests&#34;, flip_bools=False)
    {&#39;tests&#39;: False}

    By using the `Args.parser()` method, `Args` can take advantage of all the same
    combinators as other parsers:

    &gt;&gt;&gt; from dollar_lambda import argument
    &gt;&gt;&gt; p = MyArgs.parser()
    &gt;&gt;&gt; p1 = p &gt;&gt; argument(&#34;a&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;--no-tests&#34;, &#34;hello&#34;)
    {&#39;tests&#39;: False, &#39;a&#39;: &#39;hello&#39;}

    To supply other metadata, like `help` text and more complex `type` converters, use `field`:
    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     n: int = field(default=0, help=&#34;a number to increment&#34;, type=lambda x: 1 + int(x))
    &gt;&gt;&gt; MyArgs.parse_args(&#34;-n&#34;, &#34;1&#34;)
    {&#39;n&#39;: 2}
    &gt;&gt;&gt; MyArgs.parse_args()
    {&#39;n&#39;: 1}
    &#34;&#34;&#34;

    @classmethod
    def parser(cls, flip_bools: bool = True) -&gt; Parser[Sequence[KeyValue[Any]]]:
        &#34;&#34;&#34;
        Returns a parser for the dataclass.
        Converts each field to a parser (`option` or `flag` depending on its type).
        Combines these parsers using `nonpositional`.

        Parameters
        ----------
        flip_bools: bool
             Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

        Examples
        --------
        &gt;&gt;&gt; @dataclass
        ... class MyArgs(Args):
        ...     tests: bool = True

        Note the leading `--no-`:
        &gt;&gt;&gt; MyArgs.parse_args(&#34;--no-tests&#34;)
        {&#39;tests&#39;: False}
        &gt;&gt;&gt; MyArgs.parse_args()
        {&#39;tests&#39;: True}

        To suppress this behavior, set `flip_bools=False`:
        &gt;&gt;&gt; MyArgs.parse_args(&#34;--tests&#34;, flip_bools=False)
        {&#39;tests&#39;: False}
        &#34;&#34;&#34;
        return _ArgsField.nonpositional(
            *[_ArgsField.parse(field) for field in fields(cls)], flip_bools=flip_bools
        )

    @classmethod
    def parse_args(
        cls, *args, flip_bools: bool = True
    ) -&gt; &#34;typing.Sequence[KeyValueTuple] | typing.Dict[str, Any]&#34;:
        &#34;&#34;&#34;
        Parses the arguments and returns a dictionary of the parsed values.
        &#34;&#34;&#34;
        return (cls.parser(flip_bools=flip_bools) &gt;&gt; done()).parse_args(*args)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="dollar_lambda.Args.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>*args, flip_bools: bool = True) <span style="white-space: nowrap;">-></span> Union[Sequence[<a title="dollar_lambda.key_value.KeyValueTuple" href="key_value.html#dollar_lambda.key_value.KeyValueTuple">KeyValueTuple</a>], Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the arguments and returns a dictionary of the parsed values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/args.py#L189-L196" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def parse_args(
    cls, *args, flip_bools: bool = True
) -&gt; &#34;typing.Sequence[KeyValueTuple] | typing.Dict[str, Any]&#34;:
    &#34;&#34;&#34;
    Parses the arguments and returns a dictionary of the parsed values.
    &#34;&#34;&#34;
    return (cls.parser(flip_bools=flip_bools) &gt;&gt; done()).parse_args(*args)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Args.parser"><code class="name flex">
<span>def <span class="ident">parser</span></span>(<span>flip_bools: bool = True) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a parser for the dataclass.
Converts each field to a parser (<code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> or <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> depending on its type).
Combines these parsers using <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to add <code>--no-&lt;argument&gt;</code> before arguments that default to <code>True</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     tests: bool = True
</code></pre>
<p>Note the leading <code>--no-</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--no-tests&quot;)
{'tests': False}
&gt;&gt;&gt; MyArgs.parse_args()
{'tests': True}
</code></pre>
<p>To suppress this behavior, set <code>flip_bools=False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--tests&quot;, flip_bools=False)
{'tests': False}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/args.py#L157-L187" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def parser(cls, flip_bools: bool = True) -&gt; Parser[Sequence[KeyValue[Any]]]:
    &#34;&#34;&#34;
    Returns a parser for the dataclass.
    Converts each field to a parser (`option` or `flag` depending on its type).
    Combines these parsers using `nonpositional`.

    Parameters
    ----------
    flip_bools: bool
         Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

    Examples
    --------
    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     tests: bool = True

    Note the leading `--no-`:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--no-tests&#34;)
    {&#39;tests&#39;: False}
    &gt;&gt;&gt; MyArgs.parse_args()
    {&#39;tests&#39;: True}

    To suppress this behavior, set `flip_bools=False`:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--tests&#34;, flip_bools=False)
    {&#39;tests&#39;: False}
    &#34;&#34;&#34;
    return _ArgsField.nonpositional(
        *[_ArgsField.parse(field) for field in fields(cls)], flip_bools=flip_bools
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.CommandTree"><code class="flex name class">
<span>class <span class="ident">CommandTree</span></span>
</code></dt>
<dd>
<div class="desc"><p>Allows parsers to dynamically dispatch their results based on the input. For usage details,
see the <a href="#commandtree-tutorial"><code>CommandTree</code> tutorial</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/decorators.py#L246-L475" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class CommandTree:
    &#34;&#34;&#34;
    Allows parsers to dynamically dispatch their results based on the input. For usage details,
    see the [`CommandTree` tutorial](#commandtree-tutorial).
    &#34;&#34;&#34;

    _children: List[_Node] = field(default_factory=list)
    _required: bool = False

    def command(
        self,
        flip_bools: bool = True,
        help: Optional[Dict[str, str]] = None,
        required: bool = True,
        strings: Optional[Dict[str, str]] = None,
        types: Optional[Dict[str, Callable[[str], Any]]] = None,
    ) -&gt; Callable:
        &#34;&#34;&#34;
        A decorator for adding a function as a child of this tree.

        Parameters
        ----------

        flip_bools: bool
            Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

        help: dict
            A dictionary of help strings for the arguments.

        required: bool
            If any sibling child functions are not required, then the user will be
            able to invoke the parent function by not selecting any of the child functions.

        strings: dict
            A dictionary of strings to use for the arguments.

        types: dict
            A dictionary of types to use for the arguments.

        Examples
        --------
        With `flip_bools` set to `True`:
        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(flip_bools=True)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: --no-b
        b: (default: True)

        With `flip_bools` set to `False`:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(flip_bools=False)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: -b
        b: (default: True)


        Here is an example of how the `required` argument works:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command()
        ... def f1(a: int):
        ...     # this function can be called because one of the children (f2) is not required
        ...     return dict(f1=dict(a=a))
        ...
        &gt;&gt;&gt; @f1.command(required=False)
        ... def f2(a:int, b: bool):
        ...     return dict(f2=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.command()
        ... def f3(a: int, c: str):
        ...     return dict(f3=dict(c=c))

        Now we invoke `tree` without calling `f2` or `f3`:
        &gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;)
        {&#39;f1&#39;: {&#39;a&#39;: 1}}
        &#34;&#34;&#34;
        return self._decorator(
            flip_bools=flip_bools,
            help=help,
            required=required,
            strings=strings,
            subcommand=False,
            types=types,
        )

    def _decorator(self, **kwargs) -&gt; Callable:
        def wrapper(function: Callable):
            tree = CommandTree()
            self._children.append(_Node(function=function, tree=tree, **kwargs))
            return tree

        return wrapper

    def _parser(self, *variables: str) -&gt; Parser[_FunctionPair[KeyValue[Any]]]:
        if not self._children:
            raise RuntimeError(
                &#34;You must assign children to a CommandTree object in order to use it as a parser.&#34;
            )

        def get_alternatives() -&gt; Iterator[Parser[_FunctionPair[KeyValue[Any]]]]:
            for child in self._children:
                parser: Parser[_FunctionPair[KeyValue[Any]]] = child.parser(*variables)
                if child.tree is not None and child.tree._children:
                    parser = cast(
                        Parser[_FunctionPair[KeyValue[Any]]],
                        parser
                        &gt;&gt; child.tree._parser(*variables, *child.variable_names()),
                    )
                yield parser

        return wrap_help(reduce(operator.or_, get_alternatives()))

    def __call__(self, *args: str) -&gt; Any:
        &#34;&#34;&#34;
        Run the parser associated with this tree and execute the
        function associated with a succeeding parser.

        If `args` is empty, uses `sys.argv[1:]`.
        &#34;&#34;&#34;
        _args = args if args or parser_mod.TESTING else sys.argv[1:]
        p = self._parser() &gt;&gt; done()
        result = p.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            p.handle_error(result)
            if parser_mod.TESTING:
                return  # type: ignore[return-value]
            else:
                exit()
        assert isinstance(result, NonemptyList)
        pair = cast(_FunctionPair, result.head.parsed)
        return pair.function(**{kv.key: kv.value for kv in pair.get})

    def subcommand(
        self,
        flip_bools: bool = True,
        help: Optional[Dict[str, str]] = None,
        required: bool = False,
        strings: Optional[Dict[str, str]] = None,
        types: Optional[Dict[str, Callable[[str], Any]]] = None,
    ) -&gt; Callable:
        &#34;&#34;&#34;
        A decorator for adding a function as a child of this tree.
        As a subcommand, the function&#39;s name must be invoked on the command
        line for the function to be called.

        Parameters
        ----------

        flip_bools: bool
            Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

        help: dict
            A dictionary of help strings for the arguments.

        required: bool
            If any sibling child functions are not required, then the user will be
            able to invoke the parent function by not selecting any of the child functions.

        strings: dict
            A dictionary of strings to use for the arguments.

        types: dict
            A dictionary of types to use for the arguments.

        Examples
        --------
        With `flip_bools` set to `True`:
        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(flip_bools=True)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 --no-b
        b: (default: True)

        With `flip_bools` set to `False`:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(flip_bools=False)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 -b
        b: (default: True)


        Here is an example of how the `required` argument works:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command()
        ... def f1(a: int):
        ...     # this function can be called because one of the children (f2) is not required
        ...     return dict(f1=dict(a=a))
        ...
        &gt;&gt;&gt; @f1.subcommand(required=False)
        ... def f2(a:int, b: bool):
        ...     return dict(f2=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.subcommand()
        ... def f3(a: int, c: str):
        ...     return dict(f3=dict(c=c))

        Now we invoke `tree` without calling `f2` or `f3`:
        &gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;)
        {&#39;f1&#39;: {&#39;a&#39;: 1}}
        &#34;&#34;&#34;
        return self._decorator(
            flip_bools=flip_bools,
            help=help,
            required=required,
            types=types,
            strings=strings,
            subcommand=True,
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.CommandTree.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self, flip_bools: bool = True, help: Optional[Dict[str, str]] = None, required: bool = True, strings: Optional[Dict[str, str]] = None, types: Optional[Dict[str, Callable[[str], Any]]] = None) <span style="white-space: nowrap;">-></span> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>A decorator for adding a function as a child of this tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to add <code>--no-&lt;argument&gt;</code> before arguments that default to <code>True</code>.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of help strings for the arguments.</dd>
<dt><strong><code>required</code></strong> :&ensp;<code>bool</code></dt>
<dd>If any sibling child functions are not required, then the user will be
able to invoke the parent function by not selecting any of the child functions.</dd>
<dt><strong><code>strings</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of strings to use for the arguments.</dd>
<dt><strong><code>types</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of types to use for the arguments.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>With <code>flip_bools</code> set to <code>True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(flip_bools=True)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: --no-b
b: (default: True)
</code></pre>
<p>With <code>flip_bools</code> set to <code>False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(flip_bools=False)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -b
b: (default: True)
</code></pre>
<p>Here is an example of how the <code>required</code> argument works:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     # this function can be called because one of the children (f2) is not required
...     return dict(f1=dict(a=a))
...
&gt;&gt;&gt; @f1.command(required=False)
... def f2(a:int, b: bool):
...     return dict(f2=dict(b=b))
...
&gt;&gt;&gt; @f1.command()
... def f3(a: int, c: str):
...     return dict(f3=dict(c=c))
</code></pre>
<p>Now we invoke <code>tree</code> without calling <code>f2</code> or <code>f3</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/decorators.py#L256-L340" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def command(
    self,
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    required: bool = True,
    strings: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable:
    &#34;&#34;&#34;
    A decorator for adding a function as a child of this tree.

    Parameters
    ----------

    flip_bools: bool
        Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

    help: dict
        A dictionary of help strings for the arguments.

    required: bool
        If any sibling child functions are not required, then the user will be
        able to invoke the parent function by not selecting any of the child functions.

    strings: dict
        A dictionary of strings to use for the arguments.

    types: dict
        A dictionary of types to use for the arguments.

    Examples
    --------
    With `flip_bools` set to `True`:
    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command(flip_bools=True)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: --no-b
    b: (default: True)

    With `flip_bools` set to `False`:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command(flip_bools=False)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: -b
    b: (default: True)


    Here is an example of how the `required` argument works:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command()
    ... def f1(a: int):
    ...     # this function can be called because one of the children (f2) is not required
    ...     return dict(f1=dict(a=a))
    ...
    &gt;&gt;&gt; @f1.command(required=False)
    ... def f2(a:int, b: bool):
    ...     return dict(f2=dict(b=b))
    ...
    &gt;&gt;&gt; @f1.command()
    ... def f3(a: int, c: str):
    ...     return dict(f3=dict(c=c))

    Now we invoke `tree` without calling `f2` or `f3`:
    &gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;)
    {&#39;f1&#39;: {&#39;a&#39;: 1}}
    &#34;&#34;&#34;
    return self._decorator(
        flip_bools=flip_bools,
        help=help,
        required=required,
        strings=strings,
        subcommand=False,
        types=types,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.CommandTree.subcommand"><code class="name flex">
<span>def <span class="ident">subcommand</span></span>(<span>self, flip_bools: bool = True, help: Optional[Dict[str, str]] = None, required: bool = False, strings: Optional[Dict[str, str]] = None, types: Optional[Dict[str, Callable[[str], Any]]] = None) <span style="white-space: nowrap;">-></span> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>A decorator for adding a function as a child of this tree.
As a subcommand, the function's name must be invoked on the command
line for the function to be called.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to add <code>--no-&lt;argument&gt;</code> before arguments that default to <code>True</code>.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of help strings for the arguments.</dd>
<dt><strong><code>required</code></strong> :&ensp;<code>bool</code></dt>
<dd>If any sibling child functions are not required, then the user will be
able to invoke the parent function by not selecting any of the child functions.</dd>
<dt><strong><code>strings</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of strings to use for the arguments.</dd>
<dt><strong><code>types</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of types to use for the arguments.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>With <code>flip_bools</code> set to <code>True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.subcommand(flip_bools=True)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: f1 --no-b
b: (default: True)
</code></pre>
<p>With <code>flip_bools</code> set to <code>False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.subcommand(flip_bools=False)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: f1 -b
b: (default: True)
</code></pre>
<p>Here is an example of how the <code>required</code> argument works:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     # this function can be called because one of the children (f2) is not required
...     return dict(f1=dict(a=a))
...
&gt;&gt;&gt; @f1.subcommand(required=False)
... def f2(a:int, b: bool):
...     return dict(f2=dict(b=b))
...
&gt;&gt;&gt; @f1.subcommand()
... def f3(a: int, c: str):
...     return dict(f3=dict(c=c))
</code></pre>
<p>Now we invoke <code>tree</code> without calling <code>f2</code> or <code>f3</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/decorators.py#L389-L475" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def subcommand(
    self,
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    required: bool = False,
    strings: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable:
    &#34;&#34;&#34;
    A decorator for adding a function as a child of this tree.
    As a subcommand, the function&#39;s name must be invoked on the command
    line for the function to be called.

    Parameters
    ----------

    flip_bools: bool
        Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

    help: dict
        A dictionary of help strings for the arguments.

    required: bool
        If any sibling child functions are not required, then the user will be
        able to invoke the parent function by not selecting any of the child functions.

    strings: dict
        A dictionary of strings to use for the arguments.

    types: dict
        A dictionary of types to use for the arguments.

    Examples
    --------
    With `flip_bools` set to `True`:
    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.subcommand(flip_bools=True)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: f1 --no-b
    b: (default: True)

    With `flip_bools` set to `False`:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.subcommand(flip_bools=False)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: f1 -b
    b: (default: True)


    Here is an example of how the `required` argument works:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command()
    ... def f1(a: int):
    ...     # this function can be called because one of the children (f2) is not required
    ...     return dict(f1=dict(a=a))
    ...
    &gt;&gt;&gt; @f1.subcommand(required=False)
    ... def f2(a:int, b: bool):
    ...     return dict(f2=dict(b=b))
    ...
    &gt;&gt;&gt; @f1.subcommand()
    ... def f3(a: int, c: str):
    ...     return dict(f3=dict(c=c))

    Now we invoke `tree` without calling `f2` or `f3`:
    &gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;)
    {&#39;f1&#39;: {&#39;a&#39;: 1}}
    &#34;&#34;&#34;
    return self._decorator(
        flip_bools=flip_bools,
        help=help,
        required=required,
        types=types,
        strings=strings,
        subcommand=True,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.Parser"><code class="flex name class">
<span>class <span class="ident">Parser</span></span>
<span>(</span><span>f: Callable[[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[str]], <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="parser.html#dollar_lambda.parser.Parse">Parse</a>[+A_co]]], usage: Optional[str], helps: Dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Main class powering the argument parser.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L75-L422" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class Parser(MonadPlus[A_co]):
    &#34;&#34;&#34;
    Main class powering the argument parser.
    &#34;&#34;&#34;

    __pdoc__[&#34;Parser.__add__&#34;] = True
    __pdoc__[&#34;Parser.__or__&#34;] = True
    __pdoc__[&#34;Parser.__rshift__&#34;] = True
    __pdoc__[&#34;Parser.__ge__&#34;] = True

    f: Callable[[Sequence[str]], Result[Parse[A_co]]]
    usage: Optional[str]
    helps: Dict[str, str]

    def __add__(
        self: &#34;Parser[Sequence[A]]&#34;, other: &#34;Parser[Sequence[B]]&#34;
    ) -&gt; &#34;Parser[Sequence[A | B]]&#34;:
        &#34;&#34;&#34;
        Parse two arguments in either order.
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
        {&#39;verbose&#39;: True, &#39;debug&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
        {&#39;debug&#39;: True, &#39;verbose&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
        usage: --verbose --debug
        Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

        Note that if more than two arguments are chained together with `+`, some combinations will not parse:
        &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
        {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
        usage: -a -b -c
        Expected &#39;-b&#39;. Got &#39;-c&#39;

        This makes more sense when one supplies the implicit parentheses:
        &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

        In order to chain together more than two arguments, use `nonpositional`:
        &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
        {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
        &#34;&#34;&#34;
        p = (self &gt;&gt; other) | (other &gt;&gt; self)
        usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
        return replace(p, usage=usage)

    def __or__(  # type: ignore[override]
        self: &#34;Parser[A_co]&#34;,
        other: &#34;Parser[B]&#34;,
    ) -&gt; &#34;Parser[A_co | B]&#34;:
        &#34;&#34;&#34;
        Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

        &gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
        &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
        {&#39;verbose&#39;: True}

        Note that when both arguments are supplied, this will only parse the first:
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        {&#39;verbose&#39;: True}

        If you want this to fail, use `&gt;&gt;` (`Parser.__rshift__`) with `done()` or another parser:
        &gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        usage: [--option OPTION | --verbose]
        Unrecognized argument: --option
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[&#34;A_co | B&#34;]]:
            return self.parse(cs) | other.parse(cs)

        return Parser(
            f,
            usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
            helps={**self.helps, **other.helps},
        )

    def __rshift__(
        self: &#34;Parser[Sequence[A]]&#34;, p: &#34;Parser[Sequence[B]]&#34;
    ) -&gt; &#34;Parser[Sequence[A | B]]&#34;:
        &#34;&#34;&#34;
        This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
        gets handed off to the second parser. If either parser fails, the whole thing fails.

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        usage: first second
        The following arguments are required: second
        &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
        usage: first second
        The following arguments are required: second
        &#34;&#34;&#34;
        # def f(p1: Sequence[D]) -&gt; Parser[Parse[Sequence[D | B]]]:
        #     def g(p2: Sequence[B]) -&gt; Parser[Sequence[D | B]]:
        #         return Parser.return_(p1 + p2)

        #     return p &gt;= g

        # return self &gt;= f
        parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
        return replace(
            parser,
            usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False),
            helps={**self.helps, **p.helps},
        )

    def __ge__(self, f: Callable[[A_co], Monad[B]]) -&gt; &#34;Parser[B]&#34;:
        return self.bind(f)

    def bind(self, f: Callable[[A_co], Monad[B]]) -&gt; &#34;Parser[B]&#34;:
        &#34;&#34;&#34;
        Returns a new parser that

        1. applies `self`;
        2. if this succeeds, applies `f` to the parsed component of the result.

        `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
        avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
        `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

        Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
        and we typically prefer using the infix operator to the spelled out method.

        Let&#39;s start with our simplest parser, `argument`:
        &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

        Now let&#39;s use the `equals` parser to write a function that takes the output of `p1` and fails unless
        the next argument is the same as the first:
        &gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Parser[Sequence[KeyValue[str]]]:
        ...     [kv] = kvs
        ...     return equals(kv.value)

        &gt;&gt;&gt; p = p1 &gt;= f
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
        {&#39;a&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        Expected &#39;a&#39;. Got &#39;b&#39;
        &#34;&#34;&#34;

        def h(parse: Parse[A_co]) -&gt; Result[Parse[B]]:
            y = f(parse.parsed)
            assert isinstance(y, Parser), y
            return y.parse(parse.unparsed)

        def g(cs: Sequence[str]) -&gt; Result[Parse[B]]:
            return self.parse(cs) &gt;= h

        return Parser(g, usage=None, helps=self.helps)

    @classmethod
    def empty(cls: Type[&#34;Parser[Sequence[A]]&#34;]) -&gt; &#34;Parser[Sequence[A]]&#34;:
        &#34;&#34;&#34;
        Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
        &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
        {}
        &#34;&#34;&#34;
        return cls.return_(Sequence([]))

    def handle_error(self, error: ArgumentError) -&gt; None:
        def print_usage(usage: str):
            print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in usage else &#34; &#34;)
            if &#34;\n&#34; in usage:
                usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in usage.split(&#34;\n&#34;)])
            print(usage)
            if self.helps:
                for k, v in self.helps.items():
                    print(f&#34;{k}: {v}&#34;)

        if isinstance(error, HelpError):
            print_usage(error.usage)
        else:
            if self.usage:
                print_usage(self.usage)
            if error.usage:
                print(error.usage)

    def many(self: &#34;Parser[Sequence[A]]&#34;) -&gt; &#34;Parser[Sequence[A]]&#34;:
        &#34;&#34;&#34;
        Applies `self` zero or more times (like `*` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(return_dict=False)
        []
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, return_dict=False)
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;)]
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)  # return_dict=False allows duplicate keys
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

        Note that if `self` contains `Parser.__or__`, the arguments can be
        heterogenous:
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
        &gt;&gt;&gt; p = p.many()
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, return_dict=False) # mix --verbose and --quiet
        [(&#39;verbose&#39;, True), (&#39;quiet&#39;, True)]
        &#34;&#34;&#34;
        p = self.many1() | self.empty()
        return replace(p, usage=f&#34;[{self.usage} ...]&#34;)

    def many1(self: &#34;Parser[Sequence[A]]&#34;) -&gt; &#34;Parser[Sequence[A]]&#34;:
        &#34;&#34;&#34;
        Applies `self` one or more times (like `+` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
        {&#39;1-or-more&#39;: &#39;1&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, return_dict=False)  # return_dict=False allows duplicate keys
        [(&#39;1-or-more&#39;, &#39;1&#39;), (&#39;1-or-more&#39;, &#39;2&#39;)]
        &gt;&gt;&gt; p.parse_args()
        usage: 1-or-more [1-or-more ...]
        The following arguments are required: 1-or-more
        &#34;&#34;&#34;

        def g() -&gt; Generator[&#34;Parser[Sequence[A]]&#34;, Sequence[A], None]:
            # noinspection PyTypeChecker
            r1: Sequence[A] = yield self
            # noinspection PyTypeChecker
            r2: Sequence[A] = yield self.many()
            yield Parser[Sequence[A]].return_(r1 + r2)

        @lru_cache()
        def f(cs: tuple):
            y = Parser.do(g)
            assert isinstance(y, Parser), y
            return y.parse(Sequence(list(cs)))

        return Parser(
            lambda cs: f(tuple(cs)),
            usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
            helps=self.helps,
        )

    def optional(self: &#34;Parser[Sequence[A]]&#34;) -&gt; &#34;Parser[Sequence[A]]&#34;:
        &#34;&#34;&#34;
        Allows arguments to be optional:
        &gt;&gt;&gt; p1 = flag(&#34;optional&#34;) &gt;&gt; done()
        &gt;&gt;&gt; p = p1.optional()
        &gt;&gt;&gt; p.parse_args(&#34;--optional&#34;)
        {&#39;optional&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--misspelled&#34;)  # succeeds with no output
        {}
        &gt;&gt;&gt; p1.parse_args(&#34;--misspelled&#34;)
        usage: --optional
        Expected &#39;--optional&#39;. Got &#39;--misspelled&#39;
        &#34;&#34;&#34;
        return self | self.empty()

    def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        &#34;&#34;&#34;
        Applies the parser to the input sequence `cs`.
        &#34;&#34;&#34;
        return self.f(cs)

    def parse_args(
        self: &#34;Parser[Sequence[KeyValue]]&#34;,
        *args: str,
        return_dict: bool = True,
        check_help: bool = True,
    ) -&gt; &#34;typing.Sequence[KeyValueTuple] | Dict[str, Any]&#34;:
        &#34;&#34;&#34;
        The main way the user extracts parsed results from the parser.

        Parameters
        ----------
        args : str
            A sequence of strings to parse. If empty, defaults to `sys.argv[1:]`.
        return_dict : bool
            Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
            The tuples are `KeyValueTuple` namedtuples, with fields `key` and `value`.
        check_help : bool
            Before running the parser, checks if the input string is `--help` or `-h`.
            If it is, returns the usage message.

        Examples
        --------

        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
        usage: a
        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
        usage: a
        &#34;&#34;&#34;
        _args = args if args or TESTING else sys.argv[1:]
        if check_help:
            return wrap_help(self).parse_args(
                *_args, return_dict=return_dict, check_help=False
            )
        result = self.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            self.handle_error(result)
            if TESTING:
                return  # type: ignore[return-value]
            else:
                exit()

        kvs = result.head.parsed
        if return_dict:
            return {kv.key: kv.value for kv in kvs}
        return [KeyValueTuple(**asdict(kv)) for kv in kvs]

    @classmethod
    def return_(cls, a: A_co) -&gt; &#34;Parser[A_co]&#34;:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
        and always returns `a` as the result. For the most part, the user will not use
        this method unless building custom parsers.

        &gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
        &gt;&gt;&gt; Parser.return_(([KeyValue(&#34;some-key&#34;, &#34;some-value&#34;)])).parse_args()
        {&#39;some-key&#39;: &#39;some-value&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
            return Result.return_(Parse(a, cs))

        return Parser(f, usage=None, helps={})

    @classmethod
    def zero(cls, error: Optional[ArgumentError] = None) -&gt; &#34;Parser[A_co]&#34;:
        &#34;&#34;&#34;
        This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

        Parameters
        ----------
        error : Optional[ArgumentError]
            Customize the error returned by `zero`.

        &gt;&gt;&gt; Parser.zero().parse_args()
        zero
        &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
        zero
        &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
        This is a test.
        &#34;&#34;&#34;
        return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pytypeclass.monoid.MonadPlus</li>
<li>pytypeclass.monad.Monad</li>
<li>pytypeclass.monoid.Monoid</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.Parser.f"><code class="name">var <span class="ident">f</span> : Callable[[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[str]], <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="parser.html#dollar_lambda.parser.Parse">Parse</a>[+A_co]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.Parser.helps"><code class="name">var <span class="ident">helps</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.Parser.usage"><code class="name">var <span class="ident">usage</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dollar_lambda.Parser.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Always returns {}, no matter the input. Mostly useful for use in <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; empty().parse_args(&quot;any&quot;, &quot;arguments&quot;)
{}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L234-L241" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def empty(cls: Type[&#34;Parser[Sequence[A]]&#34;]) -&gt; &#34;Parser[Sequence[A]]&#34;:
    &#34;&#34;&#34;
    Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
    &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
    {}
    &#34;&#34;&#34;
    return cls.return_(Sequence([]))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.return_"><code class="name flex">
<span>def <span class="ident">return_</span></span>(<span>a: +A_co) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"><p>This method is required to make <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. It consumes none of the input
and always returns <code>a</code> as the result. For the most part, the user will not use
this method unless building custom parsers.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
&gt;&gt;&gt; Parser.return_(([KeyValue(&quot;some-key&quot;, &quot;some-value&quot;)])).parse_args()
{'some-key': 'some-value'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L387-L403" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def return_(cls, a: A_co) -&gt; &#34;Parser[A_co]&#34;:  # type: ignore[misc]
    # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
    &#34;&#34;&#34;
    This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
    and always returns `a` as the result. For the most part, the user will not use
    this method unless building custom parsers.

    &gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
    &gt;&gt;&gt; Parser.return_(([KeyValue(&#34;some-key&#34;, &#34;some-value&#34;)])).parse_args()
    {&#39;some-key&#39;: &#39;some-value&#39;}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        return Result.return_(Parse(a, cs))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.zero"><code class="name flex">
<span>def <span class="ident">zero</span></span>(<span>error: Optional[<a title="dollar_lambda.error.ArgumentError" href="error.html#dollar_lambda.error.ArgumentError">ArgumentError</a>] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"><p>This parser always fails. This method is necessary to make <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13"><code>Monoid</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>error</code></strong> :&ensp;<code>Optional[ArgumentError]</code></dt>
<dd>Customize the error returned by <code>zero</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.zero().parse_args()
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero().parse_args(&quot;a&quot;)
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero(error=ArgumentError(&quot;This is a test.&quot;)).parse_args(&quot;a&quot;)
This is a test.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L405-L422" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def zero(cls, error: Optional[ArgumentError] = None) -&gt; &#34;Parser[A_co]&#34;:
    &#34;&#34;&#34;
    This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

    Parameters
    ----------
    error : Optional[ArgumentError]
        Customize the error returned by `zero`.

    &gt;&gt;&gt; Parser.zero().parse_args()
    zero
    &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
    zero
    &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
    This is a test.
    &#34;&#34;&#34;
    return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.Parser.__add__"><code class="name flex">
<span>def <span class="ident">__add__</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]], other: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[B]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[typing.Union[~A, ~B]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse two arguments in either order.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;debug&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--debug&quot;)
{'verbose': True, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;, &quot;--verbose&quot;)
{'debug': True, 'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;)
usage: --verbose --debug
Expected '--verbose'. Got '--debug'
</code></pre>
<p>Note that if more than two arguments are chained together with <code>+</code>, some combinations will not parse:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;a&quot;) + flag(&quot;b&quot;) + flag(&quot;c&quot;)
&gt;&gt;&gt; p.parse_args(&quot;-c&quot;, &quot;-a&quot;, &quot;-b&quot;)   # this works
{'c': True, 'a': True, 'b': True}
&gt;&gt;&gt; p.parse_args(&quot;-a&quot;, &quot;-c&quot;, &quot;-b&quot;)   # this doesn't
usage: -a -b -c
Expected '-b'. Got '-c'
</code></pre>
<p>This makes more sense when one supplies the implicit parentheses:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (flag(&quot;a&quot;) + flag(&quot;b&quot;)) + flag(&quot;c&quot;)
</code></pre>
<p>In order to chain together more than two arguments, use <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;a&quot;), flag(&quot;b&quot;), flag(&quot;c&quot;))
&gt;&gt;&gt; p.parse_args(&quot;-a&quot;, &quot;-c&quot;, &quot;-b&quot;)
{'a': True, 'c': True, 'b': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L90-L122" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __add__(
    self: &#34;Parser[Sequence[A]]&#34;, other: &#34;Parser[Sequence[B]]&#34;
) -&gt; &#34;Parser[Sequence[A | B]]&#34;:
    &#34;&#34;&#34;
    Parse two arguments in either order.
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    usage: --verbose --debug
    Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

    Note that if more than two arguments are chained together with `+`, some combinations will not parse:
    &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
    {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
    usage: -a -b -c
    Expected &#39;-b&#39;. Got &#39;-c&#39;

    This makes more sense when one supplies the implicit parentheses:
    &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

    In order to chain together more than two arguments, use `nonpositional`:
    &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
    {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
    &#34;&#34;&#34;
    p = (self &gt;&gt; other) | (other &gt;&gt; self)
    usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
    return replace(p, usage=usage)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__ge__"><code class="name flex">
<span>def <span class="ident">__ge__</span></span>(<span>self, f: Callable[[+A_co], pytypeclass.monad.Monad[~B]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~B]</span>
</code></dt>
<dd>
<div class="desc"><p>Return self&gt;=value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L191-L192" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __ge__(self, f: Callable[[A_co], Monad[B]]) -&gt; &#34;Parser[B]&#34;:
    return self.bind(f)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__or__"><code class="name flex">
<span>def <span class="ident">__or__</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A_co], other: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[B]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[typing.Union[+A_co, ~B]]</span>
</code></dt>
<dd>
<div class="desc"><p>Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
&gt;&gt;&gt; p = option(&quot;option&quot;) | flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--option&quot;, &quot;x&quot;)
{'option': 'x'}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<p>Note that when both arguments are supplied, this will only parse the first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--option&quot;, &quot;x&quot;)
{'verbose': True}
</code></pre>
<p>If you want this to fail, use <code>&gt;&gt;</code> (<code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code>) with <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> or another parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&quot;--verbose&quot;, &quot;--option&quot;, &quot;x&quot;)
usage: [--option OPTION | --verbose]
Unrecognized argument: --option
&gt;&gt;&gt; p.parse_args(&quot;--option&quot;, &quot;x&quot;)
{'option': 'x'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L124-L157" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __or__(  # type: ignore[override]
    self: &#34;Parser[A_co]&#34;,
    other: &#34;Parser[B]&#34;,
) -&gt; &#34;Parser[A_co | B]&#34;:
    &#34;&#34;&#34;
    Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

    &gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
    &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
    {&#39;option&#39;: &#39;x&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}

    Note that when both arguments are supplied, this will only parse the first:
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
    {&#39;verbose&#39;: True}

    If you want this to fail, use `&gt;&gt;` (`Parser.__rshift__`) with `done()` or another parser:
    &gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
    usage: [--option OPTION | --verbose]
    Unrecognized argument: --option
    &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
    {&#39;option&#39;: &#39;x&#39;}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[&#34;A_co | B&#34;]]:
        return self.parse(cs) | other.parse(cs)

    return Parser(
        f,
        usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
        helps={**self.helps, **other.helps},
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__rshift__"><code class="name flex">
<span>def <span class="ident">__rshift__</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]], p: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[B]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[typing.Union[~A, ~B]]]</span>
</code></dt>
<dd>
<div class="desc"><p>This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
gets handed off to the second parser. If either parser fails, the whole thing fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;first&quot;) &gt;&gt; argument(&quot;second&quot;)
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
{'first': 'a', 'second': 'b'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)
usage: first second
The following arguments are required: second
&gt;&gt;&gt; p.parse_args(&quot;b&quot;)
usage: first second
The following arguments are required: second
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L159-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __rshift__(
    self: &#34;Parser[Sequence[A]]&#34;, p: &#34;Parser[Sequence[B]]&#34;
) -&gt; &#34;Parser[Sequence[A | B]]&#34;:
    &#34;&#34;&#34;
    This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
    gets handed off to the second parser. If either parser fails, the whole thing fails.

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
    usage: first second
    The following arguments are required: second
    &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
    usage: first second
    The following arguments are required: second
    &#34;&#34;&#34;
    # def f(p1: Sequence[D]) -&gt; Parser[Parse[Sequence[D | B]]]:
    #     def g(p2: Sequence[B]) -&gt; Parser[Sequence[D | B]]:
    #         return Parser.return_(p1 + p2)

    #     return p &gt;= g

    # return self &gt;= f
    parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
    return replace(
        parser,
        usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False),
        helps={**self.helps, **p.helps},
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.bind"><code class="name flex">
<span>def <span class="ident">bind</span></span>(<span>self, f: Callable[[+A_co], pytypeclass.monad.Monad[~B]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~B]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new parser that</p>
<ol>
<li>applies <code>self</code>;</li>
<li>if this succeeds, applies <code>f</code> to the parsed component of the result.</li>
</ol>
<p><code>bind</code> is one of the functions that makes <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. But most users will
avoid using it directly, preferring higher level combinators like <code>&gt;&gt;</code> (<code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code>),
<code>|</code> (<code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>) and <code>+</code> (<code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code>).</p>
<p>Note that <code>&gt;=</code> as a synonym for <code>bind</code> (as defined in <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26"><code>pytypeclass</code></a>)
and we typically prefer using the infix operator to the spelled out method.</p>
<p>Let's start with our simplest parser, <code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = argument(&quot;some_dest&quot;)
</code></pre>
<p>Now let's use the <code><a title="dollar_lambda.equals" href="#dollar_lambda.equals">equals()</a></code> parser to write a function that takes the output of <code>p1</code> and fails unless
the next argument is the same as the first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Parser[Sequence[KeyValue[str]]]:
...     [kv] = kvs
...     return equals(kv.value)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = p1 &gt;= f
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;a&quot;)
{'a': 'a'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
Expected 'a'. Got 'b'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L194-L232" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bind(self, f: Callable[[A_co], Monad[B]]) -&gt; &#34;Parser[B]&#34;:
    &#34;&#34;&#34;
    Returns a new parser that

    1. applies `self`;
    2. if this succeeds, applies `f` to the parsed component of the result.

    `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
    avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
    `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

    Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
    and we typically prefer using the infix operator to the spelled out method.

    Let&#39;s start with our simplest parser, `argument`:
    &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

    Now let&#39;s use the `equals` parser to write a function that takes the output of `p1` and fails unless
    the next argument is the same as the first:
    &gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Parser[Sequence[KeyValue[str]]]:
    ...     [kv] = kvs
    ...     return equals(kv.value)

    &gt;&gt;&gt; p = p1 &gt;= f
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
    {&#39;a&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    Expected &#39;a&#39;. Got &#39;b&#39;
    &#34;&#34;&#34;

    def h(parse: Parse[A_co]) -&gt; Result[Parse[B]]:
        y = f(parse.parsed)
        assert isinstance(y, Parser), y
        return y.parse(parse.unparsed)

    def g(cs: Sequence[str]) -&gt; Result[Parse[B]]:
        return self.parse(cs) &gt;= h

    return Parser(g, usage=None, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.handle_error"><code class="name flex">
<span>def <span class="ident">handle_error</span></span>(<span>self, error: <a title="dollar_lambda.error.ArgumentError" href="error.html#dollar_lambda.error.ArgumentError">ArgumentError</a>) <span style="white-space: nowrap;">-></span> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L243-L259" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def handle_error(self, error: ArgumentError) -&gt; None:
    def print_usage(usage: str):
        print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in usage else &#34; &#34;)
        if &#34;\n&#34; in usage:
            usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in usage.split(&#34;\n&#34;)])
        print(usage)
        if self.helps:
            for k, v in self.helps.items():
                print(f&#34;{k}: {v}&#34;)

    if isinstance(error, HelpError):
        print_usage(error.usage)
    else:
        if self.usage:
            print_usage(self.usage)
        if error.usage:
            print(error.usage)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.many"><code class="name flex">
<span>def <span class="ident">many</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> zero or more times (like <code>*</code> in regexes).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(return_dict=False)
[]
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, return_dict=False)
[('as-many-as-you-like', 'a')]
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;, return_dict=False)  # return_dict=False allows duplicate keys
[('as-many-as-you-like', 'a'), ('as-many-as-you-like', 'b')]
</code></pre>
<p>Note that if <code>self</code> contains <code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>, the arguments can be
heterogenous:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p = p.many()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;, return_dict=False) # mix --verbose and --quiet
[('verbose', True), ('quiet', True)]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L261-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def many(self: &#34;Parser[Sequence[A]]&#34;) -&gt; &#34;Parser[Sequence[A]]&#34;:
    &#34;&#34;&#34;
    Applies `self` zero or more times (like `*` in regexes).

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(return_dict=False)
    []
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, return_dict=False)
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;)]
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)  # return_dict=False allows duplicate keys
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

    Note that if `self` contains `Parser.__or__`, the arguments can be
    heterogenous:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
    &gt;&gt;&gt; p = p.many()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, return_dict=False) # mix --verbose and --quiet
    [(&#39;verbose&#39;, True), (&#39;quiet&#39;, True)]
    &#34;&#34;&#34;
    p = self.many1() | self.empty()
    return replace(p, usage=f&#34;[{self.usage} ...]&#34;)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.many1"><code class="name flex">
<span>def <span class="ident">many1</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> one or more times (like <code>+</code> in regexes).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;1-or-more&quot;).many1()
&gt;&gt;&gt; p.parse_args(&quot;1&quot;)
{'1-or-more': '1'}
&gt;&gt;&gt; p.parse_args(&quot;1&quot;, &quot;2&quot;, return_dict=False)  # return_dict=False allows duplicate keys
[('1-or-more', '1'), ('1-or-more', '2')]
&gt;&gt;&gt; p.parse_args()
usage: 1-or-more [1-or-more ...]
The following arguments are required: 1-or-more
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L286-L318" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def many1(self: &#34;Parser[Sequence[A]]&#34;) -&gt; &#34;Parser[Sequence[A]]&#34;:
    &#34;&#34;&#34;
    Applies `self` one or more times (like `+` in regexes).

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
    {&#39;1-or-more&#39;: &#39;1&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, return_dict=False)  # return_dict=False allows duplicate keys
    [(&#39;1-or-more&#39;, &#39;1&#39;), (&#39;1-or-more&#39;, &#39;2&#39;)]
    &gt;&gt;&gt; p.parse_args()
    usage: 1-or-more [1-or-more ...]
    The following arguments are required: 1-or-more
    &#34;&#34;&#34;

    def g() -&gt; Generator[&#34;Parser[Sequence[A]]&#34;, Sequence[A], None]:
        # noinspection PyTypeChecker
        r1: Sequence[A] = yield self
        # noinspection PyTypeChecker
        r2: Sequence[A] = yield self.many()
        yield Parser[Sequence[A]].return_(r1 + r2)

    @lru_cache()
    def f(cs: tuple):
        y = Parser.do(g)
        assert isinstance(y, Parser), y
        return y.parse(Sequence(list(cs)))

    return Parser(
        lambda cs: f(tuple(cs)),
        usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
        helps=self.helps,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.optional"><code class="name flex">
<span>def <span class="ident">optional</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Allows arguments to be optional:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;optional&quot;) &gt;&gt; done()
&gt;&gt;&gt; p = p1.optional()
&gt;&gt;&gt; p.parse_args(&quot;--optional&quot;)
{'optional': True}
&gt;&gt;&gt; p.parse_args(&quot;--misspelled&quot;)  # succeeds with no output
{}
&gt;&gt;&gt; p1.parse_args(&quot;--misspelled&quot;)
usage: --optional
Expected '--optional'. Got '--misspelled'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L320-L333" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def optional(self: &#34;Parser[Sequence[A]]&#34;) -&gt; &#34;Parser[Sequence[A]]&#34;:
    &#34;&#34;&#34;
    Allows arguments to be optional:
    &gt;&gt;&gt; p1 = flag(&#34;optional&#34;) &gt;&gt; done()
    &gt;&gt;&gt; p = p1.optional()
    &gt;&gt;&gt; p.parse_args(&#34;--optional&#34;)
    {&#39;optional&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--misspelled&#34;)  # succeeds with no output
    {}
    &gt;&gt;&gt; p1.parse_args(&#34;--misspelled&#34;)
    usage: --optional
    Expected &#39;--optional&#39;. Got &#39;--misspelled&#39;
    &#34;&#34;&#34;
    return self | self.empty()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, cs: <a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[str]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="parser.html#dollar_lambda.parser.Parse">Parse</a>[+A_co]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the parser to the input sequence <code>cs</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L335-L339" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
    &#34;&#34;&#34;
    Applies the parser to the input sequence `cs`.
    &#34;&#34;&#34;
    return self.f(cs)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[KeyValue]], *args: str, return_dict: bool = True, check_help: bool = True) <span style="white-space: nowrap;">-></span> Union[Sequence[<a title="dollar_lambda.key_value.KeyValueTuple" href="key_value.html#dollar_lambda.key_value.KeyValueTuple">KeyValueTuple</a>], Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>The main way the user extracts parsed results from the parser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>str</code></dt>
<dd>A sequence of strings to parse. If empty, defaults to <code>sys.argv[1:]</code>.</dd>
<dt><strong><code>return_dict</code></strong> :&ensp;<code>bool</code></dt>
<dd>Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
The tuples are <code>KeyValueTuple</code> namedtuples, with fields <code>key</code> and <code>value</code>.</dd>
<dt><strong><code>check_help</code></strong> :&ensp;<code>bool</code></dt>
<dd>Before running the parser, checks if the input string is <code>--help</code> or <code>-h</code>.
If it is, returns the usage message.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;-h&quot;)
usage: a
&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;--help&quot;)
usage: a
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/3b7aec7c787d576a53897dbf5891d1c0b11c400d/dollar_lambda/parser.py#L341-L385" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_args(
    self: &#34;Parser[Sequence[KeyValue]]&#34;,
    *args: str,
    return_dict: bool = True,
    check_help: bool = True,
) -&gt; &#34;typing.Sequence[KeyValueTuple] | Dict[str, Any]&#34;:
    &#34;&#34;&#34;
    The main way the user extracts parsed results from the parser.

    Parameters
    ----------
    args : str
        A sequence of strings to parse. If empty, defaults to `sys.argv[1:]`.
    return_dict : bool
        Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
        The tuples are `KeyValueTuple` namedtuples, with fields `key` and `value`.
    check_help : bool
        Before running the parser, checks if the input string is `--help` or `-h`.
        If it is, returns the usage message.

    Examples
    --------

    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
    usage: a
    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
    usage: a
    &#34;&#34;&#34;
    _args = args if args or TESTING else sys.argv[1:]
    if check_help:
        return wrap_help(self).parse_args(
            *_args, return_dict=return_dict, check_help=False
        )
    result = self.parse(Sequence(list(_args))).get
    if isinstance(result, ArgumentError):
        self.handle_error(result)
        if TESTING:
            return  # type: ignore[return-value]
        else:
            exit()

    kvs = result.head.parsed
    if return_dict:
        return {kv.key: kv.value for kv in kvs}
    return [KeyValueTuple(**asdict(kv)) for kv in kvs]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#highlights">Highlights</a><ul>
<li><a href="#the-command-decorator">The command decorator</a><ul>
<li><a href="#equivalent-syntax">Equivalent $λ syntax</a></li>
</ul>
</li>
<li><a href="#for-alternatives">| for alternatives</a></li>
<li><a href="#commandtree-for-dynamic-dispatch">CommandTree for dynamic dispatch</a></li>
</ul>
</li>
<li><a href="#tutorial">Tutorial</a><ul>
<li><a href="#an-example-from-argparse">An example from argparse</a></li>
<li><a href="#high-level-parsers">High-Level Parsers</a><ul>
<li><a href="#flag">flag</a></li>
<li><a href="#option">option</a></li>
<li><a href="#empty">empty</a></li>
<li><a href="#done">done</a></li>
</ul>
</li>
<li><a href="#parser-combinators">Parser Combinators</a><ul>
<li><a href="#parser__or__">Parser.__or__</a></li>
<li><a href="#parser__rshift__">Parser.__rshift__</a></li>
<li><a href="#nonpositional-and-parser__add__">nonpositional and Parser.__add__</a></li>
</ul>
</li>
<li><a href="#putting-it-all-together">Putting it all together</a></li>
<li><a href="#variations-on-the-example">Variations on the example</a><ul>
<li><a href="#variable-numbers-of-arguments">Variable numbers of arguments</a></li>
<li><a href="#parsermany">Parser.many</a></li>
<li><a href="#parsermany1">Parser.many1</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#commandtree-tutorial">CommandTree Tutorial</a><ul>
<li><a href="#commandtreecommand">CommandTree.command</a></li>
<li><a href="#commandtreesubcommand">CommandTree.subcommand</a></li>
</ul>
</li>
<li><a href="#why">Why $λ?</a><ul>
<li><a href="#versatile">Versatile</a></li>
<li><a href="#type-safe">Type-safe</a></li>
<li><a href="#concise">Concise</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="dollar_lambda.args" href="args.html">dollar_lambda.args</a></code></li>
<li><code><a title="dollar_lambda.decorators" href="decorators.html">dollar_lambda.decorators</a></code></li>
<li><code><a title="dollar_lambda.error" href="error.html">dollar_lambda.error</a></code></li>
<li><code><a title="dollar_lambda.key_value" href="key_value.html">dollar_lambda.key_value</a></code></li>
<li><code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code></li>
<li><code><a title="dollar_lambda.result" href="result.html">dollar_lambda.result</a></code></li>
<li><code><a title="dollar_lambda.sequence" href="sequence.html">dollar_lambda.sequence</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="dollar_lambda.apply" href="#dollar_lambda.apply">apply</a></code></li>
<li><code><a title="dollar_lambda.apply_item" href="#dollar_lambda.apply_item">apply_item</a></code></li>
<li><code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument</a></code></li>
<li><code><a title="dollar_lambda.command" href="#dollar_lambda.command">command</a></code></li>
<li><code><a title="dollar_lambda.defaults" href="#dollar_lambda.defaults">defaults</a></code></li>
<li><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done</a></code></li>
<li><code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty</a></code></li>
<li><code><a title="dollar_lambda.equals" href="#dollar_lambda.equals">equals</a></code></li>
<li><code><a title="dollar_lambda.field" href="#dollar_lambda.field">field</a></code></li>
<li><code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag</a></code></li>
<li><code><a title="dollar_lambda.item" href="#dollar_lambda.item">item</a></code></li>
<li><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional</a></code></li>
<li><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option</a></code></li>
<li><code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat</a></code></li>
<li><code><a title="dollar_lambda.sat_item" href="#dollar_lambda.sat_item">sat_item</a></code></li>
<li><code><a title="dollar_lambda.type_" href="#dollar_lambda.type_">type_</a></code></li>
<li><code><a title="dollar_lambda.wrap_help" href="#dollar_lambda.wrap_help">wrap_help</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.Args.parse_args" href="#dollar_lambda.Args.parse_args">parse_args</a></code></li>
<li><code><a title="dollar_lambda.Args.parser" href="#dollar_lambda.Args.parser">parser</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.CommandTree.command" href="#dollar_lambda.CommandTree.command">command</a></code></li>
<li><code><a title="dollar_lambda.CommandTree.subcommand" href="#dollar_lambda.CommandTree.subcommand">subcommand</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code></h4>
<ul class="two-column">
<li><code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">__add__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__ge__" href="#dollar_lambda.Parser.__ge__">__ge__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">__or__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">__rshift__</a></code></li>
<li><code><a title="dollar_lambda.Parser.bind" href="#dollar_lambda.Parser.bind">bind</a></code></li>
<li><code><a title="dollar_lambda.Parser.empty" href="#dollar_lambda.Parser.empty">empty</a></code></li>
<li><code><a title="dollar_lambda.Parser.f" href="#dollar_lambda.Parser.f">f</a></code></li>
<li><code><a title="dollar_lambda.Parser.handle_error" href="#dollar_lambda.Parser.handle_error">handle_error</a></code></li>
<li><code><a title="dollar_lambda.Parser.helps" href="#dollar_lambda.Parser.helps">helps</a></code></li>
<li><code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">many</a></code></li>
<li><code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">many1</a></code></li>
<li><code><a title="dollar_lambda.Parser.optional" href="#dollar_lambda.Parser.optional">optional</a></code></li>
<li><code><a title="dollar_lambda.Parser.parse" href="#dollar_lambda.Parser.parse">parse</a></code></li>
<li><code><a title="dollar_lambda.Parser.parse_args" href="#dollar_lambda.Parser.parse_args">parse_args</a></code></li>
<li><code><a title="dollar_lambda.Parser.return_" href="#dollar_lambda.Parser.return_">return_</a></code></li>
<li><code><a title="dollar_lambda.Parser.usage" href="#dollar_lambda.Parser.usage">usage</a></code></li>
<li><code><a title="dollar_lambda.Parser.zero" href="#dollar_lambda.Parser.zero">zero</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</html>
