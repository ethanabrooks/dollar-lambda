<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dollar_lambda API documentation</title>
<meta name="description" content="This package provides an alternative to [`argparse`](https://docs.python.org/3/library/argparse.html)
based on parser combinators and functional first …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&family=IBM+Plex+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
body {
font-family: 'IBM Plex Sans', sans-serif;
line-height: 1.45;
font-size: 15px;
}
pre, code {
font-family: Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", Monaco, "Courier New", Courier, monospace;
}
p code {
white-space: nowrap;
}
</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:50%;max-height:10em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="file:///Users/ethanbrooks/monad_argparse/docs/dollar_lambda/index.html">
<link rel="icon" href="https://ethanabrooks.github.io/dollar-lambda/logo.png">
<main>
<article id="content">
<header>
<h1 class="title">Package <code>dollar_lambda</code></h1>
<a href="https://github.com/ethanabrooks/dollar-lambda" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
</svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</header>
<section id="section-intro">
<p>This package provides an alternative to <a href="https://docs.python.org/3/library/argparse.html"><code>argparse</code></a>
based on parser combinators and functional first principles. Arguably, <code>$λ</code> is way more expressive than any reasonable
person would ever need&hellip; but even if it's not the parser that we need, it's the parser we deserve.</p>
<h1 id="installation">Installation</h1>
<pre><code>pip install dollar-lambda
</code></pre>
<h1 id="highlights">Highlights</h1>
<p><code>$λ</code> comes with syntactic sugar that came make building parsers completely boilerplate-free.
For complex parsing situations that exceed the expressive capacity of this syntax,
the user can also drop down to the lower-level syntax that lies behind the sugar, which can
handle any reasonable amount of logical complexity.</p>
<h2 id="the-command-decorator">The <a href="#dollar_lambda.command"><code>@command</code></a> decorator</h2>
<p>For the vast majority of parsing patterns, <code>@command</code> is the most concise way to
define a parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command()
... def main(x: int, dev: bool = False, prod: bool = False):
...     return dict(x=x, dev=dev, prod=prod)
</code></pre>
<p>Here is the help text generated by this parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-h&quot;)
usage: -x X --dev --prod
</code></pre>
<p>And here it is in action:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;--dev&quot;)
{'x': 1, 'dev': True, 'prod': False}
</code></pre>
<p>Ordinarily you would provide <code>main</code> no arguments and
it would get them from the command line.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; parser.TESTING = False  # False by default but needs to be true for doctests
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.argv[1:] = [&quot;-x&quot;, &quot;1&quot;, &quot;--dev&quot;]  # simulate command line input
&gt;&gt;&gt; main()
{'x': 1, 'dev': True, 'prod': False}
</code></pre>
<p>In this document we'll feed the strings directly for the sake of brevity.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; parser.TESTING = True
</code></pre>
<p>Use the <code>parsers</code> argument to add custom logic to this parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(parsers=dict(kwargs=(flag(&quot;dev&quot;) | flag(&quot;prod&quot;))))
... def main(x: int, **kwargs):
...     return dict(x=x, **kwargs)
</code></pre>
<p>This parser requires either a <code>--dev</code> or <code>--prod</code> flag and maps it to the <code>kwargs</code> argument:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-h&quot;)
usage: -x X [--dev | --prod]
&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;--dev&quot;)
{'x': 1, 'dev': True}
&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;--prod&quot;)
{'x': 1, 'prod': True}
&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;)
usage: -x X [--dev | --prod]
The following arguments are required: --dev
</code></pre>
<h2 id="commandtree-for-dynamic-dispatch"><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> for dynamic dispatch</h2>
<p>For many programs, a user will want to use one entrypoint for one set of
arguments, and another for another set of arguments. Returning to our example,
let's say we wanted to execute <code>prod_function</code> when the user provides the
<code>--prod</code> flag, and <code>dev_function</code> when the user provides the <code>--dev</code> flag:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def base_function(x: int):
...     print(&quot;Ran base_function with arguments:&quot;, dict(x=x))
...
&gt;&gt;&gt; @base_function.command()
... def prod_function(x: int, prod: bool):
...     print(&quot;Ran prod_function with arguments:&quot;, dict(x=x, prod=prod))
...
&gt;&gt;&gt; @base_function.command()
... def dev_function(x: int, dev: bool):
...     print(&quot;Ran dev_function with arguments:&quot;, dict(x=x, dev=dev))
</code></pre>
<p>Let's see how this parser handles different inputs.
If we provide the <code>--prod</code> flag, <code>$λ</code> automatically invokes
<code>prod_function</code> with the parsed arguments:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-x&quot;, &quot;1&quot;, &quot;--prod&quot;)
Ran prod_function with arguments: {'x': 1, 'prod': True}
</code></pre>
<p>If we provide the <code>--dev</code> flag, <code>$λ</code> invokes <code>dev_function</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-x&quot;, &quot;1&quot;, &quot;--dev&quot;)
Ran dev_function with arguments: {'x': 1, 'dev': True}
</code></pre>
<p>With this configuration, the parser will run <code>base_function</code> if neither
<code>--prod</code> nor <code>--dev</code> are given:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-x&quot;, &quot;1&quot;)
Ran base_function with arguments: {'x': 1}
</code></pre>
<p>As with <code>main</code> in the previous example, you would ordinarily provide <code>tree</code> no arguments and it would get them
from the command line.</p>
<p>There are many other ways to use <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code>,
including some that make use of the <code>base_function</code>.
To learn more, we recommend the <a href="#commandtree-tutorial"><code>CommandTree</code> tutorial</a>.</p>
<h2 id="lower-level-syntax">Lower-level syntax</h2>
<p><a href="#dollar_lambda.command"><code>@command</code></a> and <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> cover many use cases,
but they are both syntactic sugar for a lower-level interface that is far
more expressive.</p>
<p>Suppose you want to implement a parser that first tries to parse an option
(a flag that takes an argument),
<code>-x X</code> and if that fails, tries to parse the input as a variadic sequence of
floats:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = option(&quot;x&quot;, type=int) | argument(&quot;y&quot;, type=float).many()
</code></pre>
<p>We go over this syntax in greater detail in the <a href="#tutorial">tutorial</a>.
For now, suffice to say that <code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument()</a></code> defines a positional argument,
<a href="#dollar_lambda.Parser.many"><code>many</code></a> allows parsers to be applied
zero or more times, and <a href="#dollar_lambda.Parser.__or__"><code>|</code></a> expresses alternatives.</p>
<p>Here is the help text:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: [-x X | [Y ...]]
</code></pre>
<p>As promised, this succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;)
{'x': 1}
</code></pre>
<p>And this succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)
{'y': [1.0, 2.0, 3.0]}
</code></pre>
<p>Again, you would ordinarily provide <code>parse_args</code> no arguments and it would get them
from the command line:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; parser.TESTING = False
&gt;&gt;&gt; sys.argv[1:] = [&quot;-x&quot;, &quot;1&quot;]  # simulate command line input
&gt;&gt;&gt; p.parse_args()
{'x': 1}
&gt;&gt;&gt; parser.TESTING = True
</code></pre>
<h1 id="tutorial">Tutorial</h1>
<p>We've already seen many of the concepts that power <code>$λ</code> in the
<a href="#highlights">Highlights</a> section. This tutorial will address
these concepts one at a time and expose the reader to some
nuances of usage.</p>
<h2 id="an-example-from-argparse">An example from <code>argparse</code></h2>
<p>Many of you are already familiar with <code>argparse</code>.
You may even recognize this example from the <code>argparse</code> docs:</p>
<pre><code>import argparse
parser = argparse.ArgumentParser(description=&quot;calculate X to the power of Y&quot;)
group = parser.add_mutually_exclusive_group()
group.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;)
group.add_argument(&quot;-q&quot;, &quot;--quiet&quot;, action=&quot;store_true&quot;)
parser.add_argument(&quot;x&quot;, type=int, help=&quot;the base&quot;)
parser.add_argument(&quot;y&quot;, type=int, help=&quot;the exponent&quot;)
args = parser.parse_args()
</code></pre>
<p>Here is one way to express this logic in <code>$λ</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(
...     parsers=dict(kwargs=(flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)).optional()),
...     help=dict(x=&quot;the base&quot;, y=&quot;the exponent&quot;),
... )
... def main(x: int, y: int, **kwargs):
...     return dict(x=x, y=y, **kwargs)  # Run program. Return can be whatever.
</code></pre>
<p>Here is the help text for this parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-h&quot;)
usage: -x X -y Y [--verbose | --quiet]
x: the base
y: the exponent
</code></pre>
<p>As indicated, this succeeds given <code>--verbose</code></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True}
</code></pre>
<p>or <code>--quiet</code></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;)
{'x': 1, 'y': 2, 'quiet': True}
</code></pre>
<p>or neither</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)
{'x': 1, 'y': 2}
</code></pre>
<p>Ordinarily , we would not feed <code>main</code> any arguments, and it would get them from
the command line:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; parser.TESTING = False  # False by default but needs to be True for doctests
&gt;&gt;&gt; sys.argv[1:] = [&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;]  # simulate command line input
&gt;&gt;&gt; main()
{'x': 1, 'y': 2}
&gt;&gt;&gt; parser.TESTING = True
</code></pre>
<h2 id="equivalent-in-lower-level-syntax">Equivalent in lower-level syntax</h2>
<p>To better understand what is going on here, let's remove the syntactic sugar:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)).optional(),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... )
...
&gt;&gt;&gt; def main(x, y, **kwargs):
...     return dict(x=x, y=y, **kwargs)
</code></pre>
<p>Now let's walk through this step by step.</p>
<h2 id="high-level-parsers">High-Level Parsers</h2>
<p>In the de-sugared implementation there are two different parser constructors:
<code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code>, which binds a boolean value to a variable, and <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code>, which binds an arbitrary value to a variable.</p>
<h3 id="flag"><code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code></h3>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<p>By default <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> fails when it does not receive expected input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose
</code></pre>
<p>Alternately, you can set a default value:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;, default=False).parse_args()
{'verbose': False}
</code></pre>
<h3 id="option"><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code></h3>
<p><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> is similar but takes an argument:
By default, <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> expects a single <code>-</code> for single-character variable names (as in <code>-x</code>),
as opposed to <code>--</code> for longer names (as in <code>--xenophon</code>):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;).parse_args(&quot;-x&quot;, &quot;1&quot;)
{'x': '1'}
&gt;&gt;&gt; option(&quot;xenophon&quot;).parse_args(&quot;--xenophon&quot;, &quot;1&quot;)
{'xenophon': '1'}
</code></pre>
<p>Use the <code>type</code> argument to convert the input to a different type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;, type=int).parse_args(&quot;-x&quot;, &quot;1&quot;)  # converts &quot;1&quot; to an int
{'x': 1}
</code></pre>
<h2 id="parser-combinators">Parser Combinators</h2>
<p>Parser combinators are functions that combine multiple parsers into new, more complex parsers.
Our example uses two such functions: <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> and <a href="#dollar_lambda.Parser.__or__"><code>|</code></a>.</p>
<h3 id="_1"><a href="#dollar_lambda.Parser.__or__"><code>|</code></a></h3>
<p>The <a href="#dollar_lambda.Parser.__or__"><code>|</code></a> operator is used for alternatives. Specifically, it will try the first parser,
and if that fails, try the second:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;) # flag(&quot;verbose&quot;) fails
{'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;) # flag(&quot;verbose&quot;) succeeds
{'verbose': True}
</code></pre>
<p>By default one of the two flags would be required to prevent failure:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args() # neither flag is provided so this fails
usage: [--verbose | --quiet]
The following arguments are required: --verbose
</code></pre>
<p>We can permit the omission of both flags
by using <code>optional</code>, as we saw earlier, or we can supply a default value:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)).optional().parse_args() # flags fail, but that's ok
{}
&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;, default=False)).parse_args() # flag(&quot;verbose&quot;) fails but flag(&quot;quiet&quot;, default=False) succeeds
{'quiet': False}
</code></pre>
<p>Users should note that unlike logical "or" but like Python <code>or</code>, the <a href="#dollar_lambda.Parser.__or__"><code>|</code></a> operator is not commutative:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) | argument(&quot;x&quot;)).parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<p><code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument()</a></code> binds to positional arguments. If it comes first, it will think that <code>"--verbose"</code> is
the expression that we want to bind to <code>x</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (argument(&quot;x&quot;) | flag(&quot;verbose&quot;)).parse_args(&quot;--verbose&quot;)
{'x': '--verbose'}
</code></pre>
<h3 id="nonpositional-and"><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> and <a href="#dollar_lambda.Parser.__add__"><code>+</code></a></h3>
<p><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<p>For just two parsers you can use <a href="#dollar_lambda.Parser.__add__"><code>+</code></a> instead of <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<p>This will not cover all permutations for more than two parsers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;) + option(&quot;x&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;--quiet&quot;)
usage: --verbose --quiet -x X
Expected '--quiet'. Got '-x'
</code></pre>
<p>To see why note the implicit parentheses:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;)) + option(&quot;x&quot;)
</code></pre>
<p>In order to cover the case where <code>-x</code> comes between <code>--verbose</code> and <code>--quiet</code>,
use <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;), option(&quot;x&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;--quiet&quot;)  # works
{'verbose': True, 'x': '1', 'quiet': True}
</code></pre>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>Let's recall the original example without the syntactic sugar:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)).optional(),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... )
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
</code></pre>
<p>As we've seen, <code>(flag("verbose") | flag("quiet")).optional()</code> succeeds on either <code>--verbose</code> or <code>--quiet</code>
or neither.</p>
<p><code>option("x", type=int)</code> succeeds on <code>-x X</code>, where <code>X</code> is
some integer, binding that integer to the variable <code>"x"</code>. Similarly for <code>option("y", type=int)</code>.</p>
<p><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> takes the three parsers:</p>
<ul>
<li><code>(flag("verbose") | flag("quiet")).optional()</code></li>
<li><code>option("x", type=int)</code></li>
<li><code>option("y", type=int)</code></li>
</ul>
<p>and applies them in every order, until some order succeeds.</p>
<p>Applying the syntactic sugar:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(
...     parsers=dict(kwargs=(flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)).optional()),
...     help=dict(x=&quot;the base&quot;, y=&quot;the exponent&quot;),
... )
... def main(x: int, y: int, **kwargs):
...     pass  # do work
</code></pre>
<p>Here the <code>parsers</code> argument reserves a function argument (in this case, <code>kwargs</code>)
for a custom parser (in this case, <code>(flag("verbose") | flag("quiet")).optional()</code>)
using our lower-level syntax.
The <code>help</code> argument
assigns help text to the arguments (in this case <code>x</code> and <code>y</code>).</p>
<h2 id="variations-on-the-example">Variations on the example</h2>
<h3 id="positional-arguments">Positional arguments</h3>
<p>What if we wanted to supply <code>x</code> and <code>y</code> as positional arguments?</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flags = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p =  option(&quot;x&quot;, type=int) &gt;&gt; option(&quot;y&quot;, type=int) &gt;&gt; flags
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: -x X -y Y [--verbose | --quiet]
</code></pre>
<p>This introduces a new parser combinator: <a href="#dollar_lambda.Parser.__rshift__"><code>&gt;&gt;</code></a> which evaluates
parsers in sequence. In this example, it would first evaluate the <code>option("x", type=int)</code> parser,
and if that succeeded, it would hand the unparsed remainder on to the <code>option("y", type=int)</code> parser,
and so on until all parsers have been evaluated or no more input remains.
If any of the parsers fail, the combined parser fails:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;)   # succeeds
{'x': 1, 'y': 2, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;-typo&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;)   # first parser fails
usage: -x X -y Y [--verbose | --quiet]
Expected '-x'. Got '-typo'
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--typo&quot;)   # third parser fails
usage: -x X -y Y [--verbose | --quiet]
Expected '--verbose'. Got '--typo'
</code></pre>
<p>Unlike with <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> in the previous section, <a href="#dollar_lambda.Parser.__rshift__"><code>&gt;&gt;</code></a> requires the user to provide
arguments in a fixed order:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-y&quot;, &quot;2&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;--quiet&quot;)   # fails
usage: -x X -y Y [--verbose | --quiet]
Expected '-x'. Got '-y'
</code></pre>
<p>When using positional arguments, it might make sense to drop the <code>-x</code> and <code>-y</code> flags:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = argument(&quot;x&quot;, type=int) &gt;&gt; argument(&quot;y&quot;, type=int) &gt;&gt; flags
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: X Y [--verbose | --quiet]
&gt;&gt;&gt; p.parse_args(&quot;1&quot;, &quot;2&quot;, &quot;--quiet&quot;)
{'x': 1, 'y': 2, 'quiet': True}
</code></pre>
<p><code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument()</a></code> will bind input to a variable without checking for any special flag strings like
<code>-x</code> or <code>-y</code> preceding the input.</p>
<h3 id="variable-numbers-of-arguments">Variable numbers of arguments</h3>
<p>What if there was a special argument, <code>verbosity</code>,
that only makes sense if the user chooses <code>--verbose</code>?</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...    ((flag(&quot;verbose&quot;) + option(&quot;verbosity&quot;, type=int)) | flag(&quot;quiet&quot;)),
...    option(&quot;x&quot;, type=int),
...    option(&quot;y&quot;, type=int),
... )
</code></pre>
<p>Remember that <a href="#dollar_lambda.Parser.__add__"><code>+</code></a> evaluates two parsers in both orders
and stopping at the first order that succeeds. So this allows us to
supply <code>--verbose</code> and <code>--verbosity</code> in any order.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;)
{'x': 1, 'y': 2, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbosity&quot;, &quot;3&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
usage: [--verbose --verbosity VERBOSITY | --quiet] -x X -y Y
Expected '--verbose'. Got '-x'
</code></pre>
<p>We could express the same logic with the <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> decorator:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(
...     parsers=dict(
...         kwargs=flag(&quot;verbose&quot;) + option(&quot;verbosity&quot;, type=int) | flag(&quot;quiet&quot;)
...     ),
...     help=dict(x=&quot;the base&quot;, y=&quot;the exponent&quot;),
... )
... def main(x: int, y: int, **kwargs):
...     pass  # do work
</code></pre>
<p>This is also a case where you might want to use <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(help=dict(x=&quot;the base&quot;, y=&quot;the exponent&quot;))
... def base_function(x: int, y: int):
...     pass  # do work
...
&gt;&gt;&gt; @base_function.command()
... def verbose_function(x: int, y: int, verbose: bool, verbosity: int):
...     args = dict(x=x, y=y, verbose=verbose, verbosity=verbosity)
...     print(&quot;invoked verbose_function with args&quot;, args)
...
&gt;&gt;&gt; @base_function.command()
... def quiet_function(x: int, y: int, quiet: bool):
...     pass  # do work
...
&gt;&gt;&gt; tree(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbosity&quot;, &quot;3&quot;)
invoked verbose_function with args {'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3}
</code></pre>
<h3 id="many"><a href="#dollar_lambda.Parser.many"><code>many</code></a></h3>
<p>What if we want to specify verbosity by the number of times that <code>--verbose</code> appears?
For this we need <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code>. Before showing how we could use <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> in this setting,
let's look at how it works.</p>
<p><code>parser.many</code> takes <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> and tries to apply it as many times as possible.
<code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> is a bit like the <code>*</code> pattern, if you are familiar with regexes.
<code>parser.many</code> always succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)  # still succeeds
{'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--verbose&quot;)  # succeeds, binding list to 'verbose'
{'verbose': [True, True]}
</code></pre>
<p>Now returning to the original example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     flag(&quot;verbose&quot;).many(),
...     option(&quot;x&quot;, type=int),
...     option(&quot;y&quot;, type=int),
... )
&gt;&gt;&gt; args = p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbose&quot;)
&gt;&gt;&gt; args
{'x': 1, 'y': 2, 'verbose': [True, True]}
&gt;&gt;&gt; verbosity = len(args['verbose'])
&gt;&gt;&gt; verbosity
2
</code></pre>
<h3 id="many1"><a href="#dollar_lambda.Parser.many1"><code>many1</code></a></h3>
<p>In the previous example, the parse will default to <code>verbosity=0</code> if no <code>--verbose</code> flags
are given.
What if we wanted users to be explicit about choosing a "quiet" setting?
In other words, what if the user actually had to provide an explicit <code>--quiet</code> flag when
no <code>--verbose</code> flags were given?</p>
<p>For this, we use <code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">Parser.many1()</a></code>. This method is like <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> except that it fails
when on zero successes (recall that <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> always succeeds). So if <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code>
is like regex <code>*</code>, <code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">Parser.many1()</a></code> is like <a href="#dollar_lambda.Parser.__add__"><code>+</code></a>. Take a look:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p = flag(&quot;verbose&quot;).many1()  # note many1(), not many()
&gt;&gt;&gt; p.parse_args()  # fails
usage: --verbose [--verbose ...]
The following arguments are required: --verbose
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)  # succeeds
{'verbose': True}
</code></pre>
<p>To compell that <code>--quiet</code> flag from our users, we can do the following:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...    ((flag(&quot;verbose&quot;).many1()) | flag(&quot;quiet&quot;)),
...    option(&quot;x&quot;, type=int),
...    option(&quot;y&quot;, type=int),
... )
</code></pre>
<p>Now omitting both <code>--verbose</code> and <code>--quiet</code> will fail:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)
usage: [--verbose [--verbose ...] | --quiet] -x X -y Y
Expected '--verbose'. Got '-x'
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;) # this succeeds
{'verbose': True, 'x': 1, 'y': 2}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;) # and this succeeds
{'quiet': True, 'x': 1, 'y': 2}
</code></pre>
<h1 id="commandtree-tutorial"><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> Tutorial</h1>
<p><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> has already shown up in the
<a href="#commandtree-for-dynamic-dispatch">Highlights section</a>
and in the <a href="#variations-on-the-example">tutorial</a>.
In this section we will give a more thorough treatment,
exposing some of the underlying logic and covering all
the variations in functionality that <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code>
offers.</p>
<p><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> draws inspiration
from the <a href="https://click.palletsprojects.com/"><code>Click</code></a> library.
<code><a title="dollar_lambda.CommandTree.subcommand" href="#dollar_lambda.CommandTree.subcommand">CommandTree.subcommand()</a></code> (discussed <a href="#commandtreesubcommand">here</a>) closely
approximates the functionality described in the <a href="https://click.palletsprojects.com/en/8.1.x/commands/#command">Commands and Groups</a>
section of the <code>Click</code> documentation.</p>
<h2 id="commandtreecommand"><code><a title="dollar_lambda.CommandTree.command" href="#dollar_lambda.CommandTree.command">CommandTree.command()</a></code></h2>
<p>First let's walk through the use of the <code><a title="dollar_lambda.CommandTree.command" href="#dollar_lambda.CommandTree.command">CommandTree.command()</a></code> decorator, one step
at a time. First we define the object:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
</code></pre>
<p>Now we define at least one child function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a)) # this can be whatever
</code></pre>
<p><code><a title="dollar_lambda.CommandTree.command" href="#dollar_lambda.CommandTree.command">CommandTree.command()</a></code> automatically converts the function arguments into a parser.
We can run the parser and pass its output to our function <code>f1</code> by calling <code>tree</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A
</code></pre>
<p>At this point the parser takes a single option <code>-a</code> that binds an <code>int</code> to <code>'a'</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
</code></pre>
<p>Usually we would call <code>tree</code> with no arguments, and it would get its input from <code>sys.argv[1:]</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; parser.TESTING = False  # False by default but needs to be true for doctests
&gt;&gt;&gt; sys.argv[1:] = [&quot;-a&quot;, &quot;1&quot;]  # simulate command line input
&gt;&gt;&gt; tree()
{'f1': {'a': 1}}
&gt;&gt;&gt; parser.TESTING = True
</code></pre>
<p>Now let's add a second child function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command()
... def f2(b: bool):
...     return dict(f2=dict(b=b))  # this can also be whatever
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: [-a A | -b]
</code></pre>
<p><code>tree</code> will execute either <code>f1</code> or <code>f2</code> based on which of the parsers succeeds.
This will execute <code>f1</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
</code></pre>
<p>This will execute <code>f2</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-b&quot;)
{'f2': {'b': True}}
</code></pre>
<p>This fails:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree()
usage: [-a A | -b]
The following arguments are required: -a
</code></pre>
<p>Often in cases where there are alternative sets of argument like this,
there is also a set of shared arguments. We can define a parent function
to make our help text more concise and to allow the user to run the
parent function when the child arguments are not provided.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):  # this will be the parent function
...     return dict(f1=dict(a=a))
</code></pre>
<p>Now define a child function, <code>g1</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @f1.command()  # note f1, not tree
... def g1(a:int, b: bool):
...     return dict(g1=dict(b=b))
</code></pre>
<p>Make sure to include all the arguments of <code>f1</code> in <code>g1</code> or else
<code>g1</code> will fail when it is invoked. In its current state, <code>tree</code> sequences
the arguments of <code>f1</code> and <code>g1</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A -b
</code></pre>
<p>As before we can define an additional child function to induce alternative
argument sets:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @f1.command()  # note f1, not tree
... def g2(a: int, c: str):
...     return dict(g2=dict(c=c))
</code></pre>
<p>Note that our usage message shows <code>-a A</code> preceding the brackets because it corresponds
to the parent function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A [-b | -c C]
</code></pre>
<p>To execute <code>g1</code>, we give the <code>-b</code> flag:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;, &quot;-b&quot;)
{'g1': {'b': True}}
</code></pre>
<p>To execute <code>g2</code>, we give the <code>-c</code> flag:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;, &quot;-c&quot;, &quot;foo&quot;)
{'g2': {'c': 'foo'}}
</code></pre>
<p>Also, note that <code>tree</code> can have arbitrary depth:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @g1.command()  # h1 is a child of g1
... def h1(a: int, b: bool, d: float):
...    return dict(h1=dict(d=d))
</code></pre>
<p>Note the additional <code>-d D</code> argument on the left side of the <code>|</code> pipe:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A [-b -d D | -c C]
</code></pre>
<p>That comes from the third argument of <code>h1</code>.</p>
<h2 id="commandtreesubcommand"><code><a title="dollar_lambda.CommandTree.subcommand" href="#dollar_lambda.CommandTree.subcommand">CommandTree.subcommand()</a></code></h2>
<p>Often we want to explicitly specify which function to execute by naming it on the command line.
This would implement functionality similar to
<a href="https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers"><code>ArgumentParser.add_subparsers</code></a>
or <a href="https://click.palletsprojects.com/en/8.1.x/commands/#command"><code>Click.command</code></a>.</p>
<p>For this we would use the <code><a title="dollar_lambda.CommandTree.subcommand" href="#dollar_lambda.CommandTree.subcommand">CommandTree.subcommand()</a></code> decorator:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
...
&gt;&gt;&gt; @f1.subcommand()  # note subcommand, not command
... def g1(a:int, b: bool):
...     return dict(g1=dict(b=b))
...
&gt;&gt;&gt; @f1.subcommand()  # again, subcommand, not command
... def g2(a: int, c: str):
...     return dict(g2=dict(c=c))
</code></pre>
<p>Now the usage message indicates that <code>g1</code> and <code>g2</code> are required arguments:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A [g1 -b | g2 -c C]
</code></pre>
<p>Now we would select g1 as follows:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;, &quot;g1&quot;, &quot;-b&quot;)
{'g1': {'b': True}}
</code></pre>
<p>And g2 as follows:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-a&quot;, &quot;1&quot;, &quot;g2&quot;, &quot;-c&quot;, &quot;foo&quot;)
{'g2': {'c': 'foo'}}
</code></pre>
<p>You can freely mix and match <code>subcommand</code> and <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
...
&gt;&gt;&gt; @f1.subcommand()
... def g1(a:int, b: bool):
...     return dict(g1=dict(b=b))
...
&gt;&gt;&gt; @f1.command()  # note command, not subcommand
... def g2(a: int, c: str):
...     return dict(g2=dict(c=c))
</code></pre>
<p>Note that the left side of the pipe (corresponding to the <code>g1</code> function)
requires a <code>"g1"</code> argument to run but the right side (corresponding to the <code>g2</code> function)
does not:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -a A [g1 -b | -c C]
</code></pre>
<h1 id="use-with-config-files">Use with config files</h1>
<p>A common use case is to have a config file with default values that arguments should
fall back to if not provided on the command line. Instead of implementing specific functionality
itself, <code>$λ</code> accommodates this situation by simply getting out of the way, thereby affording the
user the most flexibility in terms of accessing and using the config file. Here is a simple example.</p>
<pre><code># example-config.json
{
  &quot;x&quot;: 1
}
</code></pre>
<p>Define a parser with optional values where you want to be able to fall back to the config file:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = option(&quot;x&quot;, type=int).optional() &gt;&gt; argument(&quot;y&quot;, type=int)
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: -x X Y
</code></pre>
<p>In this example, <code>-x X</code> can be omitted, falling back to the config, but the positional argument
<code>Y</code> will be required.</p>
<p>Make sure that the optional arguments do not have default values or else the config value will
always be overridden.
Inside main, load the config and update with any arguments provided on the command line:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import json
&gt;&gt;&gt; def main(**kwargs):
...     with open(&quot;example-config.json&quot;) as f:
...         config = json.load(f)
...
...     config.update(kwargs)
...     return config
</code></pre>
<p>Override the value in the config by providing an explicit argument:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(**p.parse_args(&quot;-x&quot;, &quot;0&quot;, &quot;1&quot;))
{'x': 0, 'y': 1}
</code></pre>
<p>Fall back to the value in the config by not providing an argument for <code>x</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(**p.parse_args(&quot;2&quot;))
{'x': 1, 'y': 2}
</code></pre>
<p>We can also write this with <code>@command</code> syntax:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(
...     parsers=dict(
...         y=argument(&quot;y&quot;, type=int),
...         kwargs=option(&quot;x&quot;, type=int).optional(),
...     )
... )
... def main(y: int, **kwargs):
...     with open(&quot;example-config.json&quot;) as f:
...         config = json.load(f)
...
...     config.update(**kwargs, y=y)
...     return config
&gt;&gt;&gt; main(&quot;-x&quot;, &quot;0&quot;, &quot;1&quot;)  # override config value
{'x': 0, 'y': 1}
&gt;&gt;&gt; main(2)  # fall back to config value
{'x': 1, 'y': 2}
</code></pre>
<h1 id="nesting-output">Nesting output</h1>
<p>By default introducing a <code>.</code> character into the name of an <code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument()</a></code>, <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code>, or <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> will
induce nested output:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;a.b&quot;, type=int).parse_args(&quot;1&quot;)
{'a': {'b': 1}}
&gt;&gt;&gt; option(&quot;a.b&quot;, type=int).parse_args(&quot;--a.b&quot;, &quot;1&quot;)
{'a': {'b': 1}}
&gt;&gt;&gt; flag(&quot;a.b&quot;).parse_args(&quot;--a.b&quot;)
{'a': {'b': True}}
</code></pre>
<p>This mechanism handles collisions:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nonpositional(flag(&quot;a.b&quot;), flag(&quot;a.c&quot;)).parse_args(&quot;--a.b&quot;, &quot;--a.c&quot;)
{'a': {'b': True, 'c': True}}
</code></pre>
<p>even when mixing nested and unnested output:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nonpositional(flag(&quot;a&quot;), flag(&quot;a.b&quot;)).parse_args(&quot;-a&quot;, &quot;--a.b&quot;)
{'a': [True, {'b': True}]}
</code></pre>
<p>It can also go arbitrarily deep:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; nonpositional(flag(&quot;a.b.c&quot;), flag(&quot;a.b.d&quot;)).parse_args(&quot;--a.b.c&quot;, &quot;--a.b.d&quot;)
{'a': {'b': {'c': True, 'd': True}}}
</code></pre>
<p>This behavior can always be disabled by setting <code>nesting=False</code> (or just not using <code>.</code> in the name).</p>
<h1 id="ignoring-arguments">Ignoring arguments</h1>
<p>There may be cases in which a user wants to provide certain arguments on the
command line that <code>$λ</code> should ignore (not return in the output of <code><a title="dollar_lambda.Parser.parse_args" href="#dollar_lambda.Parser.parse_args">Parser.parse_args()</a></code>
or pass to the a decorated function). Suppose we wish to ignore any arguments starting
with the <code>--config-</code> prefix:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; regex = r&quot;config-\S*&quot;
&gt;&gt;&gt; config_parsers = flag(regex) | option(regex)
</code></pre>
<p>In the case of ordered arguments, we simply use the <code>ignore</code> method:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;x&quot;) &gt;&gt; config_parsers.ignore() &gt;&gt; flag(&quot;y&quot;)
</code></pre>
<p>This will ignore any argument that starts with <code>--config-</code> and comes between <code>x</code> and <code>y</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;--config-foo&quot;, &quot;-y&quot;)
{'x': True, 'y': True}
</code></pre>
<p>Because of the way we defined <code>config_parsers</code>, this also works with <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;--config-bar&quot;, &quot;1&quot;, &quot;-y&quot;)
{'x': True, 'y': True}
</code></pre>
<p>In the case of nonpositional arguments, use the <code>repeated</code> keyword:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;x&quot;), flag(&quot;y&quot;), repeated=config_parsers.ignore())
</code></pre>
<p>Now neither <code>config-foo</code> nor <code>config-bar</code> show up in the output:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-y&quot;, &quot;--config-foo&quot;, &quot;--config-bar&quot;, &quot;1&quot;)
{'x': True, 'y': True}
</code></pre>
<p>This works regardless of order:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--config-baz&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;--config-foz&quot;, &quot;-x&quot;)
{'y': True, 'x': True}
</code></pre>
<p>And no matter how many matches are found:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(
...     &quot;--config-foo&quot;,
...     &quot;1&quot;,
...     &quot;--config-bar&quot;,
...     &quot;-y&quot;,
...     &quot;--config-baz&quot;,
...     &quot;2&quot;,
...     &quot;-x&quot;,
...     &quot;--config-foz&quot;,
... )
{'y': True, 'x': True}
</code></pre>
<p>The same technique can be used with decorators:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(repeated=config_parsers.ignore())
... def f(x: bool, y: bool):
...    return dict(x=x, y=y)
&gt;&gt;&gt; f(&quot;-x&quot;, &quot;-y&quot;, &quot;--config-foo&quot;, &quot;--config-bar&quot;, &quot;1&quot;)
{'x': True, 'y': True}
</code></pre>
<p>And similarly with <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code>.</p>
<h1 id="why">Why <code>$λ</code>?</h1>
<p><code>$λ</code> can handle many kinds of argument-parsing patterns
that are either very awkward, difficult, or impossible with other parsing libraries.
In particular, we emphasize the following qualities:</p>
<h3 id="versatile">Versatile</h3>
<p><code>$λ</code> provides high-level functionality equivalent to other parsers. But unlike other parsers,
it permits low-level customization to handle arbitrarily complex parsing patterns.
There are many parsing patterns that <code>$λ</code> can handle which are not possible with other parsing libraries.</p>
<h3 id="type-safe">Type-safe</h3>
<p><code>$λ</code> uses type annotations as much as Python allows. Types are checked using <a href="https://mypy.readthedocs.io/en/stable/index.html#"><code>MyPy</code></a> and exported with the package so that users can also benefit from
the type system. Furthermore, with rare exceptions, <code>$λ</code> avoids mutations and side-effects and preserves <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential
transparency</a>. This makes it easier for the type-checker <em>and
for the user</em> to reason about the code.</p>
<h3 id="concise">Concise</h3>
<p><code>$λ</code> provides many syntactic shortcuts for cutting down boilerplate:</p>
<ul>
<li>the <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> decorator and the <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> object for automatically building parsers from function signatures.</li>
<li>operators like <a href="#dollar_lambda.Parser.__rshift__"><code>&gt;&gt;</code></a>,
<a href="#dollar_lambda.Parser.__or__"><code>|</code></a>, <a href="#dollar_lambda.Parser.__xor__"><code>^</code></a>,
and <a href="#dollar_lambda.Parser.__add__"><code>+</code></a> (and <a href="#dollar_lambda.Parser.__ge__"><code>&gt;=</code></a> if you want to get fancy)</li>
</ul>
<h3 id="lightweight">Lightweight</h3>
<p><code>$λ</code> is written in pure python with no dependencies
(excepting <a href="https://github.com/ethanabrooks/pytypeclass"><code>pytypeclass</code></a>
which was written expressly for this library and has no dependencies).
<code>$λ</code> will not introduce dependency conflicts and it installs in a flash.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/__init__.py#L1-L928" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This package provides an alternative to [`argparse`](https://docs.python.org/3/library/argparse.html)
based on parser combinators and functional first principles. Arguably, `$λ` is way more expressive than any reasonable
person would ever need... but even if it&#39;s not the parser that we need, it&#39;s the parser we deserve.

# Installation
```
pip install dollar-lambda
```

# Highlights
`$λ` comes with syntactic sugar that came make building parsers completely boilerplate-free.
For complex parsing situations that exceed the expressive capacity of this syntax,
the user can also drop down to the lower-level syntax that lies behind the sugar, which can
handle any reasonable amount of logical complexity.

## The [`@command`](#dollar_lambda.command) decorator
For the vast majority of parsing patterns, `@command` is the most concise way to
define a parser:

&gt;&gt;&gt; @command()
... def main(x: int, dev: bool = False, prod: bool = False):
...     return dict(x=x, dev=dev, prod=prod)

Here is the help text generated by this parser:

&gt;&gt;&gt; main(&#34;-h&#34;)
usage: -x X --dev --prod

And here it is in action:

&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;--dev&#34;)
{&#39;x&#39;: 1, &#39;dev&#39;: True, &#39;prod&#39;: False}

Ordinarily you would provide `main` no arguments and
it would get them from the command line.

&gt;&gt;&gt; parser.TESTING = False  # False by default but needs to be true for doctests
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.argv[1:] = [&#34;-x&#34;, &#34;1&#34;, &#34;--dev&#34;]  # simulate command line input
&gt;&gt;&gt; main()
{&#39;x&#39;: 1, &#39;dev&#39;: True, &#39;prod&#39;: False}

In this document we&#39;ll feed the strings directly for the sake of brevity.
&gt;&gt;&gt; parser.TESTING = True

Use the `parsers` argument to add custom logic to this parser:

&gt;&gt;&gt; @command(parsers=dict(kwargs=(flag(&#34;dev&#34;) | flag(&#34;prod&#34;))))
... def main(x: int, **kwargs):
...     return dict(x=x, **kwargs)

This parser requires either a `--dev` or `--prod` flag and maps it to the `kwargs` argument:
&gt;&gt;&gt; main(&#34;-h&#34;)
usage: -x X [--dev | --prod]
&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;--dev&#34;)
{&#39;x&#39;: 1, &#39;dev&#39;: True}
&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;--prod&#34;)
{&#39;x&#39;: 1, &#39;prod&#39;: True}
&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;)
usage: -x X [--dev | --prod]
The following arguments are required: --dev

## `CommandTree` for dynamic dispatch
For many programs, a user will want to use one entrypoint for one set of
arguments, and another for another set of arguments. Returning to our example,
let&#39;s say we wanted to execute `prod_function` when the user provides the
`--prod` flag, and `dev_function` when the user provides the `--dev` flag:

&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def base_function(x: int):
...     print(&#34;Ran base_function with arguments:&#34;, dict(x=x))
...
&gt;&gt;&gt; @base_function.command()
... def prod_function(x: int, prod: bool):
...     print(&#34;Ran prod_function with arguments:&#34;, dict(x=x, prod=prod))
...
&gt;&gt;&gt; @base_function.command()
... def dev_function(x: int, dev: bool):
...     print(&#34;Ran dev_function with arguments:&#34;, dict(x=x, dev=dev))

Let&#39;s see how this parser handles different inputs.
If we provide the `--prod` flag, `$λ` automatically invokes
 `prod_function` with the parsed arguments:

&gt;&gt;&gt; tree(&#34;-x&#34;, &#34;1&#34;, &#34;--prod&#34;)
Ran prod_function with arguments: {&#39;x&#39;: 1, &#39;prod&#39;: True}

If we provide the `--dev` flag, `$λ` invokes `dev_function`:

&gt;&gt;&gt; tree(&#34;-x&#34;, &#34;1&#34;, &#34;--dev&#34;)
Ran dev_function with arguments: {&#39;x&#39;: 1, &#39;dev&#39;: True}

With this configuration, the parser will run `base_function` if neither
`--prod` nor `--dev` are given:

&gt;&gt;&gt; tree(&#34;-x&#34;, &#34;1&#34;)
Ran base_function with arguments: {&#39;x&#39;: 1}

As with `main` in the previous example, you would ordinarily provide `tree` no arguments and it would get them
from the command line.

There are many other ways to use `CommandTree`,
including some that make use of the `base_function`.
To learn more, we recommend the [`CommandTree` tutorial](#commandtree-tutorial).

## Lower-level syntax
[`@command`](#dollar_lambda.command) and `CommandTree` cover many use cases,
but they are both syntactic sugar for a lower-level interface that is far
more expressive.

Suppose you want to implement a parser that first tries to parse an option
(a flag that takes an argument),
`-x X` and if that fails, tries to parse the input as a variadic sequence of
floats:

&gt;&gt;&gt; p = option(&#34;x&#34;, type=int) | argument(&#34;y&#34;, type=float).many()

We go over this syntax in greater detail in the [tutorial](#tutorial).
For now, suffice to say that `argument` defines a positional argument,
[`many`](#dollar_lambda.Parser.many) allows parsers to be applied
zero or more times, and [`|`](#dollar_lambda.Parser.__or__) expresses alternatives.

Here is the help text:

&gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
usage: [-x X | [Y ...]]

As promised, this succeeds:

&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;)
{&#39;x&#39;: 1}

And this succeeds:

&gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, &#34;3&#34;)
{&#39;y&#39;: [1.0, 2.0, 3.0]}

Again, you would ordinarily provide `parse_args` no arguments and it would get them
from the command line:
&gt;&gt;&gt; parser.TESTING = False
&gt;&gt;&gt; sys.argv[1:] = [&#34;-x&#34;, &#34;1&#34;]  # simulate command line input
&gt;&gt;&gt; p.parse_args()
{&#39;x&#39;: 1}
&gt;&gt;&gt; parser.TESTING = True

# Tutorial

We&#39;ve already seen many of the concepts that power `$λ` in the
[Highlights](#highlights) section. This tutorial will address
these concepts one at a time and expose the reader to some
nuances of usage.

## An example from `argparse`

Many of you are already familiar with `argparse`.
You may even recognize this example from the `argparse` docs:

```
import argparse
parser = argparse.ArgumentParser(description=&#34;calculate X to the power of Y&#34;)
group = parser.add_mutually_exclusive_group()
group.add_argument(&#34;-v&#34;, &#34;--verbose&#34;, action=&#34;store_true&#34;)
group.add_argument(&#34;-q&#34;, &#34;--quiet&#34;, action=&#34;store_true&#34;)
parser.add_argument(&#34;x&#34;, type=int, help=&#34;the base&#34;)
parser.add_argument(&#34;y&#34;, type=int, help=&#34;the exponent&#34;)
args = parser.parse_args()
```

Here is one way to express this logic in `$λ`:

&gt;&gt;&gt; @command(
...     parsers=dict(kwargs=(flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)).optional()),
...     help=dict(x=&#34;the base&#34;, y=&#34;the exponent&#34;),
... )
... def main(x: int, y: int, **kwargs):
...     return dict(x=x, y=y, **kwargs)  # Run program. Return can be whatever.

Here is the help text for this parser:

&gt;&gt;&gt; main(&#34;-h&#34;)
usage: -x X -y Y [--verbose | --quiet]
x: the base
y: the exponent

As indicated, this succeeds given `--verbose`

&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True}

or `--quiet`

&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;quiet&#39;: True}

or neither

&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2}

Ordinarily , we would not feed `main` any arguments, and it would get them from
the command line:

&gt;&gt;&gt; parser.TESTING = False  # False by default but needs to be True for doctests
&gt;&gt;&gt; sys.argv[1:] = [&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;]  # simulate command line input
&gt;&gt;&gt; main()
{&#39;x&#39;: 1, &#39;y&#39;: 2}
&gt;&gt;&gt; parser.TESTING = True

## Equivalent in lower-level syntax
To better understand what is going on here, let&#39;s remove the syntactic sugar:

&gt;&gt;&gt; p = nonpositional(
...     (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)).optional(),
...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
... )
...
&gt;&gt;&gt; def main(x, y, **kwargs):
...     return dict(x=x, y=y, **kwargs)

Now let&#39;s walk through this step by step.

## High-Level Parsers
In the de-sugared implementation there are two different parser constructors:
`flag`, which binds a boolean value to a variable, and `option`, which binds an arbitrary value to a variable.

### `flag`
&gt;&gt;&gt; p = flag(&#34;verbose&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
{&#39;verbose&#39;: True}

By default `flag` fails when it does not receive expected input:
&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose

Alternately, you can set a default value:
&gt;&gt;&gt; flag(&#34;verbose&#34;, default=False).parse_args()
{&#39;verbose&#39;: False}

### `option`
`option` is similar but takes an argument:
By default, `option` expects a single `-` for single-character variable names (as in `-x`),
as opposed to `--` for longer names (as in `--xenophon`):

&gt;&gt;&gt; option(&#34;x&#34;).parse_args(&#34;-x&#34;, &#34;1&#34;)
{&#39;x&#39;: &#39;1&#39;}
&gt;&gt;&gt; option(&#34;xenophon&#34;).parse_args(&#34;--xenophon&#34;, &#34;1&#34;)
{&#39;xenophon&#39;: &#39;1&#39;}

Use the `type` argument to convert the input to a different type:
&gt;&gt;&gt; option(&#34;x&#34;, type=int).parse_args(&#34;-x&#34;, &#34;1&#34;)  # converts &#34;1&#34; to an int
{&#39;x&#39;: 1}

## Parser Combinators
Parser combinators are functions that combine multiple parsers into new, more complex parsers.
Our example uses two such functions: `nonpositional` and [`|`](#dollar_lambda.Parser.__or__).

### [`|`](#dollar_lambda.Parser.__or__)

The [`|`](#dollar_lambda.Parser.__or__) operator is used for alternatives. Specifically, it will try the first parser,
and if that fails, try the second:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;) # flag(&#34;verbose&#34;) fails
{&#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;) # flag(&#34;verbose&#34;) succeeds
{&#39;verbose&#39;: True}

By default one of the two flags would be required to prevent failure:
&gt;&gt;&gt; p.parse_args() # neither flag is provided so this fails
usage: [--verbose | --quiet]
The following arguments are required: --verbose

We can permit the omission of both flags
by using `optional`, as we saw earlier, or we can supply a default value:

&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)).optional().parse_args() # flags fail, but that&#39;s ok
{}
&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;, default=False)).parse_args() # flag(&#34;verbose&#34;) fails but flag(&#34;quiet&#34;, default=False) succeeds
{&#39;quiet&#39;: False}

Users should note that unlike logical &#34;or&#34; but like Python `or`, the [`|`](#dollar_lambda.Parser.__or__) operator is not commutative:

&gt;&gt;&gt; (flag(&#34;verbose&#34;) | argument(&#34;x&#34;)).parse_args(&#34;--verbose&#34;)
{&#39;verbose&#39;: True}

`argument` binds to positional arguments. If it comes first, it will think that `&#34;--verbose&#34;` is
the expression that we want to bind to `x`:

&gt;&gt;&gt; (argument(&#34;x&#34;) | flag(&#34;verbose&#34;)).parse_args(&#34;--verbose&#34;)
{&#39;x&#39;: &#39;--verbose&#39;}

### `nonpositional` and [`+`](#dollar_lambda.Parser.__add__)
`nonpositional` takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:

&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

For just two parsers you can use [`+`](#dollar_lambda.Parser.__add__) instead of `nonpositional`:
&gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

This will not cover all permutations for more than two parsers:
&gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;) + option(&#34;x&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;--quiet&#34;)
usage: --verbose --quiet -x X
Expected &#39;--quiet&#39;. Got &#39;-x&#39;

To see why note the implicit parentheses:
&gt;&gt;&gt; p = (flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;)) + option(&#34;x&#34;)

In order to cover the case where `-x` comes between `--verbose` and `--quiet`,
use `nonpositional`:
&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;), option(&#34;x&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;--quiet&#34;)  # works
{&#39;verbose&#39;: True, &#39;x&#39;: &#39;1&#39;, &#39;quiet&#39;: True}

## Putting it all together
Let&#39;s recall the original example without the syntactic sugar:

&gt;&gt;&gt; p = nonpositional(
...     (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)).optional(),
...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
... )
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)

As we&#39;ve seen, `(flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)).optional()` succeeds on either `--verbose` or `--quiet`
or neither.

`option(&#34;x&#34;, type=int)` succeeds on `-x X`, where `X` is
some integer, binding that integer to the variable `&#34;x&#34;`. Similarly for `option(&#34;y&#34;, type=int)`.

`nonpositional` takes the three parsers:

- `(flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)).optional()`
- `option(&#34;x&#34;, type=int)`
- `option(&#34;y&#34;, type=int)`

and applies them in every order, until some order succeeds.

Applying the syntactic sugar:

&gt;&gt;&gt; @command(
...     parsers=dict(kwargs=(flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)).optional()),
...     help=dict(x=&#34;the base&#34;, y=&#34;the exponent&#34;),
... )
... def main(x: int, y: int, **kwargs):
...     pass  # do work

Here the `parsers` argument reserves a function argument (in this case, `kwargs`)
for a custom parser (in this case, `(flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)).optional()`)
using our lower-level syntax.  The `help` argument
assigns help text to the arguments (in this case `x` and `y`).

## Variations on the example
### Positional arguments
What if we wanted to supply `x` and `y` as positional arguments?

&gt;&gt;&gt; flags = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
&gt;&gt;&gt; p =  option(&#34;x&#34;, type=int) &gt;&gt; option(&#34;y&#34;, type=int) &gt;&gt; flags
&gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
usage: -x X -y Y [--verbose | --quiet]

This introduces a new parser combinator: [`&gt;&gt;`](#dollar_lambda.Parser.__rshift__) which evaluates
parsers in sequence. In this example, it would first evaluate the `option(&#34;x&#34;, type=int)` parser,
and if that succeeded, it would hand the unparsed remainder on to the `option(&#34;y&#34;, type=int)` parser,
and so on until all parsers have been evaluated or no more input remains.
 If any of the parsers fail, the combined parser fails:

&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;)   # succeeds
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;-typo&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;)   # first parser fails
usage: -x X -y Y [--verbose | --quiet]
Expected &#39;-x&#39;. Got &#39;-typo&#39;
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--typo&#34;)   # third parser fails
usage: -x X -y Y [--verbose | --quiet]
Expected &#39;--verbose&#39;. Got &#39;--typo&#39;

Unlike with `nonpositional` in the previous section, [`&gt;&gt;`](#dollar_lambda.Parser.__rshift__) requires the user to provide
arguments in a fixed order:
&gt;&gt;&gt; p.parse_args(&#34;-y&#34;, &#34;2&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;--quiet&#34;)   # fails
usage: -x X -y Y [--verbose | --quiet]
Expected &#39;-x&#39;. Got &#39;-y&#39;

When using positional arguments, it might make sense to drop the `-x` and `-y` flags:
&gt;&gt;&gt; p = argument(&#34;x&#34;, type=int) &gt;&gt; argument(&#34;y&#34;, type=int) &gt;&gt; flags
&gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
usage: X Y [--verbose | --quiet]
&gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, &#34;--quiet&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;quiet&#39;: True}

`argument` will bind input to a variable without checking for any special flag strings like
`-x` or `-y` preceding the input.


### Variable numbers of arguments

What if there was a special argument, `verbosity`,
that only makes sense if the user chooses `--verbose`?

&gt;&gt;&gt; p = nonpositional(
...    ((flag(&#34;verbose&#34;) + option(&#34;verbosity&#34;, type=int)) | flag(&#34;quiet&#34;)),
...    option(&#34;x&#34;, type=int),
...    option(&#34;y&#34;, type=int),
... )

Remember that [`+`](#dollar_lambda.Parser.__add__) evaluates two parsers in both orders
and stopping at the first order that succeeds. So this allows us to
supply `--verbose` and `--verbosity` in any order.

&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbosity&#34;, &#34;3&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;verbosity&#39;: 3}
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
usage: [--verbose --verbosity VERBOSITY | --quiet] -x X -y Y
Expected &#39;--verbose&#39;. Got &#39;-x&#39;

We could express the same logic with the `command` decorator:

&gt;&gt;&gt; @command(
...     parsers=dict(
...         kwargs=flag(&#34;verbose&#34;) + option(&#34;verbosity&#34;, type=int) | flag(&#34;quiet&#34;)
...     ),
...     help=dict(x=&#34;the base&#34;, y=&#34;the exponent&#34;),
... )
... def main(x: int, y: int, **kwargs):
...     pass  # do work

This is also a case where you might want to use `CommandTree`:

&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(help=dict(x=&#34;the base&#34;, y=&#34;the exponent&#34;))
... def base_function(x: int, y: int):
...     pass  # do work
...
&gt;&gt;&gt; @base_function.command()
... def verbose_function(x: int, y: int, verbose: bool, verbosity: int):
...     args = dict(x=x, y=y, verbose=verbose, verbosity=verbosity)
...     print(&#34;invoked verbose_function with args&#34;, args)
...
&gt;&gt;&gt; @base_function.command()
... def quiet_function(x: int, y: int, quiet: bool):
...     pass  # do work
...
&gt;&gt;&gt; tree(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbosity&#34;, &#34;3&#34;)
invoked verbose_function with args {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;verbosity&#39;: 3}

### [`many`](#dollar_lambda.Parser.many)

What if we want to specify verbosity by the number of times that `--verbose` appears?
For this we need `Parser.many`. Before showing how we could use `Parser.many` in this setting,
let&#39;s look at how it works.

`parser.many` takes `parser` and tries to apply it as many times as possible.
`Parser.many` is a bit like the `*` pattern, if you are familiar with regexes.
`parser.many` always succeeds:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)  # still succeeds
{&#39;verbose&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--verbose&#34;)  # succeeds, binding list to &#39;verbose&#39;
{&#39;verbose&#39;: [True, True]}

Now returning to the original example:

&gt;&gt;&gt; p = nonpositional(
...     flag(&#34;verbose&#34;).many(),
...     option(&#34;x&#34;, type=int),
...     option(&#34;y&#34;, type=int),
... )
&gt;&gt;&gt; args = p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbose&#34;)
&gt;&gt;&gt; args
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: [True, True]}
&gt;&gt;&gt; verbosity = len(args[&#39;verbose&#39;])
&gt;&gt;&gt; verbosity
2

### [`many1`](#dollar_lambda.Parser.many1)

In the previous example, the parse will default to `verbosity=0` if no `--verbose` flags
are given.  What if we wanted users to be explicit about choosing a &#34;quiet&#34; setting?
In other words, what if the user actually had to provide an explicit `--quiet` flag when
no `--verbose` flags were given?

For this, we use `Parser.many1`. This method is like `Parser.many` except that it fails
when on zero successes (recall that `Parser.many` always succeeds). So if `Parser.many`
is like regex `*`, `Parser.many1` is like [`+`](#dollar_lambda.Parser.__add__). Take a look:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p = flag(&#34;verbose&#34;).many1()  # note many1(), not many()
&gt;&gt;&gt; p.parse_args()  # fails
usage: --verbose [--verbose ...]
The following arguments are required: --verbose
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)  # succeeds
{&#39;verbose&#39;: True}

To compell that `--quiet` flag from our users, we can do the following:

&gt;&gt;&gt; p = nonpositional(
...    ((flag(&#34;verbose&#34;).many1()) | flag(&#34;quiet&#34;)),
...    option(&#34;x&#34;, type=int),
...    option(&#34;y&#34;, type=int),
... )

Now omitting both `--verbose` and `--quiet` will fail:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)
usage: [--verbose [--verbose ...] | --quiet] -x X -y Y
Expected &#39;--verbose&#39;. Got &#39;-x&#39;
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;) # this succeeds
{&#39;verbose&#39;: True, &#39;x&#39;: 1, &#39;y&#39;: 2}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;) # and this succeeds
{&#39;quiet&#39;: True, &#39;x&#39;: 1, &#39;y&#39;: 2}

# `CommandTree` Tutorial
`CommandTree` has already shown up in the
[Highlights section](#commandtree-for-dynamic-dispatch)
and in the [tutorial](#variations-on-the-example).
In this section we will give a more thorough treatment,
exposing some of the underlying logic and covering all
the variations in functionality that `CommandTree`
offers.

`CommandTree` draws inspiration
from the [`Click`](https://click.palletsprojects.com/) library.
`CommandTree.subcommand` (discussed [here](#commandtreesubcommand)) closely
approximates the functionality described in the [Commands and Groups](https://click.palletsprojects.com/en/8.1.x/commands/#command)
section of the `Click` documentation.

## `CommandTree.command`

First let&#39;s walk through the use of the `CommandTree.command` decorator, one step
at a time. First we define the object:

&gt;&gt;&gt; tree = CommandTree()

Now we define at least one child function:

&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a)) # this can be whatever

`CommandTree.command` automatically converts the function arguments into a parser.
We can run the parser and pass its output to our function `f1` by calling `tree`:

&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A

At this point the parser takes a single option `-a` that binds an `int` to `&#39;a&#39;`:
&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;)
{&#39;f1&#39;: {&#39;a&#39;: 1}}

Usually we would call `tree` with no arguments, and it would get its input from `sys.argv[1:]`.

&gt;&gt;&gt; parser.TESTING = False  # False by default but needs to be true for doctests
&gt;&gt;&gt; sys.argv[1:] = [&#34;-a&#34;, &#34;1&#34;]  # simulate command line input
&gt;&gt;&gt; tree()
{&#39;f1&#39;: {&#39;a&#39;: 1}}
&gt;&gt;&gt; parser.TESTING = True

Now let&#39;s add a second child function:

&gt;&gt;&gt; @tree.command()
... def f2(b: bool):
...     return dict(f2=dict(b=b))  # this can also be whatever

&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: [-a A | -b]

`tree` will execute either `f1` or `f2` based on which of the parsers succeeds.
This will execute `f1`:

&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;)
{&#39;f1&#39;: {&#39;a&#39;: 1}}

This will execute `f2`:

&gt;&gt;&gt; tree(&#34;-b&#34;)
{&#39;f2&#39;: {&#39;b&#39;: True}}

This fails:

&gt;&gt;&gt; tree()
usage: [-a A | -b]
The following arguments are required: -a

Often in cases where there are alternative sets of argument like this,
there is also a set of shared arguments. We can define a parent function
 to make our help text more concise and to allow the user to run the
 parent function when the child arguments are not provided.

&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):  # this will be the parent function
...     return dict(f1=dict(a=a))

Now define a child function, `g1`:

&gt;&gt;&gt; @f1.command()  # note f1, not tree
... def g1(a:int, b: bool):
...     return dict(g1=dict(b=b))

Make sure to include all the arguments of `f1` in `g1` or else
`g1` will fail when it is invoked. In its current state, `tree` sequences
 the arguments of `f1` and `g1`:

&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A -b

As before we can define an additional child function to induce alternative
argument sets:

&gt;&gt;&gt; @f1.command()  # note f1, not tree
... def g2(a: int, c: str):
...     return dict(g2=dict(c=c))

Note that our usage message shows `-a A` preceding the brackets because it corresponds
to the parent function:
&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A [-b | -c C]

To execute `g1`, we give the `-b` flag:
&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;, &#34;-b&#34;)
{&#39;g1&#39;: {&#39;b&#39;: True}}

To execute `g2`, we give the `-c` flag:
&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;, &#34;-c&#34;, &#34;foo&#34;)
{&#39;g2&#39;: {&#39;c&#39;: &#39;foo&#39;}}

Also, note that `tree` can have arbitrary depth:

&gt;&gt;&gt; @g1.command()  # h1 is a child of g1
... def h1(a: int, b: bool, d: float):
...    return dict(h1=dict(d=d))

Note the additional `-d D` argument on the left side of the `|` pipe:

&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A [-b -d D | -c C]

That comes from the third argument of `h1`.

## `CommandTree.subcommand`
Often we want to explicitly specify which function to execute by naming it on the command line.
This would implement functionality similar to
[`ArgumentParser.add_subparsers`](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_subparsers)
or [`Click.command`](https://click.palletsprojects.com/en/8.1.x/commands/#command).

For this we would use the `CommandTree.subcommand` decorator:

&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
...
&gt;&gt;&gt; @f1.subcommand()  # note subcommand, not command
... def g1(a:int, b: bool):
...     return dict(g1=dict(b=b))
...
&gt;&gt;&gt; @f1.subcommand()  # again, subcommand, not command
... def g2(a: int, c: str):
...     return dict(g2=dict(c=c))

Now the usage message indicates that `g1` and `g2` are required arguments:
&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A [g1 -b | g2 -c C]

Now we would select g1 as follows:
&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;, &#34;g1&#34;, &#34;-b&#34;)
{&#39;g1&#39;: {&#39;b&#39;: True}}

And g2 as follows:
&gt;&gt;&gt; tree(&#34;-a&#34;, &#34;1&#34;, &#34;g2&#34;, &#34;-c&#34;, &#34;foo&#34;)
{&#39;g2&#39;: {&#39;c&#39;: &#39;foo&#39;}}

You can freely mix and match `subcommand` and `command`:

&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
...
&gt;&gt;&gt; @f1.subcommand()
... def g1(a:int, b: bool):
...     return dict(g1=dict(b=b))
...
&gt;&gt;&gt; @f1.command()  # note command, not subcommand
... def g2(a: int, c: str):
...     return dict(g2=dict(c=c))

Note that the left side of the pipe (corresponding to the `g1` function)
requires a `&#34;g1&#34;` argument to run but the right side (corresponding to the `g2` function)
does not:

&gt;&gt;&gt; tree(&#34;-h&#34;)
usage: -a A [g1 -b | -c C]

# Use with config files
A common use case is to have a config file with default values that arguments should
fall back to if not provided on the command line. Instead of implementing specific functionality
itself, `$λ` accommodates this situation by simply getting out of the way, thereby affording the
user the most flexibility in terms of accessing and using the config file. Here is a simple example.

```
# example-config.json
.. include:: ../example-config.json
```

Define a parser with optional values where you want to be able to fall back to the config file:
&gt;&gt;&gt; p = option(&#34;x&#34;, type=int).optional() &gt;&gt; argument(&#34;y&#34;, type=int)
&gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
usage: -x X Y

In this example, `-x X` can be omitted, falling back to the config, but the positional argument
`Y` will be required.

Make sure that the optional arguments do not have default values or else the config value will
always be overridden.
Inside main, load the config and update with any arguments provided on the command line:
&gt;&gt;&gt; import json
&gt;&gt;&gt; def main(**kwargs):
...     with open(&#34;example-config.json&#34;) as f:
...         config = json.load(f)
...
...     config.update(kwargs)
...     return config

Override the value in the config by providing an explicit argument:
&gt;&gt;&gt; main(**p.parse_args(&#34;-x&#34;, &#34;0&#34;, &#34;1&#34;))
{&#39;x&#39;: 0, &#39;y&#39;: 1}

Fall back to the value in the config by not providing an argument for `x`:
&gt;&gt;&gt; main(**p.parse_args(&#34;2&#34;))
{&#39;x&#39;: 1, &#39;y&#39;: 2}

We can also write this with `@command` syntax:

&gt;&gt;&gt; @command(
...     parsers=dict(
...         y=argument(&#34;y&#34;, type=int),
...         kwargs=option(&#34;x&#34;, type=int).optional(),
...     )
... )
... def main(y: int, **kwargs):
...     with open(&#34;example-config.json&#34;) as f:
...         config = json.load(f)
...
...     config.update(**kwargs, y=y)
...     return config
&gt;&gt;&gt; main(&#34;-x&#34;, &#34;0&#34;, &#34;1&#34;)  # override config value
{&#39;x&#39;: 0, &#39;y&#39;: 1}
&gt;&gt;&gt; main(2)  # fall back to config value
{&#39;x&#39;: 1, &#39;y&#39;: 2}

# Nesting output
By default introducing a `.` character into the name of an `argument`, `option`, or `flag` will
induce nested output:
&gt;&gt;&gt; argument(&#34;a.b&#34;, type=int).parse_args(&#34;1&#34;)
{&#39;a&#39;: {&#39;b&#39;: 1}}
&gt;&gt;&gt; option(&#34;a.b&#34;, type=int).parse_args(&#34;--a.b&#34;, &#34;1&#34;)
{&#39;a&#39;: {&#39;b&#39;: 1}}
&gt;&gt;&gt; flag(&#34;a.b&#34;).parse_args(&#34;--a.b&#34;)
{&#39;a&#39;: {&#39;b&#39;: True}}

This mechanism handles collisions:
&gt;&gt;&gt; nonpositional(flag(&#34;a.b&#34;), flag(&#34;a.c&#34;)).parse_args(&#34;--a.b&#34;, &#34;--a.c&#34;)
{&#39;a&#39;: {&#39;b&#39;: True, &#39;c&#39;: True}}

even when mixing nested and unnested output:
&gt;&gt;&gt; nonpositional(flag(&#34;a&#34;), flag(&#34;a.b&#34;)).parse_args(&#34;-a&#34;, &#34;--a.b&#34;)
{&#39;a&#39;: [True, {&#39;b&#39;: True}]}

It can also go arbitrarily deep:
&gt;&gt;&gt; nonpositional(flag(&#34;a.b.c&#34;), flag(&#34;a.b.d&#34;)).parse_args(&#34;--a.b.c&#34;, &#34;--a.b.d&#34;)
{&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: True, &#39;d&#39;: True}}}

This behavior can always be disabled by setting `nesting=False` (or just not using `.` in the name).

# Ignoring arguments
There may be cases in which a user wants to provide certain arguments on the
command line that `$λ` should ignore (not return in the output of `Parser.parse_args`
or pass to the a decorated function). Suppose we wish to ignore any arguments starting
with the `--config-` prefix:

&gt;&gt;&gt; regex = r&#34;config-\\S*&#34;
&gt;&gt;&gt; config_parsers = flag(regex) | option(regex)

In the case of ordered arguments, we simply use the `ignore` method:

&gt;&gt;&gt; p = flag(&#34;x&#34;) &gt;&gt; config_parsers.ignore() &gt;&gt; flag(&#34;y&#34;)

This will ignore any argument that starts with `--config-` and comes between `x` and `y`:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;--config-foo&#34;, &#34;-y&#34;)
{&#39;x&#39;: True, &#39;y&#39;: True}

Because of the way we defined `config_parsers`, this also works with `option`:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;--config-bar&#34;, &#34;1&#34;, &#34;-y&#34;)
{&#39;x&#39;: True, &#39;y&#39;: True}

In the case of nonpositional arguments, use the `repeated` keyword:
&gt;&gt;&gt; p = nonpositional(flag(&#34;x&#34;), flag(&#34;y&#34;), repeated=config_parsers.ignore())

Now neither `config-foo` nor `config-bar` show up in the output:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-y&#34;, &#34;--config-foo&#34;, &#34;--config-bar&#34;, &#34;1&#34;)
{&#39;x&#39;: True, &#39;y&#39;: True}

This works regardless of order:
&gt;&gt;&gt; p.parse_args(&#34;--config-baz&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;--config-foz&#34;, &#34;-x&#34;)
{&#39;y&#39;: True, &#39;x&#39;: True}

And no matter how many matches are found:
&gt;&gt;&gt; p.parse_args(
...     &#34;--config-foo&#34;,
...     &#34;1&#34;,
...     &#34;--config-bar&#34;,
...     &#34;-y&#34;,
...     &#34;--config-baz&#34;,
...     &#34;2&#34;,
...     &#34;-x&#34;,
...     &#34;--config-foz&#34;,
... )
{&#39;y&#39;: True, &#39;x&#39;: True}

The same technique can be used with decorators:
&gt;&gt;&gt; @command(repeated=config_parsers.ignore())
... def f(x: bool, y: bool):
...    return dict(x=x, y=y)
&gt;&gt;&gt; f(&#34;-x&#34;, &#34;-y&#34;, &#34;--config-foo&#34;, &#34;--config-bar&#34;, &#34;1&#34;)
{&#39;x&#39;: True, &#39;y&#39;: True}

And similarly with `CommandTree`.

# Why `$λ`?

`$λ` can handle many kinds of argument-parsing patterns
that are either very awkward, difficult, or impossible with other parsing libraries.
In particular, we emphasize the following qualities:

### Versatile
`$λ` provides high-level functionality equivalent to other parsers. But unlike other parsers,
it permits low-level customization to handle arbitrarily complex parsing patterns.
There are many parsing patterns that `$λ` can handle which are not possible with other parsing libraries.

### Type-safe
`$λ` uses type annotations as much as Python allows. Types are checked using [`MyPy`](
https://mypy.readthedocs.io/en/stable/index.html#) and exported with the package so that users can also benefit from
the type system. Furthermore, with rare exceptions, `$λ` avoids mutations and side-effects and preserves [referential
transparency](https://en.wikipedia.org/wiki/Referential_transparency). This makes it easier for the type-checker _and
for the user_ to reason about the code.

### Concise
`$λ` provides many syntactic shortcuts for cutting down boilerplate:

- the `command` decorator and the `CommandTree` object for automatically building parsers from function signatures.
- operators like [`&gt;&gt;`](#dollar_lambda.Parser.__rshift__),
[`|`](#dollar_lambda.Parser.__or__), [`^`](#dollar_lambda.Parser.__xor__),
and [`+`](#dollar_lambda.Parser.__add__) (and [`&gt;=`](#dollar_lambda.Parser.__ge__) if you want to get fancy)

### Lightweight
`$λ` is written in pure python with no dependencies
(excepting [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass)
which was written expressly for this library and has no dependencies).
`$λ` will not introduce dependency conflicts and it installs in a flash.
&#34;&#34;&#34;


__pdoc__ = {}

from dollar_lambda.args import Args, field
from dollar_lambda.decorators import CommandTree, command
from dollar_lambda.parser import (
    Parser,
    apply,
    argument,
    defaults,
    flag,
    item,
    matches,
    nonpositional,
    option,
    sat,
)

__all__ = [
    &#34;Parser&#34;,
    &#34;apply&#34;,
    &#34;argument&#34;,
    &#34;matches&#34;,
    &#34;flag&#34;,
    &#34;item&#34;,
    &#34;nonpositional&#34;,
    &#34;option&#34;,
    &#34;sat&#34;,
    &#34;Args&#34;,
    &#34;defaults&#34;,
    &#34;field&#34;,
    &#34;command&#34;,
    &#34;CommandTree&#34;,
]


__pdoc__[&#34;Parser.__add__&#34;] = True
__pdoc__[&#34;Parser.__or__&#34;] = True
__pdoc__[&#34;Parser.__xor__&#34;] = True
__pdoc__[&#34;Parser.__rshift__&#34;] = True
__pdoc__[&#34;Parser.__ge__&#34;] = True</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="dollar_lambda.args" href="args.html">dollar_lambda.args</a></code></dt>
<dd>
<div class="desc"><p>Defines the <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> dataclass and associated functions.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.decorators" href="decorators.html">dollar_lambda.decorators</a></code></dt>
<dd>
<div class="desc"><p>Defines the <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> decorator and the <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> class.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.error" href="error.html">dollar_lambda.error</a></code></dt>
<dd>
<div class="desc"><p>Defines errors which can be raised by parsers.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code></dt>
<dd>
<div class="desc"><p>Defines parsing functions and the <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> class that they instantiate.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.result" href="result.html">dollar_lambda.result</a></code></dt>
<dd>
<div class="desc"><p>Defines the <code>Result</code> dataclass, representing success or failure, output by parsers.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.sequence" href="sequence.html">dollar_lambda.sequence</a></code></dt>
<dd>
<div class="desc"><p>Defines <code>Sequence</code>, a strongly-typed immutable list that implements <code>MonadPlus</code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dollar_lambda.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>f: Callable[[str], B_monoid], description: str) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~B_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>A shortcut for</p>
<pre><code class="language-python">item(description).apply(f)
</code></pre>
<p>and spares <code>f</code> the trouble of outputting a <code>Result</code> object.
Here is an example of usage. First we define a simple <code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument()</a></code> parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = argument(&quot;foo&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;bar&quot;)
{'foo': 'bar'}
</code></pre>
<p>Here we use <code>f</code> to directly manipulate the binding generated by <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p2 = apply(lambda bar: Output.from_dict(**{bar + &quot;e&quot;: bar + &quot;f&quot;}), description=&quot;baz&quot;)
&gt;&gt;&gt; p2.parse_args(&quot;bar&quot;)
{'bare': 'barf'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L715-L744" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply(f: Callable[[str], B_monoid], description: str) -&gt; Parser[B_monoid]:
    &#34;&#34;&#34;
    A shortcut for
    ```python
    item(description).apply(f)
    ```
    and spares `f` the trouble of outputting a `Result` object.
    Here is an example of usage. First we define a simple `argument` parser:

    &gt;&gt;&gt; p1 = argument(&#34;foo&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;bar&#34;)
    {&#39;foo&#39;: &#39;bar&#39;}

    Here we use `f` to directly manipulate the binding generated by `item`:
    &gt;&gt;&gt; p2 = apply(lambda bar: Output.from_dict(**{bar + &#34;e&#34;: bar + &#34;f&#34;}), description=&#34;baz&#34;)
    &gt;&gt;&gt; p2.parse_args(&#34;bar&#34;)
    {&#39;bare&#39;: &#39;barf&#39;}
    &#34;&#34;&#34;

    def g(out: Output[Sequence[KeyValue[str]]]) -&gt; Result[B_monoid]:
        *_, (_, v) = map(astuple, out.get)
        assert v is not None  # because item produces output
        try:
            y = f(v)
        except Exception as e:
            usage = f&#34;argument {v} raised exception {e}&#34;
            return Result(ArgumentError(usage))
        return Result.return_(y)

    return item(description).apply(g)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.argument"><code class="name flex">
<span>def <span class="ident">argument</span></span>(<span>dest: str, nesting: bool = True, help: Optional[str] = None, type: Optional[Callable[[str], Any]] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a single word and binds it to <code>dest</code>.
Useful for positional arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of variable to bind to:</dd>
<dt><strong><code>nesting</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, then the parser will split the parsed output on <code>.</code> yielding nested output.
See Examples for more details.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The help message to display for the option:</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Optional[Callable[[str], Any]]</code></dt>
<dd>Use the <code>type</code> argument to convert the input to a different type:</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;name&quot;).parse_args(&quot;Dante&quot;)
{'name': 'Dante'}
&gt;&gt;&gt; argument(&quot;name&quot;).parse_args()
**```usage```** :&amp;ensp;&lt;code&gt;NAME&lt;/code&gt;
:   &amp;nbsp;


The following arguments are required: name
</code></pre>
<p>Here are some examples that take advantage of <code>nesting=True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;config.name&quot;).parse_args(&quot;-h&quot;)
**```usage```** :&amp;ensp;&lt;code&gt;CONFIG.NAME&lt;/code&gt;
:   &amp;nbsp;


&gt;&gt;&gt; argument(&quot;config.name&quot;).parse_args(&quot;Dante&quot;)
{'config': {'name': 'Dante'}}
</code></pre>
<p>Of course, you can disable this by setting <code>nesting=False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;config.name&quot;, nesting=False).parse_args(&quot;Dante&quot;)
{'config.name': 'Dante'}
&gt;&gt;&gt; (argument(&quot;config.first.name&quot;) &gt;&gt; argument(&quot;config.last.name&quot;)).parse_args(&quot;Dante&quot;, &quot;Alighieri&quot;)
{'config': {'first': {'name': 'Dante'}, 'last': {'name': 'Alighieri'}}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L747-L799" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def argument(
    dest: str,
    nesting: bool = True,
    help: Optional[str] = None,
    type: Optional[Callable[[str], Any]] = None,
) -&gt; Parser[Output]:
    &#34;&#34;&#34;
    Parses a single word and binds it to `dest`.
    Useful for positional arguments.

    Parameters
    ----------
    dest : str
        The name of variable to bind to:

    nesting : bool
        If `True`, then the parser will split the parsed output on `.` yielding nested output.
        See Examples for more details.

    help : Optional[str]
        The help message to display for the option:

    type : Optional[Callable[[str], Any]]
        Use the `type` argument to convert the input to a different type:

    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args(&#34;Dante&#34;)
    {&#39;name&#39;: &#39;Dante&#39;}
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args()
    usage: NAME
    The following arguments are required: name

    Here are some examples that take advantage of `nesting=True`:
    &gt;&gt;&gt; argument(&#34;config.name&#34;).parse_args(&#34;-h&#34;)
    usage: CONFIG.NAME
    &gt;&gt;&gt; argument(&#34;config.name&#34;).parse_args(&#34;Dante&#34;)
    {&#39;config&#39;: {&#39;name&#39;: &#39;Dante&#39;}}

    Of course, you can disable this by setting `nesting=False`:
    &gt;&gt;&gt; argument(&#34;config.name&#34;, nesting=False).parse_args(&#34;Dante&#34;)
    {&#39;config.name&#39;: &#39;Dante&#39;}
    &gt;&gt;&gt; (argument(&#34;config.first.name&#34;) &gt;&gt; argument(&#34;config.last.name&#34;)).parse_args(&#34;Dante&#34;, &#34;Alighieri&#34;)
    {&#39;config&#39;: {&#39;first&#39;: {&#39;name&#39;: &#39;Dante&#39;}, &#39;last&#39;: {&#39;name&#39;: &#39;Alighieri&#39;}}}
    &#34;&#34;&#34;
    parser = item(dest)
    _type: Callable[[str], Any] = str if type is None else type  # type: ignore[assignment]
    # Mypy doesn&#39;t know that types also have type Callable[[str], Any]
    if _type is not str:
        parser = parser.type(_type)
    if nesting:
        parser = parser.nesting()
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=dest.upper(), helps=helps)
    return parser</code></pre>
</details>
</dd>
<dt id="dollar_lambda.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>flip_bools: bool = True, help: Optional[typing.Dict[str, str]] = None, parsers: Optional[typing.Dict[str, <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output]]] = None, repeated: Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output]] = None) <span style="white-space: nowrap;">-></span> Callable[[Callable], Callable]</span>
</code></dt>
<dd>
<div class="desc"><p>A succinct way to generate a simple <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> parser. <code>@command</code> derives the
component parsers from the function's signature and automatically executes the function with
the parsed arguments, if parsing succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(a=&quot;something about a&quot;))
... def f(a: int = 1, b: bool = False):
...     return dict(a=a, b=b)
&gt;&gt;&gt; f(&quot;-a&quot;, &quot;2&quot;, &quot;-b&quot;)
{'a': 2, 'b': True}
</code></pre>
<p>If the wrapped function receives no arguments (as in <code>f()</code>), the parser will take
<code>sys.argv[1:]</code> as the input.</p>
<p>Note that <code>@command</code> does not handle mutually exclusive arguments or alternative
arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>For boolean arguments that default to true, this changes the flag from <code>--{dest}</code> to <code>--no-{dest}</code>:</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>A dictionary of help strings for the arguments.</dd>
<dt><strong><code>repeated</code></strong> :&ensp;<code>Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[KeyValue[Any]]]]</code></dt>
<dd>If provided, this parser gets applied repeatedly (zero or more times) at all positions.</dd>
<dt><strong><code>strings</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>This dictionary maps variable names to the strings that the parser will look for in the input.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command()
... def f(cuda: bool = True):
...     return dict(cuda=cuda)
&gt;&gt;&gt; f()
{'cuda': True}
&gt;&gt;&gt; f(&quot;--no-cuda&quot;)  # flip_bools adds --no- to the flag
{'cuda': False}
</code></pre>
<p>As the following example demonstrates, when <code>flip_bools=False</code> output can be somewhat confusing:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(flip_bools=False)
... def f(cuda: bool = True):
...     return dict(cuda=cuda)
&gt;&gt;&gt; f(&quot;--cuda&quot;)
{'cuda': False}
</code></pre>
<p>Here is an example using the <code>help</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(quiet=&quot;Be quiet&quot;))
... def f(quiet: bool):
...     return dict(quiet=quiet)
&gt;&gt;&gt; f(&quot;--help&quot;)
usage: --quiet
quiet: Be quiet
</code></pre>
<p>Here is an example using the <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> parameter:</p>
<p>TODO!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/decorators.py#L58-L147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def command(
    flip_bools: bool = True,
    help: Optional[typing.Dict[str, str]] = None,
    parsers: Optional[typing.Dict[str, Parser[Output]]] = None,
    repeated: Optional[Parser[Output]] = None,
) -&gt; Callable[[Callable], Callable]:
    &#34;&#34;&#34;
    A succinct way to generate a simple `nonpositional` parser. `@command` derives the
    component parsers from the function&#39;s signature and automatically executes the function with
    the parsed arguments, if parsing succeeds:

    &gt;&gt;&gt; @command(help=dict(a=&#34;something about a&#34;))
    ... def f(a: int = 1, b: bool = False):
    ...     return dict(a=a, b=b)
    &gt;&gt;&gt; f(&#34;-a&#34;, &#34;2&#34;, &#34;-b&#34;)
    {&#39;a&#39;: 2, &#39;b&#39;: True}

    If the wrapped function receives no arguments (as in `f()`), the parser will take
    `sys.argv[1:]` as the input.

    Note that `@command` does not handle mutually exclusive arguments or alternative
    arguments.

    Parameters
    ----------
    flip_bools : bool
        For boolean arguments that default to true, this changes the flag from `--{dest}` to `--no-{dest}`:

    help : dict[str, str]
        A dictionary of help strings for the arguments.

    repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
        If provided, this parser gets applied repeatedly (zero or more times) at all positions.

    strings : dict[str, str]
        This dictionary maps variable names to the strings that the parser will look for in the input.

    Examples
    --------

    &gt;&gt;&gt; @command()
    ... def f(cuda: bool = True):
    ...     return dict(cuda=cuda)
    &gt;&gt;&gt; f()
    {&#39;cuda&#39;: True}
    &gt;&gt;&gt; f(&#34;--no-cuda&#34;)  # flip_bools adds --no- to the flag
    {&#39;cuda&#39;: False}

    As the following example demonstrates, when `flip_bools=False` output can be somewhat confusing:

    &gt;&gt;&gt; @command(flip_bools=False)
    ... def f(cuda: bool = True):
    ...     return dict(cuda=cuda)
    &gt;&gt;&gt; f(&#34;--cuda&#34;)
    {&#39;cuda&#39;: False}

    Here is an example using the `help` parameter:

    &gt;&gt;&gt; @command(help=dict(quiet=&#34;Be quiet&#34;))
    ... def f(quiet: bool):
    ...     return dict(quiet=quiet)
    &gt;&gt;&gt; f(&#34;--help&#34;)
    usage: --quiet
    quiet: Be quiet

    Here is an example using the `parser` parameter:

    TODO!
    &#34;&#34;&#34;

    def wrapper(func: Callable) -&gt; Callable:
        p = _func_to_parser(
            func,
            exclude=None,
            flip_bools=flip_bools,
            help=help,
            parsers=parsers,
            repeated=repeated,
        )
        p = p.wrap_help()

        def wrapped(*args) -&gt; Any:
            parsed = p.parse_args(*args)
            if parsed is None:
                return
            return func(**parsed)

        return wrapped

    return wrapper</code></pre>
</details>
</dd>
<dt id="dollar_lambda.defaults"><code class="name flex">
<span>def <span class="ident">defaults</span></span>(<span>**kwargs: A) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[~A]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Useful for assigning default values to arguments.
It ignore the input and always returns <code>kwargs</code> converted into <code>CollisionDict</code>.
<code><a title="dollar_lambda.defaults" href="#dollar_lambda.defaults">defaults()</a></code> never failsekpoi</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; defaults(a=1, b=2).parse_args()
{'a': 1, 'b': 2}
&gt;&gt;&gt; (flag(&quot;fails&quot;) | defaults(fails=&quot;succeeds&quot;)).parse_args()
{'fails': 'succeeds'}
</code></pre>
<p>Here's a more complex example derived from the tutorial:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (
...         flag(&quot;verbose&quot;) + defaults(quiet=False)  # either --verbose and default &quot;quiet&quot; to False
...         | flag(&quot;quiet&quot;) + defaults(verbose=False)  # or --quiet and default &quot;verbose&quot; to False
...     ),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... )
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'quiet': False}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L802-L829" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def defaults(**kwargs: A) -&gt; Parser[Output[Sequence[KeyValue[A]]]]:
    &#34;&#34;&#34;
    Useful for assigning default values to arguments.
    It ignore the input and always returns `kwargs` converted into `CollisionDict`.
    `defaults` never failsekpoi

    &gt;&gt;&gt; defaults(a=1, b=2).parse_args()
    {&#39;a&#39;: 1, &#39;b&#39;: 2}
    &gt;&gt;&gt; (flag(&#34;fails&#34;) | defaults(fails=&#34;succeeds&#34;)).parse_args()
    {&#39;fails&#39;: &#39;succeeds&#39;}

    Here&#39;s a more complex example derived from the tutorial:
    &gt;&gt;&gt; p = nonpositional(
    ...     (
    ...         flag(&#34;verbose&#34;) + defaults(quiet=False)  # either --verbose and default &#34;quiet&#34; to False
    ...         | flag(&#34;quiet&#34;) + defaults(verbose=False)  # or --quiet and default &#34;verbose&#34; to False
    ...     ),
    ...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
    ...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
    ... )

    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
    {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}
    &#34;&#34;&#34;
    p = Parser[Output[A_monoid]].return_(
        Output[Sequence[KeyValue[A]]].from_dict(**kwargs)
    )
    return replace(p, usage=None)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.field"><code class="name flex">
<span>def <span class="ident">field</span></span>(<span>help: Optional[str] = None, metadata: Optional[dict] = None, parser: Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output]] = None, **kwargs) <span style="white-space: nowrap;">-></span> dataclasses.Field</span>
</code></dt>
<dd>
<div class="desc"><p>This is a thin wrapper around <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.field</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>help</code></strong> :&ensp;<code>str</code></dt>
<dd>An optional help string for the argument.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>str</code></dt>
<dd>Identical to the <code>metadata</code> argument for <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.field</code></a>.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Optional[type | Callable[[str], Any]]</code></dt>
<dd>A function that takes a string and returns a value just like the <code>type</code> argument for
<a href="https://docs.python.org/3/library/argparse.html#type"><code>ArgumentParser.add_argument</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>dataclasses.Field</code> object that can be used in place of a default argument as
described in the <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.Field</code> documentation</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/args.py#L15-L46" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def field(
    help: Optional[str] = None,
    metadata: Optional[dict] = None,
    parser: Optional[Parser[Output]] = None,
    **kwargs,
) -&gt; Field:
    &#34;&#34;&#34;
    This is a thin wrapper around [`dataclasses.field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).

    Parameters
    ----------
    help : str
        An optional help string for the argument.
    metadata : str
        Identical to the `metadata` argument for [`dataclasses.field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).
    type : Optional[type | Callable[[str], Any]]
        A function that takes a string and returns a value just like the `type` argument for
        [`ArgumentParser.add_argument`](https://docs.python.org/3/library/argparse.html#type).

    Returns
    -------
    A `dataclasses.Field` object that can be used in place of a default argument as
    described in the [`dataclasses.Field` documentation](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).

    &#34;&#34;&#34;
    if metadata is None:
        metadata = {}
    if parser is not None:
        metadata.update(parser=parser)
    if help is not None:
        metadata.update(help=help)
    return dataclasses.field(metadata=metadata, **kwargs)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.flag"><code class="name flex">
<span>def <span class="ident">flag</span></span>(<span>dest: str, default: Optional[bool] = None, help: Optional[str] = None, nesting: bool = True, regex: bool = True, short: bool = True, string: Optional[str] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[bool]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Binds a boolean value to a variable.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>The variable to which the value will be bound.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>An optional default value.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>An optional help string.</dd>
<dt><strong><code>nesting</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, then the parser will split the parsed output on <code>.</code> yielding nested output.
See Examples for more details.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, then the parser will use a regex to match the flag string.</dd>
<dt><strong><code>short</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to check for the short form of the flag, which
uses a single dash and the first character of <code>dest</code>, e.g. <code>-f</code> for <code>foo</code>.</dd>
<dt><strong><code>string</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>A custom string to use for the flag. Defaults to <code>--{dest}</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Here is an example using the <code>default</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;, default=False)
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: --verbose
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args()
{'verbose': False}
</code></pre>
<p>By default <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> fails when it does not receive expected input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose
</code></pre>
<p>Here is an example using the <code>help</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;, help=&quot;Turn on verbose output.&quot;)
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: --verbose
verbose: Turn on verbose output.
</code></pre>
<p>Here is an example using the <code>short</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;, short=True).parse_args(&quot;-v&quot;)  # this is the default
{'verbose': True}
&gt;&gt;&gt; flag(&quot;verbose&quot;, short=False).parse_args(&quot;-v&quot;)  # fails
usage: --verbose
Expected '--verbose'. Got '-v'
</code></pre>
<p>Here is an example using the <code>string</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;value&quot;, string=&quot;v&quot;).parse_args(&quot;v&quot;)  # note that string does not have to start with -
{'value': True}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;config.value&quot;).parse_args(&quot;--config.value&quot;)
{'config': {'value': True}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L832-L940" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flag(
    dest: str,
    default: Optional[bool] = None,
    help: Optional[str] = None,
    nesting: bool = True,
    regex: bool = True,
    short: bool = True,
    string: Optional[str] = None,
) -&gt; Parser[Output[Sequence[KeyValue[bool]]]]:
    &#34;&#34;&#34;
    Binds a boolean value to a variable.

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}


    Parameters
    ----------
    dest : str
        The variable to which the value will be bound.

    default : Optional[bool]
        An optional default value.

    help : Optional[str]
        An optional help string.

    nesting : bool
        If `True`, then the parser will split the parsed output on `.` yielding nested output.
        See Examples for more details.

    regex : bool
        If `True`, then the parser will use a regex to match the flag string.

    short : bool
        Whether to check for the short form of the flag, which
        uses a single dash and the first character of `dest`, e.g. `-f` for `foo`.

    string : Optional[str]
        A custom string to use for the flag. Defaults to `--{dest}`.

    Examples
    --------

    Here is an example using the `default` parameter:

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, default=False)
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --verbose

    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False}

    By default `flag` fails when it does not receive expected input:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args()
    usage: --verbose
    The following arguments are required: --verbose

    Here is an example using the `help` parameter:

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, help=&#34;Turn on verbose output.&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --verbose
    verbose: Turn on verbose output.

    Here is an example using the `short` parameter:

    &gt;&gt;&gt; flag(&#34;verbose&#34;, short=True).parse_args(&#34;-v&#34;)  # this is the default
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; flag(&#34;verbose&#34;, short=False).parse_args(&#34;-v&#34;)  # fails
    usage: --verbose
    Expected &#39;--verbose&#39;. Got &#39;-v&#39;

    Here is an example using the `string` parameter:

    &gt;&gt;&gt; flag(&#34;value&#34;, string=&#34;v&#34;).parse_args(&#34;v&#34;)  # note that string does not have to start with -
    {&#39;value&#39;: True}

    &gt;&gt;&gt; flag(&#34;config.value&#34;).parse_args(&#34;--config.value&#34;)
    {&#39;config&#39;: {&#39;value&#39;: True}}
    &#34;&#34;&#34;
    if string is None:
        _string = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _string = string

    def f(
        cs: Sequence[str],
        s: str,
    ) -&gt; Result[Parse[Output[Sequence[KeyValue[bool]]]]]:
        _defaults = defaults(**{dest: not default})
        if nesting:
            _defaults = _defaults.nesting()

        parser = matches(s, regex=regex) &gt;= (lambda _: _defaults)
        return parser.parse(cs)

    parser = Parser(partial(f, s=_string), usage=None, helps={})
    if string is None and short and len(dest) &gt; 1:
        short_string = f&#34;-{dest[0]}&#34;
        parser2 = flag(dest, short=False, string=short_string, default=default)
        parser = parser | parser2
    if default:
        help = f&#34;{help + &#39; &#39; if help else &#39;&#39;}(default: {default})&#34;
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=_string, helps=helps)
    return parser if default is None else parser | defaults(**{dest: default})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.item"><code class="name flex">
<span>def <span class="ident">item</span></span>(<span>name: str, usage_name: Optional[str] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[str]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a single word and binds it to <code>dest</code>.
One of the lowest level building blocks for parsers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>usage_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Used for generating usage text</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = item(&quot;name&quot;, usage_name=&quot;Your first name&quot;)
&gt;&gt;&gt; p.parse_args(&quot;Alice&quot;)
{'name': 'Alice'}
&gt;&gt;&gt; p.parse_args()
usage: name
The following arguments are required: Your first name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L955-L999" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def item(
    name: str,
    usage_name: Optional[str] = None,
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    &#34;&#34;&#34;
    Parses a single word and binds it to `dest`.
    One of the lowest level building blocks for parsers.

    Parameters
    ----------
    usage_name : Optional[str]
        Used for generating usage text

    Examples
    --------

    &gt;&gt;&gt; p = item(&#34;name&#34;, usage_name=&#34;Your first name&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; p.parse_args()
    usage: name
    The following arguments are required: Your first name
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[Output[Sequence[KeyValue[str]]]]]:
        if cs:
            head, *tail = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Output[Sequence[KeyValue[str]]].from_dict(
                            **{name: head}
                        ),
                        unparsed=Sequence(tail),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {usage_name or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.matches"><code class="name flex">
<span>def <span class="ident">matches</span></span>(<span>s: str, peak: bool = False, regex: bool = True) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[str]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the next word is <code>s</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; matches(&quot;hello&quot;).parse_args(&quot;hello&quot;)
{'hello': 'hello'}
&gt;&gt;&gt; matches(&quot;hello&quot;).parse_args(&quot;goodbye&quot;)
usage: hello
Expected 'hello'. Got 'goodbye'
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>The word to that input will be checked against for equality.</dd>
<dt><strong><code>peak</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>False</code>, then the parser will consume the word and return the remaining words as <code>unparsed</code>.
If <code>True</code>, then the parser leaves the <code>unparsed</code> component unchanged.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to treat <code>s</code> as a regular expression. If <code>False</code>, then the parser will only succeed on
string equality.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = matches(&quot;hello&quot;) &gt;&gt; matches(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
{'hello': 'hello', 'goodbye': 'goodbye'}
</code></pre>
<p>Look what happens when <code>peak=True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = matches(&quot;hello&quot;, peak=True) &gt;&gt; matches(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
usage: hello goodbye
Expected 'goodbye'. Got 'hello'
</code></pre>
<p>The first parser didn't consume the word and so "hello" got passed on to <code>equals("goodbye")</code>.
But this would work:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = matches(&quot;hello&quot;, peak=True) &gt;&gt; matches(&quot;hello&quot;) &gt;&gt; matches(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
{'hello': ['hello', 'hello'], 'goodbye': 'goodbye'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L1002-L1067" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def matches(
    s: str, peak: bool = False, regex: bool = True
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    &#34;&#34;&#34;
    Checks if the next word is `s`.

    &gt;&gt;&gt; matches(&#34;hello&#34;).parse_args(&#34;hello&#34;)
    {&#39;hello&#39;: &#39;hello&#39;}
    &gt;&gt;&gt; matches(&#34;hello&#34;).parse_args(&#34;goodbye&#34;)
    usage: hello
    Expected &#39;hello&#39;. Got &#39;goodbye&#39;

    Parameters
    ----------
    s: str
        The word to that input will be checked against for equality.
    peak : bool
        If `False`, then the parser will consume the word and return the remaining words as `unparsed`.
        If `True`, then the parser leaves the `unparsed` component unchanged.

    regex : bool
        Whether to treat `s` as a regular expression. If `False`, then the parser will only succeed on
        string equality.

    Examples
    --------

    &gt;&gt;&gt; p = matches(&#34;hello&#34;) &gt;&gt; matches(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    {&#39;hello&#39;: &#39;hello&#39;, &#39;goodbye&#39;: &#39;goodbye&#39;}

    Look what happens when `peak=True`:
    &gt;&gt;&gt; p = matches(&#34;hello&#34;, peak=True) &gt;&gt; matches(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    usage: hello goodbye
    Expected &#39;goodbye&#39;. Got &#39;hello&#39;

    The first parser didn&#39;t consume the word and so &#34;hello&#34; got passed on to `equals(&#34;goodbye&#34;)`.
    But this would work:
    &gt;&gt;&gt; p = matches(&#34;hello&#34;, peak=True) &gt;&gt; matches(&#34;hello&#34;) &gt;&gt; matches(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    {&#39;hello&#39;: [&#39;hello&#39;, &#39;hello&#39;], &#39;goodbye&#39;: &#39;goodbye&#39;}
    &#34;&#34;&#34;

    def predicate(_s: str) -&gt; bool:
        if regex:
            return bool(re.match(s, _s))
        else:
            return s == _s

    if peak:
        return sat_peak(
            predicate=predicate,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )
    else:
        return sat(
            predicate=predicate,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.nonpositional"><code class="name flex">
<span>def <span class="ident">nonpositional</span></span>(<span>*parsers: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]'", max: int = 80, repeated: Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>max</code></strong> :&ensp;<code>int</code></dt>
<dd>Limits the number of times <code>repeated</code> is applied in order to prevent <code>RecursionError</code>s.
The default for this can be increased by either setting <code>parser.MAX_MANY</code> or
the environment variable <code>DOLLAR_LAMBDA_MAX_MANY</code>.</dd>
<dt><strong><code>repeated</code></strong> :&ensp;<code>Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]]]</code></dt>
<dd>If provided, this parser gets applied repeatedly (zero or more times) at all positions.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(repeated=flag(&quot;x&quot;))
&gt;&gt;&gt; p.parse_args()
{}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;)
{'x': True}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-x&quot;)
{'x': [True, True]}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;y&quot;), repeated=flag(&quot;x&quot;))
&gt;&gt;&gt; p.parse_args(&quot;-y&quot;)
{'y': True}
&gt;&gt;&gt; p.parse_args(&quot;-y&quot;, &quot;-x&quot;)
{'y': True, 'x': True}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-y&quot;)
{'x': True, 'y': True}
&gt;&gt;&gt; p.parse_args(&quot;-y&quot;, &quot;-x&quot;, &quot;-x&quot;)
{'y': True, 'x': [True, True]}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-y&quot;, &quot;-x&quot;)
{'x': [True, True], 'y': True}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-x&quot;, &quot;-y&quot;)
{'x': [True, True], 'y': True}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;y&quot;), repeated=(flag(&quot;x&quot;) | flag(&quot;z&quot;)).ignore())
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-y&quot;, &quot;-z&quot;)
{'y': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L1070-L1153" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nonpositional(
    *parsers: &#34;Parser[Output[A_monoid]]&#34;,
    max: int = MAX_MANY,
    repeated: Optional[Parser[Output[A_monoid]]] = None,
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    `nonpositional` takes a sequence of parsers as arguments and attempts all permutations of them,
    returning the first permutations that is successful:

    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
    {&#39;verbose&#39;: True, &#39;quiet&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
    {&#39;quiet&#39;: True, &#39;verbose&#39;: True}

    Parameters
    ----------
    max: int
        Limits the number of times `repeated` is applied in order to prevent `RecursionError`s.
        The default for this can be increased by either setting `parser.MAX_MANY` or
        the environment variable `DOLLAR_LAMBDA_MAX_MANY`.

    repeated : Optional[Parser[Sequence[A]]]
        If provided, this parser gets applied repeatedly (zero or more times) at all positions.

    Examples
    --------
    &gt;&gt;&gt; p = nonpositional(repeated=flag(&#34;x&#34;))
    &gt;&gt;&gt; p.parse_args()
    {}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;)
    {&#39;x&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-x&#34;)
    {&#39;x&#39;: [True, True]}

    &gt;&gt;&gt; p = nonpositional(flag(&#34;y&#34;), repeated=flag(&#34;x&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;-y&#34;)
    {&#39;y&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-y&#34;, &#34;-x&#34;)
    {&#39;y&#39;: True, &#39;x&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-y&#34;)
    {&#39;x&#39;: True, &#39;y&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-y&#34;, &#34;-x&#34;, &#34;-x&#34;)
    {&#39;y&#39;: True, &#39;x&#39;: [True, True]}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-y&#34;, &#34;-x&#34;)
    {&#39;x&#39;: [True, True], &#39;y&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-x&#34;, &#34;-y&#34;)
    {&#39;x&#39;: [True, True], &#39;y&#39;: True}

    &gt;&gt;&gt; p = nonpositional(flag(&#34;y&#34;), repeated=(flag(&#34;x&#34;) | flag(&#34;z&#34;)).ignore())
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-y&#34;, &#34;-z&#34;)
    {&#39;y&#39;: True}
    &#34;&#34;&#34;
    sep = &#34; &#34; if len(parsers) &lt;= 3 else &#34;\n&#34;
    _parsers = [*parsers] if repeated is None else [*parsers, repeated]
    usage = sep.join([p.usage or &#34;&#34; for p in _parsers])
    repeat_parser = None
    if repeated is not None and max &gt; 0:
        _repeated = repeated  # for mypy&#39;s benefit

        def f(cs: Sequence[str]):
            p = _repeated &gt;&gt; nonpositional(*parsers, repeated=repeated, max=max - 1)
            return p.parse(cs)

        repeat_parser = Parser(f, usage=None, helps={})

    if not parsers:
        if repeat_parser is None:
            return Parser[Output[A_monoid]].empty()
        else:
            return repeat_parser | Parser[Output[A_monoid]].empty()

    def get_alternatives():
        if repeat_parser is not None:
            yield repeat_parser
        for i, head in enumerate(parsers):
            tail = [p for j, p in enumerate(parsers) if j != i]
            yield head &gt;&gt; nonpositional(*tail, repeated=repeated, max=max)

    parser = reduce(operator.or_, get_alternatives())
    helps = parser.helps
    if repeated is not None:
        helps = {**helps, **repeated.helps}
    return replace(parser, usage=usage, helps=helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.option"><code class="name flex">
<span>def <span class="ident">option</span></span>(<span>dest: str, default: Any = None, flag: Optional[str] = None, help: Optional[str] = None, nesting: bool = True, regex: bool = True, short: bool = True, type: Callable[[str], Any] = builtins.str) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[typing.Any]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses two words, binding the second to the first.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of variable to bind to:</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>The default value to bind on failure:</dd>
<dt><strong><code>flag</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The flag to use for the option. If not provided, defaults to <code>--{dest}</code>.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The help message to display for the option:</dd>
<dt><strong><code>nesting</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, then the parser will split the parsed output on <code>.</code> yielding nested output.
See Examples for more details.</dd>
<dt><strong><code>regex</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, then the parser will match the flag string as a regex.</dd>
<dt><strong><code>short</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to check for the short form of the flag, which
uses a single dash and the first character of <code>dest</code>, e.g. <code>-c</code> for <code>count</code>.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Callable[[str], Any]</code></dt>
<dd>Use the <code>type</code> argument to convert the input to a different type:</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;).parse_args(&quot;--count&quot;, &quot;1&quot;)
{'count': '1'}
</code></pre>
<p>In this example, you can see that the <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> parameter allows the user to
specify an arbitrary lead string, including one that doesn't start with a dash.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, flag=&quot;ct&quot;).parse_args(&quot;ct&quot;, &quot;1&quot;)
{'count': '1'}
</code></pre>
<p>This example demonstrates the use of the <code>default</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = option(&quot;count&quot;, default=2)
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: --count COUNT
count: (default: 2)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args()
{'count': 2}
</code></pre>
<p>Here we specify a help-string using the <code>help</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, help=&quot;The number we should count to&quot;).parse_args(&quot;-h&quot;)
usage: --count COUNT
count: The number we should count to
</code></pre>
<p>This example demonstrates the difference between <code>short=True</code> and <code>short=False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, short=True).parse_args(&quot;-c&quot;, &quot;1&quot;)
{'count': '1'}
&gt;&gt;&gt; option(&quot;count&quot;, short=False).parse_args(&quot;-c&quot;, &quot;1&quot;)
usage: --count COUNT
Expected '--count'. Got '-c'
</code></pre>
<p>As with <a href="https://docs.python.org/3/library/argparse.html#argument-parsing">argparse</a>,
the <code>type</code> argument allows you to convert the input to a different type using a
function that takes a single string argument:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;, type=int).parse_args(&quot;-x&quot;, &quot;1&quot;)  # converts &quot;1&quot; to an int
{'x': 1}
&gt;&gt;&gt; option(&quot;x&quot;, type=lambda x: int(x) + 1).parse_args(&quot;-x&quot;, &quot;1&quot;)
{'x': 2}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;config.x&quot;).parse_args(&quot;--config.x&quot;, &quot;a&quot;)
{'config': {'x': 'a'}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L1156-L1268" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def option(
    dest: str,
    default: Any = None,
    flag: Optional[str] = None,
    help: Optional[str] = None,
    nesting: bool = True,
    regex: bool = True,
    short: bool = True,
    type: Callable[[str], Any] = str,
) -&gt; Parser[Output[Sequence[KeyValue[Any]]]]:
    &#34;&#34;&#34;
    Parses two words, binding the second to the first.

    Parameters
    ----------
    dest : str
        The name of variable to bind to:

    default : Optional[Any]
        The default value to bind on failure:

    flag : Optional[str]
        The flag to use for the option. If not provided, defaults to `--{dest}`.

    help : Optional[str]
        The help message to display for the option:

    nesting : bool
        If `True`, then the parser will split the parsed output on `.` yielding nested output.
        See Examples for more details.

    regex : bool
        If `True`, then the parser will match the flag string as a regex.

    short : bool
        Whether to check for the short form of the flag, which
        uses a single dash and the first character of `dest`, e.g. `-c` for `count`.

    type : Callable[[str], Any]
        Use the `type` argument to convert the input to a different type:

    Examples
    --------

    &gt;&gt;&gt; option(&#34;count&#34;).parse_args(&#34;--count&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}

    In this example, you can see that the `flag` parameter allows the user to
    specify an arbitrary lead string, including one that doesn&#39;t start with a dash.

    &gt;&gt;&gt; option(&#34;count&#34;, flag=&#34;ct&#34;).parse_args(&#34;ct&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}

    This example demonstrates the use of the `default` parameter:

    &gt;&gt;&gt; p = option(&#34;count&#34;, default=2)
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --count COUNT
    count: (default: 2)


    &gt;&gt;&gt; p.parse_args()
    {&#39;count&#39;: 2}

    Here we specify a help-string using the `help` parameter:

    &gt;&gt;&gt; option(&#34;count&#34;, help=&#34;The number we should count to&#34;).parse_args(&#34;-h&#34;)
    usage: --count COUNT
    count: The number we should count to

    This example demonstrates the difference between `short=True` and `short=False`:

    &gt;&gt;&gt; option(&#34;count&#34;, short=True).parse_args(&#34;-c&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}
    &gt;&gt;&gt; option(&#34;count&#34;, short=False).parse_args(&#34;-c&#34;, &#34;1&#34;)
    usage: --count COUNT
    Expected &#39;--count&#39;. Got &#39;-c&#39;

    As with [argparse](https://docs.python.org/3/library/argparse.html#argument-parsing),
    the `type` argument allows you to convert the input to a different type using a
    function that takes a single string argument:

    &gt;&gt;&gt; option(&#34;x&#34;, type=int).parse_args(&#34;-x&#34;, &#34;1&#34;)  # converts &#34;1&#34; to an int
    {&#39;x&#39;: 1}
    &gt;&gt;&gt; option(&#34;x&#34;, type=lambda x: int(x) + 1).parse_args(&#34;-x&#34;, &#34;1&#34;)
    {&#39;x&#39;: 2}

    &gt;&gt;&gt; option(&#34;config.x&#34;).parse_args(&#34;--config.x&#34;, &#34;a&#34;)
    {&#39;config&#39;: {&#39;x&#39;: &#39;a&#39;}}
    &#34;&#34;&#34;

    if flag is None:
        _flag = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _flag = flag

    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Output[Sequence[KeyValue[str]]]]]:
        parser = matches(_flag, regex=regex) &gt;= (
            lambda _: argument(dest, nesting=nesting, type=type)
        )
        return parser.parse(cs)

    parser = Parser(f, usage=None, helps={})
    if flag is None and short and len(dest) &gt; 1:
        parser2 = option(dest=dest, short=False, flag=f&#34;-{dest[0]}&#34;, default=None)
        parser = parser | parser2
    if default:
        help = f&#34;{help + &#39; &#39; if help else &#39;&#39;}(default: {default})&#34;
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=f&#34;{_flag} {dest.upper()}&#34;, helps=helps)
    return parser if default is None else parser | defaults(**{dest: default})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.sat"><code class="name flex">
<span>def <span class="ident">sat</span></span>(<span>predicate: Callable[[str], bool], on_fail: Callable[[str], ArgumentError], name: str) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[str]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code><a title="dollar_lambda.Parser.sat" href="#dollar_lambda.Parser.sat">Parser.sat()</a></code> that uses <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code> to parse the argument and just applies <code>predicate</code> to the value output by <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = sat(lambda x: len(x) == 1, lambda x: ArgumentError(f&quot;'{x}' must have exactly one character.&quot;), &quot;x&quot;)
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)  # succeeds
{'x': 'a'}
&gt;&gt;&gt; p.parse_args(&quot;aa&quot;)  # fails
usage: x
'aa' must have exactly one character.
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Callable[[A], bool]</code></dt>
<dd>The predicate to apply to the result of <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code>. <code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat()</a></code> fails if this predicate returns false.</dd>
<dt><strong><code>on_fail</code></strong> :&ensp;<code>Callable[[A], ArgumentError]</code></dt>
<dd>A function producing an ArgumentError to return if the predicate fails.
Takes the output of <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code> as an argument.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The value to bind the result to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L1300-L1334" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sat(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Output[Sequence[KeyValue[str]]]]:
    &#34;&#34;&#34;
    A wrapper around `Parser.sat` that uses `item` to parse the argument and just applies `predicate` to the value output by `item`.

    &gt;&gt;&gt; p = sat(lambda x: len(x) == 1, lambda x: ArgumentError(f&#34;&#39;{x}&#39; must have exactly one character.&#34;), &#34;x&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)  # succeeds
    {&#39;x&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;aa&#34;)  # fails
    usage: x
    &#39;aa&#39; must have exactly one character.

    Parameters
    ----------
    predicate : Callable[[A], bool]
        The predicate to apply to the result of `item`. `sat` fails if this predicate returns false.
    on_fail : Callable[[A], ArgumentError]
        A function producing an ArgumentError to return if the predicate fails.
        Takes the output of `item` as an argument.
    name: str
        The value to bind the result to.
    &#34;&#34;&#34;

    def _predicate(out: Output[Sequence[KeyValue[str]]]) -&gt; bool:
        *_, (_, v) = map(astuple, out.get)
        return predicate(v)

    def _on_fail(out: Output[Sequence[KeyValue[str]]]) -&gt; ArgumentError:
        *_, (_, v) = map(astuple, out.get)
        return on_fail(v)

    return item(name).sat(_predicate, _on_fail)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dollar_lambda.Args"><code class="flex name class">
<span>class <span class="ident">Args</span></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> is sugar for the <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> function and removes much of the boilerplate
from defining parsers with many arguments.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     verbose: bool
...     count: int
&gt;&gt;&gt; MyArgs.parse_args(&quot;--verbose&quot;, &quot;--count&quot;, &quot;1&quot;)
{'verbose': True, 'count': 1}
</code></pre>
<p><code>MyArgs</code> will accept these arguments in any order:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--count&quot;, &quot;1&quot;, &quot;--verbose&quot;)
{'count': 1, 'verbose': True}
</code></pre>
<p>Note that when the default value of an argument is <code>True</code>, <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> will, by default
add <code>--no-</code> to the front of the flag (while still assigning the value to the original key):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     tests: bool = True
&gt;&gt;&gt; MyArgs.parse_args(&quot;--no-tests&quot;)
{'tests': False}
&gt;&gt;&gt; MyArgs.parse_args()
{'tests': True}
</code></pre>
<p>To suppress this behavior, set <code>flip_bools=False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--tests&quot;, flip_bools=False)
{'tests': False}
</code></pre>
<p>By using the <code><a title="dollar_lambda.Args.parser" href="#dollar_lambda.Args.parser">Args.parser()</a></code> method, <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> can take advantage of all the same
combinators as other parsers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument
&gt;&gt;&gt; p = MyArgs.parser()
&gt;&gt;&gt; p1 = p &gt;&gt; argument(&quot;a&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;--no-tests&quot;, &quot;hello&quot;)
{'tests': False, 'a': 'hello'}
</code></pre>
<p>To supply other metadata, like <code>help</code> text or custom parsers, use <code><a title="dollar_lambda.field" href="#dollar_lambda.field">field()</a></code>:
@dataclass</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     x: int = field(default=0, help=&quot;a number&quot;)
...     y: int = field(
...         default=1,
...         parser=option(&quot;y&quot;, type=lambda s: int(s) + 1, help=&quot;a number to increment&quot;),
...     )
&gt;&gt;&gt; MyArgs.parse_args(&quot;-h&quot;)
usage: -x X -y Y
x: a number
y: a number to increment
</code></pre>
<p>This supplies defaults for <code>y</code> when omitted:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;-x&quot;, &quot;10&quot;)
{'x': 10, 'y': 1}
</code></pre>
<p>It also applies the custom type to <code>y</code> when <code>"-y"</code> is given</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args()
{'x': 0, 'y': 1}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/args.py#L108-L227" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class Args:
    &#34;&#34;&#34;
    `Args` is sugar for the `nonpositional` function and removes much of the boilerplate
    from defining parsers with many arguments.

    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     verbose: bool
    ...     count: int
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--verbose&#34;, &#34;--count&#34;, &#34;1&#34;)
    {&#39;verbose&#39;: True, &#39;count&#39;: 1}

    `MyArgs` will accept these arguments in any order:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--count&#34;, &#34;1&#34;, &#34;--verbose&#34;)
    {&#39;count&#39;: 1, &#39;verbose&#39;: True}

    Note that when the default value of an argument is `True`, `Args` will, by default
    add `--no-` to the front of the flag (while still assigning the value to the original key):
    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     tests: bool = True
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--no-tests&#34;)
    {&#39;tests&#39;: False}
    &gt;&gt;&gt; MyArgs.parse_args()
    {&#39;tests&#39;: True}

    To suppress this behavior, set `flip_bools=False`:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--tests&#34;, flip_bools=False)
    {&#39;tests&#39;: False}

    By using the `Args.parser()` method, `Args` can take advantage of all the same
    combinators as other parsers:

    &gt;&gt;&gt; from dollar_lambda import argument
    &gt;&gt;&gt; p = MyArgs.parser()
    &gt;&gt;&gt; p1 = p &gt;&gt; argument(&#34;a&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;--no-tests&#34;, &#34;hello&#34;)
    {&#39;tests&#39;: False, &#39;a&#39;: &#39;hello&#39;}

    To supply other metadata, like `help` text or custom parsers, use `field`:
    @dataclass
    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     x: int = field(default=0, help=&#34;a number&#34;)
    ...     y: int = field(
    ...         default=1,
    ...         parser=option(&#34;y&#34;, type=lambda s: int(s) + 1, help=&#34;a number to increment&#34;),
    ...     )
    &gt;&gt;&gt; MyArgs.parse_args(&#34;-h&#34;)
    usage: -x X -y Y
    x: a number
    y: a number to increment

    This supplies defaults for `y` when omitted:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;-x&#34;, &#34;10&#34;)
    {&#39;x&#39;: 10, &#39;y&#39;: 1}

    It also applies the custom type to `y` when `&#34;-y&#34;` is given
    &gt;&gt;&gt; MyArgs.parse_args()
    {&#39;x&#39;: 0, &#39;y&#39;: 1}
    &#34;&#34;&#34;

    @classmethod
    def parser(
        cls,
        flip_bools: bool = True,
        repeated: Optional[Parser[Output]] = None,
    ) -&gt; Parser[Output]:
        &#34;&#34;&#34;
        Returns a parser for the dataclass.
        Converts each field to a parser (`option` or `flag` depending on its type).
        Combines these parsers using `nonpositional`.

        Parameters
        ----------
        flip_bools: bool
             Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

        Examples
        --------
        &gt;&gt;&gt; @dataclass
        ... class MyArgs(Args):
        ...     tests: bool = True

        Note the leading `--no-`:
        &gt;&gt;&gt; MyArgs.parse_args(&#34;--no-tests&#34;)
        {&#39;tests&#39;: False}
        &gt;&gt;&gt; MyArgs.parse_args()
        {&#39;tests&#39;: True}

        To suppress this behavior, set `flip_bools=False`:
        &gt;&gt;&gt; MyArgs.parse_args(&#34;--tests&#34;, flip_bools=False)
        {&#39;tests&#39;: False}
        &#34;&#34;&#34;

        def get_fields():
            types = typing.get_type_hints(cls)  # see https://peps.python.org/pep-0563/
            for field in fields(cls):
                field.type = types.get(field.name, str)
                yield _ArgsField.parse(field)

        return _ArgsField.parser(
            *get_fields(), flip_bools=flip_bools, repeated=repeated
        )

    @classmethod
    def parse_args(
        cls,
        *args,
        flip_bools: bool = True,
        repeated: Optional[Parser[Output]] = None,
    ) -&gt; Optional[typing.Dict[str, Any]]:
        &#34;&#34;&#34;
        Parses the arguments and returns a dictionary of the parsed values.
        &#34;&#34;&#34;
        return (
            cls.parser(flip_bools=flip_bools, repeated=repeated)
            &gt;&gt; Parser[Output[Sequence[KeyValue[Any]]]].done()
        ).parse_args(*args)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="dollar_lambda.Args.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>*args, flip_bools: bool = True, repeated: Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output]] = None) <span style="white-space: nowrap;">-></span> Optional[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the arguments and returns a dictionary of the parsed values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/args.py#L214-L227" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def parse_args(
    cls,
    *args,
    flip_bools: bool = True,
    repeated: Optional[Parser[Output]] = None,
) -&gt; Optional[typing.Dict[str, Any]]:
    &#34;&#34;&#34;
    Parses the arguments and returns a dictionary of the parsed values.
    &#34;&#34;&#34;
    return (
        cls.parser(flip_bools=flip_bools, repeated=repeated)
        &gt;&gt; Parser[Output[Sequence[KeyValue[Any]]]].done()
    ).parse_args(*args)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Args.parser"><code class="name flex">
<span>def <span class="ident">parser</span></span>(<span>flip_bools: bool = True, repeated: Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output]] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a parser for the dataclass.
Converts each field to a parser (<code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> or <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> depending on its type).
Combines these parsers using <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to add <code>--no-&lt;argument&gt;</code> before arguments that default to <code>True</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     tests: bool = True
</code></pre>
<p>Note the leading <code>--no-</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--no-tests&quot;)
{'tests': False}
&gt;&gt;&gt; MyArgs.parse_args()
{'tests': True}
</code></pre>
<p>To suppress this behavior, set <code>flip_bools=False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--tests&quot;, flip_bools=False)
{'tests': False}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/args.py#L171-L212" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def parser(
    cls,
    flip_bools: bool = True,
    repeated: Optional[Parser[Output]] = None,
) -&gt; Parser[Output]:
    &#34;&#34;&#34;
    Returns a parser for the dataclass.
    Converts each field to a parser (`option` or `flag` depending on its type).
    Combines these parsers using `nonpositional`.

    Parameters
    ----------
    flip_bools: bool
         Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

    Examples
    --------
    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     tests: bool = True

    Note the leading `--no-`:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--no-tests&#34;)
    {&#39;tests&#39;: False}
    &gt;&gt;&gt; MyArgs.parse_args()
    {&#39;tests&#39;: True}

    To suppress this behavior, set `flip_bools=False`:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--tests&#34;, flip_bools=False)
    {&#39;tests&#39;: False}
    &#34;&#34;&#34;

    def get_fields():
        types = typing.get_type_hints(cls)  # see https://peps.python.org/pep-0563/
        for field in fields(cls):
            field.type = types.get(field.name, str)
            yield _ArgsField.parse(field)

    return _ArgsField.parser(
        *get_fields(), flip_bools=flip_bools, repeated=repeated
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.CommandTree"><code class="flex name class">
<span>class <span class="ident">CommandTree</span></span>
</code></dt>
<dd>
<div class="desc"><p>Allows parsers to dynamically dispatch their results based on the input. For usage details,
see the <a href="#commandtree-tutorial"><code>CommandTree</code> tutorial</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/decorators.py#L257-L522" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class CommandTree:
    &#34;&#34;&#34;
    Allows parsers to dynamically dispatch their results based on the input. For usage details,
    see the [`CommandTree` tutorial](#commandtree-tutorial).
    &#34;&#34;&#34;

    _children: List[_Node] = field(default_factory=list)
    _can_run: bool = True

    def command(
        self,
        can_run: bool = True,
        flip_bools: bool = True,
        help: Optional[typing.Dict[str, str]] = None,
        parsers: Optional[typing.Dict[str, Parser[Output]]] = None,
        repeated: Optional[Parser[Output]] = None,
    ) -&gt; Callable:
        &#34;&#34;&#34;
        A decorator for adding a function as a child of this tree.

        Parameters
        ----------

        can_run: bool
            Whether the parser will permit the decorated function to run if no further arguments are supplied.

        flip_bools: bool
            Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

        help: dict
            A dictionary of help strings for the arguments.

        repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
            If provided, this parser gets applied repeatedly (zero or more times) at all positions.

        parsers: dict
            TODO

        Examples
        --------
        With `flip_bools` set to `True`:
        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(flip_bools=True)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: --no-b
        b: (default: True)

        With `flip_bools` set to `False`:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(flip_bools=False)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: -b
        b: (default: True)


        With `can_run` set to `True` (the default), we can run `f1` by not passing arguments
        for the `f1`&#39;s children:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(can_run=True)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.command()
        ... def g1(n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: -b -n N

        &gt;&gt;&gt; tree(&#34;-b&#34;)
        {&#39;f1&#39;: {&#39;b&#39;: True}}

        With `can_run` set to `False`, the parser will fail if the child function arguments
        are not supplied:


        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(can_run=False)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.command()
        ... def g1(n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: -b -n N

        &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
        usage: -b -n N
        Expected &#39;-b&#39;. Got &#39;f1&#39;
        &#34;&#34;&#34;
        return self._decorator(
            can_run=can_run,
            flip_bools=flip_bools,
            help=help,
            parsers=parsers,
            repeated=repeated,
            subcommand=False,
        )

    def _decorator(self, **kwargs) -&gt; Callable:
        def wrapper(function: Callable):
            tree = CommandTree()
            self._children.append(_Node(function=function, tree=tree, **kwargs))
            return tree

        return wrapper

    def _parser(self, *variables: str) -&gt; Parser[Output[_FunctionPair[Any]]]:
        if not self._children:
            raise RuntimeError(
                &#34;You must assign children to a CommandTree object in order to use it as a parser.&#34;
            )

        def get_alternatives() -&gt; Iterator[Parser[Output[_FunctionPair[Any]]]]:
            for child in self._children:
                parser: Parser[Output[_FunctionPair[Any]]] = child.parser(*variables)
                if child.tree is not None and child.tree._children:
                    child_parser = child.tree._parser(
                        *variables, *child.variable_names()
                    )
                    if child.can_run:
                        child_parser = (
                            child_parser | Parser[Output[_FunctionPair[Any]]].done()
                        )
                    parser = parser &gt;&gt; child_parser
                yield parser

        return reduce(operator.or_, get_alternatives()).wrap_help()

    def __call__(self, *args: str) -&gt; Any:
        &#34;&#34;&#34;
        Run the parser associated with this tree and execute the
        function associated with a succeeding parser.

        If `args` is empty, uses `sys.argv[1:]`.
        &#34;&#34;&#34;
        _args = args if args or parser_mod.TESTING else sys.argv[1:]
        p = self._parser() &gt;&gt; Parser[Output[_FunctionPair[Any]]].done()
        result = p.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            return p.handle_error(result)
        assert isinstance(result, NonemptyList)
        pair = result.head.parsed.get
        assert pair.function is not None
        return pair.function(**pair.seq.to_dict())

    def subcommand(
        self,
        can_run: bool = True,
        flip_bools: bool = True,
        help: Optional[typing.Dict[str, str]] = None,
        parsers: Optional[typing.Dict[str, Optional[Parser[Output]]]] = None,
        repeated: Optional[Parser[Output]] = None,
    ) -&gt; Callable:
        &#34;&#34;&#34;
        A decorator for adding a function as a child of this tree.
        As a subcommand, the function&#39;s name must be invoked on the command
        line for the function to be called.

        Parameters
        ----------

        can_run: bool
            Whether the parser will permit the decorated function to run if no further arguments are supplied.

        flip_bools: bool
            Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

        help: Dict[str, str]
            A dictionary of help strings for the arguments.

        repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
            If provided, this parser gets applied repeatedly (zero or more times) at all positions.
            See `nonpositional` for examples.

        parsers: Dict[str, Parser]
            A dictionary reserving arguments for custom parsers. See below for examples.
            See `command` for examples.

        Examples
        --------
        With `flip_bools` set to `True`:
        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(flip_bools=True)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 --no-b
        b: (default: True)

        With `flip_bools` set to `False`:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(flip_bools=False)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 -b
        b: (default: True)

        With `can_run` set to `True` (the default), we can run `f1` by not passing arguments
        for the `f1`&#39;s children:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(can_run=True)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.subcommand()
        ... def g1(b: bool, n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 -b g1 -n N

        &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
        {&#39;f1&#39;: {&#39;b&#39;: True}}

        With `can_run` set to `False`, the parser will fail if the child function arguments
        are not supplied:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(can_run=False)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.subcommand()
        ... def g1(b: bool, n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 -b g1 -n N

        &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
        usage: f1 -b g1 -n N
        The following arguments are required: g1
        &#34;&#34;&#34;
        return self._decorator(
            can_run=can_run,
            flip_bools=flip_bools,
            help=help,
            repeated=repeated,
            parsers=parsers,
            subcommand=True,
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.CommandTree.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self, can_run: bool = True, flip_bools: bool = True, help: Optional[typing.Dict[str, str]] = None, parsers: Optional[typing.Dict[str, <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output]]] = None, repeated: Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output]] = None) <span style="white-space: nowrap;">-></span> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>A decorator for adding a function as a child of this tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>can_run</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the parser will permit the decorated function to run if no further arguments are supplied.</dd>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to add <code>--no-&lt;argument&gt;</code> before arguments that default to <code>True</code>.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of help strings for the arguments.</dd>
<dt><strong><code>repeated</code></strong> :&ensp;<code>Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[KeyValue[Any]]]]</code></dt>
<dd>If provided, this parser gets applied repeatedly (zero or more times) at all positions.</dd>
<dt><strong><code>parsers</code></strong> :&ensp;<code>dict</code></dt>
<dd>TODO</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>With <code>flip_bools</code> set to <code>True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(flip_bools=True)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: --no-b
b: (default: True)
</code></pre>
<p>With <code>flip_bools</code> set to <code>False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(flip_bools=False)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -b
b: (default: True)
</code></pre>
<p>With <code>can_run</code> set to <code>True</code> (the default), we can run <code>f1</code> by not passing arguments
for the <code>f1</code>'s children:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(can_run=True)  # &lt;-
... def f1(b: bool):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; @f1.command()
... def g1(n: int):
...     return dict(g1=dict(b=b, n=n))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -b -n N
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-b&quot;)
{'f1': {'b': True}}
</code></pre>
<p>With <code>can_run</code> set to <code>False</code>, the parser will fail if the child function arguments
are not supplied:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(can_run=False)  # &lt;-
... def f1(b: bool):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; @f1.command()
... def g1(n: int):
...     return dict(g1=dict(b=b, n=n))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -b -n N
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;f1&quot;, &quot;-b&quot;)
usage: -b -n N
Expected '-b'. Got 'f1'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/decorators.py#L267-L369" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def command(
    self,
    can_run: bool = True,
    flip_bools: bool = True,
    help: Optional[typing.Dict[str, str]] = None,
    parsers: Optional[typing.Dict[str, Parser[Output]]] = None,
    repeated: Optional[Parser[Output]] = None,
) -&gt; Callable:
    &#34;&#34;&#34;
    A decorator for adding a function as a child of this tree.

    Parameters
    ----------

    can_run: bool
        Whether the parser will permit the decorated function to run if no further arguments are supplied.

    flip_bools: bool
        Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

    help: dict
        A dictionary of help strings for the arguments.

    repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
        If provided, this parser gets applied repeatedly (zero or more times) at all positions.

    parsers: dict
        TODO

    Examples
    --------
    With `flip_bools` set to `True`:
    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command(flip_bools=True)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: --no-b
    b: (default: True)

    With `flip_bools` set to `False`:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command(flip_bools=False)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: -b
    b: (default: True)


    With `can_run` set to `True` (the default), we can run `f1` by not passing arguments
    for the `f1`&#39;s children:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command(can_run=True)  # &lt;-
    ... def f1(b: bool):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; @f1.command()
    ... def g1(n: int):
    ...     return dict(g1=dict(b=b, n=n))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: -b -n N

    &gt;&gt;&gt; tree(&#34;-b&#34;)
    {&#39;f1&#39;: {&#39;b&#39;: True}}

    With `can_run` set to `False`, the parser will fail if the child function arguments
    are not supplied:


    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command(can_run=False)  # &lt;-
    ... def f1(b: bool):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; @f1.command()
    ... def g1(n: int):
    ...     return dict(g1=dict(b=b, n=n))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: -b -n N

    &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
    usage: -b -n N
    Expected &#39;-b&#39;. Got &#39;f1&#39;
    &#34;&#34;&#34;
    return self._decorator(
        can_run=can_run,
        flip_bools=flip_bools,
        help=help,
        parsers=parsers,
        repeated=repeated,
        subcommand=False,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.CommandTree.subcommand"><code class="name flex">
<span>def <span class="ident">subcommand</span></span>(<span>self, can_run: bool = True, flip_bools: bool = True, help: Optional[typing.Dict[str, str]] = None, parsers: Optional[typing.Dict[str, Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output]]]] = None, repeated: Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output]] = None) <span style="white-space: nowrap;">-></span> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>A decorator for adding a function as a child of this tree.
As a subcommand, the function's name must be invoked on the command
line for the function to be called.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>can_run</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the parser will permit the decorated function to run if no further arguments are supplied.</dd>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to add <code>--no-&lt;argument&gt;</code> before arguments that default to <code>True</code>.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>A dictionary of help strings for the arguments.</dd>
<dt><strong><code>repeated</code></strong> :&ensp;<code>Optional[<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[KeyValue[Any]]]]</code></dt>
<dd>If provided, this parser gets applied repeatedly (zero or more times) at all positions.
See <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> for examples.</dd>
<dt><strong><code>parsers</code></strong> :&ensp;<code>Dict[str, <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>]</code></dt>
<dd>A dictionary reserving arguments for custom parsers. See below for examples.
See <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> for examples.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>With <code>flip_bools</code> set to <code>True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.subcommand(flip_bools=True)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: f1 --no-b
b: (default: True)
</code></pre>
<p>With <code>flip_bools</code> set to <code>False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.subcommand(flip_bools=False)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: f1 -b
b: (default: True)
</code></pre>
<p>With <code>can_run</code> set to <code>True</code> (the default), we can run <code>f1</code> by not passing arguments
for the <code>f1</code>'s children:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.subcommand(can_run=True)  # &lt;-
... def f1(b: bool):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; @f1.subcommand()
... def g1(b: bool, n: int):
...     return dict(g1=dict(b=b, n=n))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: f1 -b g1 -n N
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;f1&quot;, &quot;-b&quot;)
{'f1': {'b': True}}
</code></pre>
<p>With <code>can_run</code> set to <code>False</code>, the parser will fail if the child function arguments
are not supplied:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.subcommand(can_run=False)  # &lt;-
... def f1(b: bool):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; @f1.subcommand()
... def g1(b: bool, n: int):
...     return dict(g1=dict(b=b, n=n))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: f1 -b g1 -n N
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;f1&quot;, &quot;-b&quot;)
usage: f1 -b g1 -n N
The following arguments are required: g1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/decorators.py#L418-L522" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def subcommand(
    self,
    can_run: bool = True,
    flip_bools: bool = True,
    help: Optional[typing.Dict[str, str]] = None,
    parsers: Optional[typing.Dict[str, Optional[Parser[Output]]]] = None,
    repeated: Optional[Parser[Output]] = None,
) -&gt; Callable:
    &#34;&#34;&#34;
    A decorator for adding a function as a child of this tree.
    As a subcommand, the function&#39;s name must be invoked on the command
    line for the function to be called.

    Parameters
    ----------

    can_run: bool
        Whether the parser will permit the decorated function to run if no further arguments are supplied.

    flip_bools: bool
        Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

    help: Dict[str, str]
        A dictionary of help strings for the arguments.

    repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
        If provided, this parser gets applied repeatedly (zero or more times) at all positions.
        See `nonpositional` for examples.

    parsers: Dict[str, Parser]
        A dictionary reserving arguments for custom parsers. See below for examples.
        See `command` for examples.

    Examples
    --------
    With `flip_bools` set to `True`:
    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.subcommand(flip_bools=True)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: f1 --no-b
    b: (default: True)

    With `flip_bools` set to `False`:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.subcommand(flip_bools=False)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: f1 -b
    b: (default: True)

    With `can_run` set to `True` (the default), we can run `f1` by not passing arguments
    for the `f1`&#39;s children:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.subcommand(can_run=True)  # &lt;-
    ... def f1(b: bool):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; @f1.subcommand()
    ... def g1(b: bool, n: int):
    ...     return dict(g1=dict(b=b, n=n))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: f1 -b g1 -n N

    &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
    {&#39;f1&#39;: {&#39;b&#39;: True}}

    With `can_run` set to `False`, the parser will fail if the child function arguments
    are not supplied:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.subcommand(can_run=False)  # &lt;-
    ... def f1(b: bool):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; @f1.subcommand()
    ... def g1(b: bool, n: int):
    ...     return dict(g1=dict(b=b, n=n))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: f1 -b g1 -n N

    &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
    usage: f1 -b g1 -n N
    The following arguments are required: g1
    &#34;&#34;&#34;
    return self._decorator(
        can_run=can_run,
        flip_bools=flip_bools,
        help=help,
        repeated=repeated,
        parsers=parsers,
        subcommand=True,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.Parser"><code class="flex name class">
<span>class <span class="ident">Parser</span></span>
<span>(</span><span>f: Callable[[Sequence[str]], Result[Parse[A_co]]], usage: Optional[str], helps: Dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Main class powering the argument parser.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L74-L712" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class Parser(MonadPlus[A_co]):
    &#34;&#34;&#34;
    Main class powering the argument parser.
    &#34;&#34;&#34;

    f: Callable[[Sequence[str]], Result[Parse[A_co]]]
    usage: Optional[str]
    helps: Dict[str, str]

    def __add__(
        self: &#34;Parser[Output[A_monoid]]&#34;, other: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        &#34;&#34;&#34;
        Parse two arguments in either order.
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
        {&#39;verbose&#39;: True, &#39;debug&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
        {&#39;debug&#39;: True, &#39;verbose&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
        usage: --verbose --debug
        Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

        Note that if more than two arguments are chained together with `+`, some combinations will not parse:
        &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
        {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
        usage: -a -b -c
        Expected &#39;-b&#39;. Got &#39;-c&#39;

        This makes more sense when one supplies the implicit parentheses:
        &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

        In order to chain together more than two arguments, use `nonpositional`:
        &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
        {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
        &#34;&#34;&#34;
        p = (self &gt;&gt; other) | (other.rshift(self))
        usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
        return replace(p, usage=usage)

    def __ge__(self, f: Callable[[A_co], Monad[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[override]
        return self.bind(f)

    def __or__(  # type: ignore[override]
        self: &#34;Parser[A_monoid]&#34;,
        other: &#34;Parser[B_monoid]&#34;,
    ) -&gt; &#34;Parser[A_monoid | B_monoid]&#34;:
        &#34;&#34;&#34;
        Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

        &gt;&gt;&gt; from dollar_lambda import argument, option, flag
        &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
        {&#39;verbose&#39;: True}

        Note that by default, `parse_args` adds `&gt;&gt; Parser.done()` to the end of parsers, causing
        `p` to fail when both arguments are supplied:

        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        usage: [--option OPTION | --verbose]
        Unrecognized argument: --option

        To disable this behavior, use `allow_unparsed`:
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;, allow_unparsed=True)
        {&#39;verbose&#39;: True}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[&#34;A_monoid | B_monoid&#34;]]:
            return self.parse(cs) | other.parse(cs)

        return Parser(
            f,
            usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
            helps={**self.helps, **other.helps},
        )

    def rshift(
        self: &#34;Parser[Output[A_monoid]]&#34;, p: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        return self &gt;&gt; p

    def __rshift__(
        self: &#34;Parser[Output[A_monoid]]&#34;, p: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        &#34;&#34;&#34;
        This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
        gets handed off to the second parser. If either parser fails, the whole thing fails.

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        usage: FIRST SECOND
        The following arguments are required: second
        &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
        usage: FIRST SECOND
        The following arguments are required: second
        &#34;&#34;&#34;

        def f(p1: Output[A_monoid]) -&gt; Parser[Output[A_monoid | B_monoid]]:
            def g(p2: Output[B_monoid]) -&gt; Parser[Output[A_monoid | B_monoid]]:
                # _p1 = p1 if isinstance(p1, Sequence) else Sequence(p1)
                # _p2 = p2 if isinstance(p2, Sequence) else Sequence(p2)
                return Parser.return_(p1 + p2)

            return p &gt;= g

        parser = self &gt;= f
        # parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
        return replace(
            parser,
            usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False),
            helps={**self.helps, **p.helps},
        )

    def __xor__(
        self: &#34;Parser[Output[A_monoid]]&#34;, other: &#34;Parser[Output[B_monoid]]&#34;
    ) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
        &#34;&#34;&#34;
        This is the same as `__or__`, but it succeeds only if one of the two parsers fails.

        &gt;&gt;&gt; p = argument(&#34;int&#34;, type=int) ^ argument(&#34;div&#34;, type=lambda x: 1 / float(x))
        &gt;&gt;&gt; p.parse_args(&#34;inf&#34;)  # succeeds because int(&#34;inf&#34;) fails
        {&#39;div&#39;: 0.0}
        &gt;&gt;&gt; p.parse_args(&#34;0&#34;)  # succeeds because 1 / 0 throws an error
        {&#39;int&#39;: 0}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)  # fails because both parsers succeed
        Both parsers succeeded. This causes ^ to fail.
        &#34;&#34;&#34;
        p = (self.fails() &gt;&gt; other) | (other.fails() &gt;&gt; self)

        def f(error: ArgumentError) -&gt; ArgumentError:
            if isinstance(error, BinaryError):
                return ArgumentError(&#34;Both parsers succeeded. This causes ^ to fail.&#34;)
            return error

        return p.map_error(f)

    def apply(self: &#34;Parser[A_monoid]&#34;, f: Callable[[A_monoid], Result[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        Takes the output of `parser` and applies `f` to it. Convert any errors that arise into `ArgumentError`.

        &gt;&gt;&gt; p1 = flag(&#34;hello&#34;)
        &gt;&gt;&gt; p1.parse_args(&#34;--hello&#34;)
        {&#39;hello&#39;: True}

        This will double `p1`&#39;s output:
        &gt;&gt;&gt; p2 = p1.apply(lambda out: Result.return_(out + out))
        &gt;&gt;&gt; p2.parse_args(&#34;--hello&#34;)
        {&#39;hello&#39;: [True, True]}
        &#34;&#34;&#34;

        def g(a: A_monoid) -&gt; Parser[B_monoid]:
            try:
                y = f(a)
            except Exception as e:
                usage = f&#34;An argument {a}: raised exception {e}&#34;
                y = Result(ArgumentError(usage))
            return Parser(
                lambda cs: y &gt;= (lambda parsed: Result.return_(Parse(parsed, cs))),
                usage=self.usage,
                helps=self.helps,
            )

        p = self &gt;= g
        return replace(p, usage=self.usage, helps=self.helps)

    def bind(self, f: Callable[[A_co], Monad[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[override]
        &#34;&#34;&#34;
        Returns a new parser that

        1. applies `self`;
        2. if this succeeds, applies `f` to the parsed component of the result.

        `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
        avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
        `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

        Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
        and we typically prefer using the infix operator to the spelled out method.

        Let&#39;s start with our simplest parser, `argument`:
        &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

        Now let&#39;s use the `matches` parser to write a function that takes the output of `p1` and fails unless
        the next argument is the same as the first:
        &gt;&gt;&gt; def f(out: Output[Sequence[KeyValue[Any]]]) -&gt; Parser[Output[str]]:
        ...     *_, kv = out.get
        ...     return matches(kv.value)

        &gt;&gt;&gt; p = p1 &gt;= f
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
        {&#39;a&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        Expected &#39;a&#39;. Got &#39;b&#39;
        &#34;&#34;&#34;

        def h(parse: Parse[A_co]) -&gt; Result[Parse[B_monoid]]:
            y = f(parse.parsed)
            assert isinstance(y, Parser), y
            return y.parse(parse.unparsed)

        def g(cs: Sequence[str]) -&gt; Result[Parse[B_monoid]]:
            return self.parse(cs) &gt;= h

        return Parser(g, usage=None, helps=self.helps)

    @classmethod
    def done(
        cls: Type[&#34;Parser[Output[A_monoid]]&#34;], a: Optional[Type[A_monoid]] = None
    ) -&gt; Parser[Output[Any]]:
        &#34;&#34;&#34;
        `done` succeds on the end of input and fails on everything else.
        &gt;&gt;&gt; Parser.done().parse_args()
        {}
        &gt;&gt;&gt; Parser.done().parse_args(&#34;arg&#34;)
        Unrecognized argument: arg

        Without `done` the parser will not complain about leftover (unparsed) input:

        &gt;&gt;&gt; flag(&#34;verbose&#34;).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, allow_unparsed=True)
        {&#39;verbose&#39;: True}

        When `allow_unparsed=False` (the default), `parse_args` adds `&gt;&gt; Parser.done()`
        to the end of the parser:
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[Output[Any]]]:
            if cs:
                c, *_ = cs
                return Result(
                    UnexpectedError(unexpected=c, usage=f&#34;Unrecognized argument: {c}&#34;)
                )
            return Result(NonemptyList(Parse(parsed=Output.zero(a), unparsed=cs)))

        return Parser(f, usage=None, helps={})

    @classmethod
    def empty(
        cls: Type[&#34;Parser[Output[A_monoid]]&#34;], a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
        &gt;&gt;&gt; Parser.empty().parse_args(&#34;any&#34;, &#34;arguments&#34;, allow_unparsed=True)
        {}
        &#34;&#34;&#34;
        return cls.return_(Output.zero(a))

    def fails(
        self: &#34;Parser[Output[A_monoid]]&#34;, a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Succeeds only if self fails. Does not consume any input.

        &gt;&gt;&gt; flag(&#34;x&#34;).fails().parse_args(&#34;not x&#34;, allow_unparsed=True)  # succeeds
        {}
        &gt;&gt;&gt; flag(&#34;x&#34;).fails().parse_args(&#34;-x&#34;, allow_unparsed=True)  # fails
        Parser unexpectedly succeeded.
        &#34;&#34;&#34;

        def g(cs: Sequence[str]) -&gt; Result[Parse[Output[A_monoid]]]:
            parse = self.parse(cs).get
            if isinstance(parse, Exception):
                return Result.return_(Parse(Output.zero(a), cs))
            else:
                return Result.zero(
                    error=SuccessError(
                        &#34;Parser unexpectedly succeeded.&#34;, input=cs, output=parse
                    )
                )

        return Parser(g, usage=None, helps=self.helps)

    def handle_error(self, error: ArgumentError) -&gt; None:
        def print_usage(usage: str):
            self._print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in usage else &#34; &#34;)
            if &#34;\n&#34; in usage:
                usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in usage.split(&#34;\n&#34;)])
            self._print(usage)
            if self.helps:
                for k, v in self.helps.items():
                    self._print(f&#34;{k}: {v}&#34;)

        if isinstance(error, HelpError):
            print_usage(error.usage)
        else:
            if self.usage:
                print_usage(self.usage)
            if error.usage:
                self._print(error.usage)
        if TESTING:
            return
        else:
            exit()

    def ignore(
        self: &#34;Parser[Output[A_monoid]]&#34;, a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Ignores the output from a parser. This is useful when you expect
        to give arguments to the command line that some other utility will
        handle.

        &gt;&gt;&gt; p = flag(&#34;hello&#34;).ignore()

        This will not bind any value to `&#34;hello&#34;`:
        &gt;&gt;&gt; p.parse_args(&#34;--hello&#34;)
        {}

        But `--hello` is still required:
        &gt;&gt;&gt; p.parse_args()
        The following arguments are required: --hello
        &#34;&#34;&#34;

        def g(keep: Parse[Output[A_monoid]]) -&gt; Result[Parse[Output[A_monoid]]]:
            return Result(NonemptyList(Parse(Output.zero(a), keep.unparsed)))

        def f(cs: Sequence[str]) -&gt; Result[Parse[Output[A_monoid]]]:
            return self.parse(cs) &gt;= g

        return Parser(f, usage=None, helps={})

    def many(
        self: &#34;Parser[Output[A_monoid]]&#34;, max: int = MAX_MANY
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Applies `self` zero or more times (like `*` in regexes).

        Parameters
        ----------

        max: int
            Limits the number of times `many` is applied in order to prevent `RecursionError`s.
            The default for this can be increased by either setting `parser.MAX_MANY` or
            the environment variable `DOLLAR_LAMBDA_MAX_MANY`.

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args()
        {}
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        {&#39;as-many-as-you-like&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;as-many-as-you-like&#39;: [&#39;a&#39;, &#39;b&#39;]}

        Note that if `self` contains `Parser.__or__`, the arguments can be
        heterogenous:
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
        &gt;&gt;&gt; p = p.many()
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;) # mix --verbose and --quiet
        {&#39;verbose&#39;: True, &#39;quiet&#39;: True}
        &#34;&#34;&#34;
        if max == 0:
            p = self.empty()
        else:
            max -= 1
            assert max &gt;= 0, max
            p = self.many1(max=max) | self.empty()
        return replace(p, usage=f&#34;[{self.usage} ...]&#34;)

    def many1(
        self: &#34;Parser[Output[A_monoid]]&#34;, max: int = MAX_MANY
    ) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Applies `self` one or more times (like `+` in regexes).

        Parameters
        ----------

        max: int
            Limits the number of times `many1` is applied in order to prevent `RecursionError`s.
            The default for this can be increased by either setting `parser.MAX_MANY` or
            the environment variable `DOLLAR_LAMBDA_MAX_MANY`.

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
        {&#39;1-or-more&#39;: &#39;1&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;)
        {&#39;1-or-more&#39;: [&#39;1&#39;, &#39;2&#39;]}
        &gt;&gt;&gt; p.parse_args()
        usage: 1-OR-MORE [1-OR-MORE ...]
        The following arguments are required: 1-or-more
        &#34;&#34;&#34;

        return Parser(
            lambda cs: (self &gt;&gt; self.many(max=max)).parse(cs),
            usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
            helps=self.helps,
        )

    def map_error(self, f: Callable[[ArgumentError], ArgumentError]) -&gt; &#34;Parser[A_co]&#34;:
        def g(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
            parse = self.parse(cs)
            if isinstance(parse.get, ArgumentError):
                return Result.zero(error=f(parse.get))
            else:
                return parse

        return Parser(g, usage=None, helps=self.helps)

    def optional(self: &#34;Parser[Output[A_monoid]]&#34;) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
        &#34;&#34;&#34;
        Allows arguments to be optional:
        &gt;&gt;&gt; p1 = flag(&#34;optional&#34;)
        &gt;&gt;&gt; p = p1.optional()
        &gt;&gt;&gt; p.parse_args(&#34;--optional&#34;)
        {&#39;optional&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--misspelled&#34;, allow_unparsed=True)  # succeeds with no output
        {}
        &gt;&gt;&gt; p1.parse_args(&#34;--misspelled&#34;)
        usage: --optional
        Expected &#39;--optional&#39;. Got &#39;--misspelled&#39;
        &#34;&#34;&#34;
        return self | self.empty()

    def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        &#34;&#34;&#34;
        Applies the parser to the input sequence `cs`.
        &#34;&#34;&#34;
        return self.f(cs)

    def parse_args(
        self: &#34;Parser[Output]&#34;,
        *args: str,
        allow_unparsed: bool = False,
        check_help: bool = True,
    ) -&gt; &#34;Optional[Dict[str, Any]]&#34;:
        &#34;&#34;&#34;
        The main way the user extracts parsed results from the parser.

        Parameters
        ----------
        args : str
            A sequence of strings to parse. If empty, defaults to `sys.argv[1:]`.
        allow_unparsed : bool
            Whether to cause parser to fail if there are unparsed inputs. Note that setting this to false
            may cause unexpected behavior when using `nonpositional` or `Args`.
        check_help : bool
            Before running the parser, checks if the input string is `--help` or `-h`.
            If it is, returns the usage message.

        Examples
        --------

        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
        usage: A
        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
        usage: A
        &#34;&#34;&#34;
        _args = args if args or TESTING else sys.argv[1:]
        if not allow_unparsed:
            return (self &gt;&gt; Parser[Output].done()).parse_args(
                *_args,
                allow_unparsed=True,
                check_help=check_help,
            )
        if check_help:
            return self.wrap_help().parse_args(
                *_args,
                allow_unparsed=allow_unparsed,
                check_help=False,
            )
        result = self.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            self.handle_error(result)
            return None
        get = result.head.parsed.get
        assert isinstance(get, Sequence), get
        return get.to_dict()

    @staticmethod
    def _print(*args, **kwargs):
        if PRINTING:
            print(*args, **kwargs)

    @classmethod
    def return_(cls, a: A_co) -&gt; &#34;Parser[A_co]&#34;:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
        and always returns `a` as the result. For the most part, the user will not use
        this method unless building custom parsers.

        &gt;&gt;&gt; Parser.return_(Output.from_dict(some_key=&#34;some_value&#34;)).parse_args()
        {&#39;some_key&#39;: &#39;some_value&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
            return Result.return_(Parse(a, cs))

        return Parser(f, usage=None, helps={})

    def sat(
        self: &#34;Parser[A_monoid]&#34;,
        predicate: Callable[[A_monoid], bool],
        on_fail: Callable[[A_monoid], ArgumentError],
    ) -&gt; &#34;Parser[A_monoid]&#34;:
        &#34;&#34;&#34;
        Applies `parser`, applies a predicate to the result and fails if this returns false.

        &gt;&gt;&gt; p = option(&#34;x&#34;, type=int).many().sat(
        ...     lambda out: sum(out.get.values()) &gt; 0,
        ...     lambda out: ArgumentError(f&#34;The values in {list(out.get.values())} must sum to more than 0.&#34;),
        ... )
        &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;1&#34;)  # fails
        usage: [-x X ...]
        The values in [-1, 1] must sum to more than 0.

        &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;2&#34;)  # succeeds
        {&#39;x&#39;: [-1, 2]}

        Parameters
        ----------
        parser : Parser[A]
            The parser to apply.
        predicate : Callable[[A], bool]
            The predicate to apply to the result of `parser`. `sat` fails if this predicate returns false.
        on_fail : Callable[[A], ArgumentError]
            A function producing an ArgumentError to return if the predicate fails.
            Takes the output of `parser` as an argument.
        &#34;&#34;&#34;

        def f(x: A_monoid) -&gt; Result[A_monoid]:
            return Result(NonemptyList(x) if predicate(x) else on_fail(x))

        return self.apply(f)

    def nesting(
        self: &#34;Parser[Output[Sequence[KeyValue[Any]]]]&#34;,
    ) -&gt; &#34;Parser[Output[Sequence[KeyValue[Any]]]]&#34;:
        &#34;&#34;&#34;
        Breaks the output of the wrapped parser into nested outputs. See the [`Nesting output`](#nesting-output)
        section of the documentation for more information.
        &#34;&#34;&#34;

        def g(out: Output[Sequence[KeyValue[str]]]) -&gt; Result[Output]:
            d = out.get
            if not d:
                raise RuntimeError(&#34;Invoked nested on a parser that returns no output.&#34;)
            *tail, head = out.get
            if &#34;.&#34; in head.key:
                key, hd, *tl = head.key.split(&#34;.&#34;)
                parents = NonemptyList.make(hd, *tl)
                path = TreePath(parents, head.value)
                kv = KeyValue(key, path)
                return Result.return_(Output(Sequence([*tail, kv])))
            else:
                return Result.return_(out)

        p = self.apply(g)
        return replace(p, usage=self.usage, helps=self.helps)

    def type(
        self: &#34;Parser[Output[Sequence[KeyValue[str]]]]&#34;, f: Callable[[str], Any]
    ) -&gt; &#34;Parser[Output[Sequence[KeyValue[str]]]]&#34;:
        &#34;&#34;&#34;
        A wrapper around `apply` that simply applies `f` to the value of the most recently parsed input.
        &gt;&gt;&gt; p1 = option(&#34;x&#34;) &gt;&gt; option(&#34;y&#34;)
        &gt;&gt;&gt; p = p1.type(int)
        &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)  # converts &#34;1&#34; but not &#34;2&#34;
        {&#39;x&#39;: &#39;1&#39;, &#39;y&#39;: 2}
        &#34;&#34;&#34;

        def g(out: Output[Sequence[KeyValue[str]]]) -&gt; Result[Output]:
            d = out.get
            if not d:
                raise RuntimeError(&#34;Invoked type on a parser that returns no output.&#34;)
            *tail, head = out.get
            try:
                y = f(head.value)
            except Exception as e:
                usage = f&#34;argument {head.value}: raised exception {e}&#34;
                return Result(ArgumentError(usage))
            return Result.return_(Output(Sequence([*tail, KeyValue(head.key, y)])))

        p = self.apply(g)
        return replace(p, usage=self.usage, helps=self.helps)

    def wrap_error(self, error: ArgumentError) -&gt; &#34;Parser[A_co]&#34;:
        return self.map_error(lambda _: error)

    def wrap_help(
        self: &#34;Parser[A_monoid]&#34;, a: Optional[Type[A_monoid]] = None
    ) -&gt; &#34;Parser[A_monoid]&#34;:
        &#34;&#34;&#34;
        This checks for the `--help` or `-h` flag before applying `parser`.
        If either of the flags is present, returns the usage message for `parser`.

        &gt;&gt;&gt; p = flag(&#34;help&#34;, help=&#34;Print this help message.&#34;).wrap_help()
        &gt;&gt;&gt; p.parse_args(&#34;--help&#34;)
        usage: --help
        help: Print this help message.
        &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
        usage: --help
        help: Print this help message.

        We can use `wrap_help` to print partial usage messages, e.g. for subcommands:
        &gt;&gt;&gt; subcommand1 = matches(&#34;subcommand1&#34;) &gt;&gt; option(&#34;option1&#34;).wrap_help()
        &gt;&gt;&gt; subcommand2 = matches(&#34;subcommand2&#34;) &gt;&gt; option(&#34;option2&#34;).wrap_help()
        &gt;&gt;&gt; p = subcommand1 | subcommand2
        &gt;&gt;&gt; p.parse_args(&#34;subcommand1&#34;, &#34;-h&#34;)
        usage: --option1 OPTION1
        &gt;&gt;&gt; p.parse_args(&#34;subcommand2&#34;, &#34;-h&#34;)
        usage: --option2 OPTION2
        &#34;&#34;&#34;
        _help_parser: Parser[Output[A_monoid]] = help_parser(self.usage, Output.zero(a))

        p = _help_parser &gt;= (lambda _: self)
        return replace(p, usage=self.usage, helps=self.helps)

    @classmethod
    def zero(cls, error: Optional[ArgumentError] = None) -&gt; &#34;Parser[A_co]&#34;:
        &#34;&#34;&#34;
        This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

        Parameters
        ----------
        error : Optional[ArgumentError]
            Customize the error returned by `zero`.

        &gt;&gt;&gt; Parser.zero().parse_args()
        zero
        &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
        zero
        &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
        This is a test.
        &#34;&#34;&#34;
        return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pytypeclass.monoid.MonadPlus</li>
<li>pytypeclass.monad.Monad</li>
<li>pytypeclass.monoid.Monoid</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.Parser.f"><code class="name">var <span class="ident">f</span> : Callable[[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[str]], <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="parser.html#dollar_lambda.parser.Parse">Parse</a>[+A_co]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.Parser.helps"><code class="name">var <span class="ident">helps</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.Parser.usage"><code class="name">var <span class="ident">usage</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dollar_lambda.Parser.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>a: Optional[Type[A_monoid]] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p><code>done</code> succeds on the end of input and fails on everything else.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.done().parse_args()
{}
&gt;&gt;&gt; Parser.done().parse_args(&quot;arg&quot;)
Unrecognized argument: arg
</code></pre>
<p>Without <code>done</code> the parser will not complain about leftover (unparsed) input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;, allow_unparsed=True)
{'verbose': True}
</code></pre>
<p>When <code>allow_unparsed=False</code> (the default), <code>parse_args</code> adds <code>&gt;&gt; Parser.done()</code>
to the end of the parser:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L289-L317" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def done(
    cls: Type[&#34;Parser[Output[A_monoid]]&#34;], a: Optional[Type[A_monoid]] = None
) -&gt; Parser[Output[Any]]:
    &#34;&#34;&#34;
    `done` succeds on the end of input and fails on everything else.
    &gt;&gt;&gt; Parser.done().parse_args()
    {}
    &gt;&gt;&gt; Parser.done().parse_args(&#34;arg&#34;)
    Unrecognized argument: arg

    Without `done` the parser will not complain about leftover (unparsed) input:

    &gt;&gt;&gt; flag(&#34;verbose&#34;).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, allow_unparsed=True)
    {&#39;verbose&#39;: True}

    When `allow_unparsed=False` (the default), `parse_args` adds `&gt;&gt; Parser.done()`
    to the end of the parser:
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[Output[Any]]]:
        if cs:
            c, *_ = cs
            return Result(
                UnexpectedError(unexpected=c, usage=f&#34;Unrecognized argument: {c}&#34;)
            )
        return Result(NonemptyList(Parse(parsed=Output.zero(a), unparsed=cs)))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>a: Optional[Type[A_monoid]] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Always returns {}, no matter the input. Mostly useful for use in <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.empty().parse_args(&quot;any&quot;, &quot;arguments&quot;, allow_unparsed=True)
{}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L319-L328" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def empty(
    cls: Type[&#34;Parser[Output[A_monoid]]&#34;], a: Optional[Type[A_monoid]] = None
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
    &gt;&gt;&gt; Parser.empty().parse_args(&#34;any&#34;, &#34;arguments&#34;, allow_unparsed=True)
    {}
    &#34;&#34;&#34;
    return cls.return_(Output.zero(a))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.return_"><code class="name flex">
<span>def <span class="ident">return_</span></span>(<span>a: A_co) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"><p>This method is required to make <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. It consumes none of the input
and always returns <code>a</code> as the result. For the most part, the user will not use
this method unless building custom parsers.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.return_(Output.from_dict(some_key=&quot;some_value&quot;)).parse_args()
{'some_key': 'some_value'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L560-L575" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def return_(cls, a: A_co) -&gt; &#34;Parser[A_co]&#34;:  # type: ignore[misc]
    # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
    &#34;&#34;&#34;
    This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
    and always returns `a` as the result. For the most part, the user will not use
    this method unless building custom parsers.

    &gt;&gt;&gt; Parser.return_(Output.from_dict(some_key=&#34;some_value&#34;)).parse_args()
    {&#39;some_key&#39;: &#39;some_value&#39;}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        return Result.return_(Parse(a, cs))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.zero"><code class="name flex">
<span>def <span class="ident">zero</span></span>(<span>error: Optional[ArgumentError] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"><p>This parser always fails. This method is necessary to make <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13"><code>Monoid</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>error</code></strong> :&ensp;<code>Optional[ArgumentError]</code></dt>
<dd>Customize the error returned by <code>zero</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.zero().parse_args()
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero().parse_args(&quot;a&quot;)
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero(error=ArgumentError(&quot;This is a test.&quot;)).parse_args(&quot;a&quot;)
This is a test.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L695-L712" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def zero(cls, error: Optional[ArgumentError] = None) -&gt; &#34;Parser[A_co]&#34;:
    &#34;&#34;&#34;
    This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

    Parameters
    ----------
    error : Optional[ArgumentError]
        Customize the error returned by `zero`.

    &gt;&gt;&gt; Parser.zero().parse_args()
    zero
    &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
    zero
    &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
    This is a test.
    &#34;&#34;&#34;
    return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.Parser.__add__"><code class="name flex">
<span>def <span class="ident">__add__</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]'", other: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[B_monoid]]'") <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[typing.Union[~A_monoid, ~B_monoid]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse two arguments in either order.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;debug&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--debug&quot;)
{'verbose': True, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;, &quot;--verbose&quot;)
{'debug': True, 'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;)
usage: --verbose --debug
Expected '--verbose'. Got '--debug'
</code></pre>
<p>Note that if more than two arguments are chained together with <code>+</code>, some combinations will not parse:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;a&quot;) + flag(&quot;b&quot;) + flag(&quot;c&quot;)
&gt;&gt;&gt; p.parse_args(&quot;-c&quot;, &quot;-a&quot;, &quot;-b&quot;)   # this works
{'c': True, 'a': True, 'b': True}
&gt;&gt;&gt; p.parse_args(&quot;-a&quot;, &quot;-c&quot;, &quot;-b&quot;)   # this doesn't
usage: -a -b -c
Expected '-b'. Got '-c'
</code></pre>
<p>This makes more sense when one supplies the implicit parentheses:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (flag(&quot;a&quot;) + flag(&quot;b&quot;)) + flag(&quot;c&quot;)
</code></pre>
<p>In order to chain together more than two arguments, use <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;a&quot;), flag(&quot;b&quot;), flag(&quot;c&quot;))
&gt;&gt;&gt; p.parse_args(&quot;-a&quot;, &quot;-c&quot;, &quot;-b&quot;)
{'a': True, 'c': True, 'b': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L84-L116" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __add__(
    self: &#34;Parser[Output[A_monoid]]&#34;, other: &#34;Parser[Output[B_monoid]]&#34;
) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
    &#34;&#34;&#34;
    Parse two arguments in either order.
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    usage: --verbose --debug
    Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

    Note that if more than two arguments are chained together with `+`, some combinations will not parse:
    &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
    {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
    usage: -a -b -c
    Expected &#39;-b&#39;. Got &#39;-c&#39;

    This makes more sense when one supplies the implicit parentheses:
    &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

    In order to chain together more than two arguments, use `nonpositional`:
    &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
    {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
    &#34;&#34;&#34;
    p = (self &gt;&gt; other) | (other.rshift(self))
    usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
    return replace(p, usage=usage)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__ge__"><code class="name flex">
<span>def <span class="ident">__ge__</span></span>(<span>self, f: Callable[[A_co], Monad[B_monoid]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~B_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>Return self&gt;=value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L118-L119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __ge__(self, f: Callable[[A_co], Monad[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[override]
    return self.bind(f)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__or__"><code class="name flex">
<span>def <span class="ident">__or__</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A_monoid]'", other: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[B_monoid]'") <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[typing.Union[~A_monoid, ~B_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, option, flag
&gt;&gt;&gt; p = option(&quot;option&quot;) | flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--option&quot;, &quot;x&quot;)
{'option': 'x'}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<p>Note that by default, <code>parse_args</code> adds <code>&gt;&gt; Parser.done()</code> to the end of parsers, causing
<code>p</code> to fail when both arguments are supplied:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--option&quot;, &quot;x&quot;)
usage: [--option OPTION | --verbose]
Unrecognized argument: --option
</code></pre>
<p>To disable this behavior, use <code>allow_unparsed</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--option&quot;, &quot;x&quot;, allow_unparsed=True)
{'verbose': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L121-L154" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __or__(  # type: ignore[override]
    self: &#34;Parser[A_monoid]&#34;,
    other: &#34;Parser[B_monoid]&#34;,
) -&gt; &#34;Parser[A_monoid | B_monoid]&#34;:
    &#34;&#34;&#34;
    Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

    &gt;&gt;&gt; from dollar_lambda import argument, option, flag
    &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
    {&#39;option&#39;: &#39;x&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}

    Note that by default, `parse_args` adds `&gt;&gt; Parser.done()` to the end of parsers, causing
    `p` to fail when both arguments are supplied:

    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
    usage: [--option OPTION | --verbose]
    Unrecognized argument: --option

    To disable this behavior, use `allow_unparsed`:
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;, allow_unparsed=True)
    {&#39;verbose&#39;: True}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[&#34;A_monoid | B_monoid&#34;]]:
        return self.parse(cs) | other.parse(cs)

    return Parser(
        f,
        usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
        helps={**self.helps, **other.helps},
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__rshift__"><code class="name flex">
<span>def <span class="ident">__rshift__</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]'", p: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[B_monoid]]'") <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[typing.Union[~A_monoid, ~B_monoid]]]</span>
</code></dt>
<dd>
<div class="desc"><p>This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
gets handed off to the second parser. If either parser fails, the whole thing fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;first&quot;) &gt;&gt; argument(&quot;second&quot;)
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
{'first': 'a', 'second': 'b'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)
usage: FIRST SECOND
The following arguments are required: second
&gt;&gt;&gt; p.parse_args(&quot;b&quot;)
usage: FIRST SECOND
The following arguments are required: second
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L161-L194" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __rshift__(
    self: &#34;Parser[Output[A_monoid]]&#34;, p: &#34;Parser[Output[B_monoid]]&#34;
) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
    &#34;&#34;&#34;
    This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
    gets handed off to the second parser. If either parser fails, the whole thing fails.

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
    usage: FIRST SECOND
    The following arguments are required: second
    &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
    usage: FIRST SECOND
    The following arguments are required: second
    &#34;&#34;&#34;

    def f(p1: Output[A_monoid]) -&gt; Parser[Output[A_monoid | B_monoid]]:
        def g(p2: Output[B_monoid]) -&gt; Parser[Output[A_monoid | B_monoid]]:
            # _p1 = p1 if isinstance(p1, Sequence) else Sequence(p1)
            # _p2 = p2 if isinstance(p2, Sequence) else Sequence(p2)
            return Parser.return_(p1 + p2)

        return p &gt;= g

    parser = self &gt;= f
    # parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
    return replace(
        parser,
        usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False),
        helps={**self.helps, **p.helps},
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__xor__"><code class="name flex">
<span>def <span class="ident">__xor__</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]'", other: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[B_monoid]]'") <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[typing.Union[~A_monoid, ~B_monoid]]]</span>
</code></dt>
<dd>
<div class="desc"><p>This is the same as <code>__or__</code>, but it succeeds only if one of the two parsers fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = argument(&quot;int&quot;, type=int) ^ argument(&quot;div&quot;, type=lambda x: 1 / float(x))
&gt;&gt;&gt; p.parse_args(&quot;inf&quot;)  # succeeds because int(&quot;inf&quot;) fails
{'div': 0.0}
&gt;&gt;&gt; p.parse_args(&quot;0&quot;)  # succeeds because 1 / 0 throws an error
{'int': 0}
&gt;&gt;&gt; p.parse_args(&quot;1&quot;)  # fails because both parsers succeed
Both parsers succeeded. This causes ^ to fail.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L196-L217" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def __xor__(
    self: &#34;Parser[Output[A_monoid]]&#34;, other: &#34;Parser[Output[B_monoid]]&#34;
) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
    &#34;&#34;&#34;
    This is the same as `__or__`, but it succeeds only if one of the two parsers fails.

    &gt;&gt;&gt; p = argument(&#34;int&#34;, type=int) ^ argument(&#34;div&#34;, type=lambda x: 1 / float(x))
    &gt;&gt;&gt; p.parse_args(&#34;inf&#34;)  # succeeds because int(&#34;inf&#34;) fails
    {&#39;div&#39;: 0.0}
    &gt;&gt;&gt; p.parse_args(&#34;0&#34;)  # succeeds because 1 / 0 throws an error
    {&#39;int&#39;: 0}
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;)  # fails because both parsers succeed
    Both parsers succeeded. This causes ^ to fail.
    &#34;&#34;&#34;
    p = (self.fails() &gt;&gt; other) | (other.fails() &gt;&gt; self)

    def f(error: ArgumentError) -&gt; ArgumentError:
        if isinstance(error, BinaryError):
            return ArgumentError(&#34;Both parsers succeeded. This causes ^ to fail.&#34;)
        return error

    return p.map_error(f)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A_monoid]'", f: Callable[[A_monoid], Result[B_monoid]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~B_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the output of <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> and applies <code>f</code> to it. Convert any errors that arise into <code>ArgumentError</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;hello&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;--hello&quot;)
{'hello': True}
</code></pre>
<p>This will double <code>p1</code>'s output:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p2 = p1.apply(lambda out: Result.return_(out + out))
&gt;&gt;&gt; p2.parse_args(&quot;--hello&quot;)
{'hello': [True, True]}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L219-L247" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply(self: &#34;Parser[A_monoid]&#34;, f: Callable[[A_monoid], Result[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[misc]
    # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
    &#34;&#34;&#34;
    Takes the output of `parser` and applies `f` to it. Convert any errors that arise into `ArgumentError`.

    &gt;&gt;&gt; p1 = flag(&#34;hello&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;--hello&#34;)
    {&#39;hello&#39;: True}

    This will double `p1`&#39;s output:
    &gt;&gt;&gt; p2 = p1.apply(lambda out: Result.return_(out + out))
    &gt;&gt;&gt; p2.parse_args(&#34;--hello&#34;)
    {&#39;hello&#39;: [True, True]}
    &#34;&#34;&#34;

    def g(a: A_monoid) -&gt; Parser[B_monoid]:
        try:
            y = f(a)
        except Exception as e:
            usage = f&#34;An argument {a}: raised exception {e}&#34;
            y = Result(ArgumentError(usage))
        return Parser(
            lambda cs: y &gt;= (lambda parsed: Result.return_(Parse(parsed, cs))),
            usage=self.usage,
            helps=self.helps,
        )

    p = self &gt;= g
    return replace(p, usage=self.usage, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.bind"><code class="name flex">
<span>def <span class="ident">bind</span></span>(<span>self, f: Callable[[A_co], Monad[B_monoid]]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~B_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new parser that</p>
<ol>
<li>applies <code>self</code>;</li>
<li>if this succeeds, applies <code>f</code> to the parsed component of the result.</li>
</ol>
<p><code>bind</code> is one of the functions that makes <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. But most users will
avoid using it directly, preferring higher level combinators like <code>&gt;&gt;</code> (<code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code>),
<code>|</code> (<code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>) and <code>+</code> (<code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code>).</p>
<p>Note that <code>&gt;=</code> as a synonym for <code>bind</code> (as defined in <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26"><code>pytypeclass</code></a>)
and we typically prefer using the infix operator to the spelled out method.</p>
<p>Let's start with our simplest parser, <code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = argument(&quot;some_dest&quot;)
</code></pre>
<p>Now let's use the <code><a title="dollar_lambda.matches" href="#dollar_lambda.matches">matches()</a></code> parser to write a function that takes the output of <code>p1</code> and fails unless
the next argument is the same as the first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(out: Output[Sequence[KeyValue[Any]]]) -&gt; Parser[Output[str]]:
...     *_, kv = out.get
...     return matches(kv.value)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = p1 &gt;= f
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;a&quot;)
{'a': 'a'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
Expected 'a'. Got 'b'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L249-L287" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bind(self, f: Callable[[A_co], Monad[B_monoid]]) -&gt; &#34;Parser[B_monoid]&#34;:  # type: ignore[override]
    &#34;&#34;&#34;
    Returns a new parser that

    1. applies `self`;
    2. if this succeeds, applies `f` to the parsed component of the result.

    `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
    avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
    `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

    Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
    and we typically prefer using the infix operator to the spelled out method.

    Let&#39;s start with our simplest parser, `argument`:
    &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

    Now let&#39;s use the `matches` parser to write a function that takes the output of `p1` and fails unless
    the next argument is the same as the first:
    &gt;&gt;&gt; def f(out: Output[Sequence[KeyValue[Any]]]) -&gt; Parser[Output[str]]:
    ...     *_, kv = out.get
    ...     return matches(kv.value)

    &gt;&gt;&gt; p = p1 &gt;= f
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
    {&#39;a&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    Expected &#39;a&#39;. Got &#39;b&#39;
    &#34;&#34;&#34;

    def h(parse: Parse[A_co]) -&gt; Result[Parse[B_monoid]]:
        y = f(parse.parsed)
        assert isinstance(y, Parser), y
        return y.parse(parse.unparsed)

    def g(cs: Sequence[str]) -&gt; Result[Parse[B_monoid]]:
        return self.parse(cs) &gt;= h

    return Parser(g, usage=None, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.fails"><code class="name flex">
<span>def <span class="ident">fails</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]'", a: Optional[Type[A_monoid]] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Succeeds only if self fails. Does not consume any input.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;x&quot;).fails().parse_args(&quot;not x&quot;, allow_unparsed=True)  # succeeds
{}
&gt;&gt;&gt; flag(&quot;x&quot;).fails().parse_args(&quot;-x&quot;, allow_unparsed=True)  # fails
Parser unexpectedly succeeded.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L330-L353" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fails(
    self: &#34;Parser[Output[A_monoid]]&#34;, a: Optional[Type[A_monoid]] = None
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Succeeds only if self fails. Does not consume any input.

    &gt;&gt;&gt; flag(&#34;x&#34;).fails().parse_args(&#34;not x&#34;, allow_unparsed=True)  # succeeds
    {}
    &gt;&gt;&gt; flag(&#34;x&#34;).fails().parse_args(&#34;-x&#34;, allow_unparsed=True)  # fails
    Parser unexpectedly succeeded.
    &#34;&#34;&#34;

    def g(cs: Sequence[str]) -&gt; Result[Parse[Output[A_monoid]]]:
        parse = self.parse(cs).get
        if isinstance(parse, Exception):
            return Result.return_(Parse(Output.zero(a), cs))
        else:
            return Result.zero(
                error=SuccessError(
                    &#34;Parser unexpectedly succeeded.&#34;, input=cs, output=parse
                )
            )

    return Parser(g, usage=None, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.handle_error"><code class="name flex">
<span>def <span class="ident">handle_error</span></span>(<span>self, error: ArgumentError) <span style="white-space: nowrap;">-></span> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L355-L375" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def handle_error(self, error: ArgumentError) -&gt; None:
    def print_usage(usage: str):
        self._print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in usage else &#34; &#34;)
        if &#34;\n&#34; in usage:
            usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in usage.split(&#34;\n&#34;)])
        self._print(usage)
        if self.helps:
            for k, v in self.helps.items():
                self._print(f&#34;{k}: {v}&#34;)

    if isinstance(error, HelpError):
        print_usage(error.usage)
    else:
        if self.usage:
            print_usage(self.usage)
        if error.usage:
            self._print(error.usage)
    if TESTING:
        return
    else:
        exit()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.ignore"><code class="name flex">
<span>def <span class="ident">ignore</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]'", a: Optional[Type[A_monoid]] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Ignores the output from a parser. This is useful when you expect
to give arguments to the command line that some other utility will
handle.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;hello&quot;).ignore()
</code></pre>
<p>This will not bind any value to <code>"hello"</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--hello&quot;)
{}
</code></pre>
<p>But <code>--hello</code> is still required:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args()
The following arguments are required: --hello
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L377-L402" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ignore(
    self: &#34;Parser[Output[A_monoid]]&#34;, a: Optional[Type[A_monoid]] = None
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Ignores the output from a parser. This is useful when you expect
    to give arguments to the command line that some other utility will
    handle.

    &gt;&gt;&gt; p = flag(&#34;hello&#34;).ignore()

    This will not bind any value to `&#34;hello&#34;`:
    &gt;&gt;&gt; p.parse_args(&#34;--hello&#34;)
    {}

    But `--hello` is still required:
    &gt;&gt;&gt; p.parse_args()
    The following arguments are required: --hello
    &#34;&#34;&#34;

    def g(keep: Parse[Output[A_monoid]]) -&gt; Result[Parse[Output[A_monoid]]]:
        return Result(NonemptyList(Parse(Output.zero(a), keep.unparsed)))

    def f(cs: Sequence[str]) -&gt; Result[Parse[Output[A_monoid]]]:
        return self.parse(cs) &gt;= g

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.many"><code class="name flex">
<span>def <span class="ident">many</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]'", max: int = 80) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> zero or more times (like <code>*</code> in regexes).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>max</code></strong> :&ensp;<code>int</code></dt>
<dd>Limits the number of times <code>many</code> is applied in order to prevent <code>RecursionError</code>s.
The default for this can be increased by either setting <code>parser.MAX_MANY</code> or
the environment variable <code>DOLLAR_LAMBDA_MAX_MANY</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args()
{}
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)
{'as-many-as-you-like': 'a'}
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
{'as-many-as-you-like': ['a', 'b']}
</code></pre>
<p>Note that if <code>self</code> contains <code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>, the arguments can be
heterogenous:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p = p.many()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;) # mix --verbose and --quiet
{'verbose': True, 'quiet': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L404-L442" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def many(
    self: &#34;Parser[Output[A_monoid]]&#34;, max: int = MAX_MANY
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Applies `self` zero or more times (like `*` in regexes).

    Parameters
    ----------

    max: int
        Limits the number of times `many` is applied in order to prevent `RecursionError`s.
        The default for this can be increased by either setting `parser.MAX_MANY` or
        the environment variable `DOLLAR_LAMBDA_MAX_MANY`.

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args()
    {}
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
    {&#39;as-many-as-you-like&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    {&#39;as-many-as-you-like&#39;: [&#39;a&#39;, &#39;b&#39;]}

    Note that if `self` contains `Parser.__or__`, the arguments can be
    heterogenous:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
    &gt;&gt;&gt; p = p.many()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;) # mix --verbose and --quiet
    {&#39;verbose&#39;: True, &#39;quiet&#39;: True}
    &#34;&#34;&#34;
    if max == 0:
        p = self.empty()
    else:
        max -= 1
        assert max &gt;= 0, max
        p = self.many1(max=max) | self.empty()
    return replace(p, usage=f&#34;[{self.usage} ...]&#34;)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.many1"><code class="name flex">
<span>def <span class="ident">many1</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]'", max: int = 80) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> one or more times (like <code>+</code> in regexes).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>max</code></strong> :&ensp;<code>int</code></dt>
<dd>Limits the number of times <code>many1</code> is applied in order to prevent <code>RecursionError</code>s.
The default for this can be increased by either setting <code>parser.MAX_MANY</code> or
the environment variable <code>DOLLAR_LAMBDA_MAX_MANY</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;1-or-more&quot;).many1()
&gt;&gt;&gt; p.parse_args(&quot;1&quot;)
{'1-or-more': '1'}
&gt;&gt;&gt; p.parse_args(&quot;1&quot;, &quot;2&quot;)
{'1-or-more': ['1', '2']}
&gt;&gt;&gt; p.parse_args()
**```usage```** :&amp;ensp;`1-OR-MORE [1-OR-MORE ...]`
:   &amp;nbsp;


The following arguments are required: 1-or-more
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L444-L473" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def many1(
    self: &#34;Parser[Output[A_monoid]]&#34;, max: int = MAX_MANY
) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Applies `self` one or more times (like `+` in regexes).

    Parameters
    ----------

    max: int
        Limits the number of times `many1` is applied in order to prevent `RecursionError`s.
        The default for this can be increased by either setting `parser.MAX_MANY` or
        the environment variable `DOLLAR_LAMBDA_MAX_MANY`.

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
    {&#39;1-or-more&#39;: &#39;1&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;)
    {&#39;1-or-more&#39;: [&#39;1&#39;, &#39;2&#39;]}
    &gt;&gt;&gt; p.parse_args()
    usage: 1-OR-MORE [1-OR-MORE ...]
    The following arguments are required: 1-or-more
    &#34;&#34;&#34;

    return Parser(
        lambda cs: (self &gt;&gt; self.many(max=max)).parse(cs),
        usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
        helps=self.helps,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.map_error"><code class="name flex">
<span>def <span class="ident">map_error</span></span>(<span>self, f: Callable[[ArgumentError], ArgumentError]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L475-L483" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def map_error(self, f: Callable[[ArgumentError], ArgumentError]) -&gt; &#34;Parser[A_co]&#34;:
    def g(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        parse = self.parse(cs)
        if isinstance(parse.get, ArgumentError):
            return Result.zero(error=f(parse.get))
        else:
            return parse

    return Parser(g, usage=None, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.nesting"><code class="name flex">
<span>def <span class="ident">nesting</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[Sequence[KeyValue[Any]]]]'") <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[typing.Any]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Breaks the output of the wrapped parser into nested outputs. See the <a href="#nesting-output"><code>Nesting output</code></a>
section of the documentation for more information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L612-L635" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nesting(
    self: &#34;Parser[Output[Sequence[KeyValue[Any]]]]&#34;,
) -&gt; &#34;Parser[Output[Sequence[KeyValue[Any]]]]&#34;:
    &#34;&#34;&#34;
    Breaks the output of the wrapped parser into nested outputs. See the [`Nesting output`](#nesting-output)
    section of the documentation for more information.
    &#34;&#34;&#34;

    def g(out: Output[Sequence[KeyValue[str]]]) -&gt; Result[Output]:
        d = out.get
        if not d:
            raise RuntimeError(&#34;Invoked nested on a parser that returns no output.&#34;)
        *tail, head = out.get
        if &#34;.&#34; in head.key:
            key, hd, *tl = head.key.split(&#34;.&#34;)
            parents = NonemptyList.make(hd, *tl)
            path = TreePath(parents, head.value)
            kv = KeyValue(key, path)
            return Result.return_(Output(Sequence([*tail, kv])))
        else:
            return Result.return_(out)

    p = self.apply(g)
    return replace(p, usage=self.usage, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.optional"><code class="name flex">
<span>def <span class="ident">optional</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]'") <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[~A_monoid]]</span>
</code></dt>
<dd>
<div class="desc"><p>Allows arguments to be optional:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;optional&quot;)
&gt;&gt;&gt; p = p1.optional()
&gt;&gt;&gt; p.parse_args(&quot;--optional&quot;)
{'optional': True}
&gt;&gt;&gt; p.parse_args(&quot;--misspelled&quot;, allow_unparsed=True)  # succeeds with no output
{}
&gt;&gt;&gt; p1.parse_args(&quot;--misspelled&quot;)
usage: --optional
Expected '--optional'. Got '--misspelled'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L485-L498" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def optional(self: &#34;Parser[Output[A_monoid]]&#34;) -&gt; &#34;Parser[Output[A_monoid]]&#34;:
    &#34;&#34;&#34;
    Allows arguments to be optional:
    &gt;&gt;&gt; p1 = flag(&#34;optional&#34;)
    &gt;&gt;&gt; p = p1.optional()
    &gt;&gt;&gt; p.parse_args(&#34;--optional&#34;)
    {&#39;optional&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--misspelled&#34;, allow_unparsed=True)  # succeeds with no output
    {}
    &gt;&gt;&gt; p1.parse_args(&#34;--misspelled&#34;)
    usage: --optional
    Expected &#39;--optional&#39;. Got &#39;--misspelled&#39;
    &#34;&#34;&#34;
    return self | self.empty()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, cs: Sequence[str]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="parser.html#dollar_lambda.parser.Parse">Parse</a>[+A_co]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the parser to the input sequence <code>cs</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L500-L504" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
    &#34;&#34;&#34;
    Applies the parser to the input sequence `cs`.
    &#34;&#34;&#34;
    return self.f(cs)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output]'", *args: str, allow_unparsed: bool = False, check_help: bool = True) <span style="white-space: nowrap;">-></span> Optional[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>The main way the user extracts parsed results from the parser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>str</code></dt>
<dd>A sequence of strings to parse. If empty, defaults to <code>sys.argv[1:]</code>.</dd>
<dt><strong><code>allow_unparsed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to cause parser to fail if there are unparsed inputs. Note that setting this to false
may cause unexpected behavior when using <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> or <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code>.</dd>
<dt><strong><code>check_help</code></strong> :&ensp;<code>bool</code></dt>
<dd>Before running the parser, checks if the input string is <code>--help</code> or <code>-h</code>.
If it is, returns the usage message.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;-h&quot;)
usage: A
&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;--help&quot;)
usage: A
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L506-L553" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parse_args(
    self: &#34;Parser[Output]&#34;,
    *args: str,
    allow_unparsed: bool = False,
    check_help: bool = True,
) -&gt; &#34;Optional[Dict[str, Any]]&#34;:
    &#34;&#34;&#34;
    The main way the user extracts parsed results from the parser.

    Parameters
    ----------
    args : str
        A sequence of strings to parse. If empty, defaults to `sys.argv[1:]`.
    allow_unparsed : bool
        Whether to cause parser to fail if there are unparsed inputs. Note that setting this to false
        may cause unexpected behavior when using `nonpositional` or `Args`.
    check_help : bool
        Before running the parser, checks if the input string is `--help` or `-h`.
        If it is, returns the usage message.

    Examples
    --------

    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
    usage: A
    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
    usage: A
    &#34;&#34;&#34;
    _args = args if args or TESTING else sys.argv[1:]
    if not allow_unparsed:
        return (self &gt;&gt; Parser[Output].done()).parse_args(
            *_args,
            allow_unparsed=True,
            check_help=check_help,
        )
    if check_help:
        return self.wrap_help().parse_args(
            *_args,
            allow_unparsed=allow_unparsed,
            check_help=False,
        )
    result = self.parse(Sequence(list(_args))).get
    if isinstance(result, ArgumentError):
        self.handle_error(result)
        return None
    get = result.head.parsed.get
    assert isinstance(get, Sequence), get
    return get.to_dict()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.rshift"><code class="name flex">
<span>def <span class="ident">rshift</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[A_monoid]]'", p: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[B_monoid]]'") <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[typing.Union[~A_monoid, ~B_monoid]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L156-L159" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rshift(
    self: &#34;Parser[Output[A_monoid]]&#34;, p: &#34;Parser[Output[B_monoid]]&#34;
) -&gt; &#34;Parser[Output[A_monoid | B_monoid]]&#34;:
    return self &gt;&gt; p</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.sat"><code class="name flex">
<span>def <span class="ident">sat</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A_monoid]'", predicate: Callable[[A_monoid], bool], on_fail: Callable[[A_monoid], ArgumentError]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~A_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>, applies a predicate to the result and fails if this returns false.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = option(&quot;x&quot;, type=int).many().sat(
...     lambda out: sum(out.get.values()) &gt; 0,
...     lambda out: ArgumentError(f&quot;The values in {list(out.get.values())} must sum to more than 0.&quot;),
... )
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-1&quot;, &quot;-x&quot;, &quot;1&quot;)  # fails
usage: [-x X ...]
The values in [-1, 1] must sum to more than 0.
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-1&quot;, &quot;-x&quot;, &quot;2&quot;)  # succeeds
{'x': [-1, 2]}
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parser</code></strong> :&ensp;<code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A]</code></dt>
<dd>The parser to apply.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Callable[[A], bool]</code></dt>
<dd>The predicate to apply to the result of <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>. <code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat()</a></code> fails if this predicate returns false.</dd>
<dt><strong><code>on_fail</code></strong> :&ensp;<code>Callable[[A], ArgumentError]</code></dt>
<dd>A function producing an ArgumentError to return if the predicate fails.
Takes the output of <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> as an argument.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L577-L610" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sat(
    self: &#34;Parser[A_monoid]&#34;,
    predicate: Callable[[A_monoid], bool],
    on_fail: Callable[[A_monoid], ArgumentError],
) -&gt; &#34;Parser[A_monoid]&#34;:
    &#34;&#34;&#34;
    Applies `parser`, applies a predicate to the result and fails if this returns false.

    &gt;&gt;&gt; p = option(&#34;x&#34;, type=int).many().sat(
    ...     lambda out: sum(out.get.values()) &gt; 0,
    ...     lambda out: ArgumentError(f&#34;The values in {list(out.get.values())} must sum to more than 0.&#34;),
    ... )
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;1&#34;)  # fails
    usage: [-x X ...]
    The values in [-1, 1] must sum to more than 0.

    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;2&#34;)  # succeeds
    {&#39;x&#39;: [-1, 2]}

    Parameters
    ----------
    parser : Parser[A]
        The parser to apply.
    predicate : Callable[[A], bool]
        The predicate to apply to the result of `parser`. `sat` fails if this predicate returns false.
    on_fail : Callable[[A], ArgumentError]
        A function producing an ArgumentError to return if the predicate fails.
        Takes the output of `parser` as an argument.
    &#34;&#34;&#34;

    def f(x: A_monoid) -&gt; Result[A_monoid]:
        return Result(NonemptyList(x) if predicate(x) else on_fail(x))

    return self.apply(f)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Output[Sequence[KeyValue[str]]]]'", f: Callable[[str], Any]) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Output" href="sequence.html#dollar_lambda.sequence.Output">Output</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.sequence.KeyValue" href="sequence.html#dollar_lambda.sequence.KeyValue">KeyValue</a>[str]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code><a title="dollar_lambda.apply" href="#dollar_lambda.apply">apply()</a></code> that simply applies <code>f</code> to the value of the most recently parsed input.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = option(&quot;x&quot;) &gt;&gt; option(&quot;y&quot;)
&gt;&gt;&gt; p = p1.type(int)
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)  # converts &quot;1&quot; but not &quot;2&quot;
{'x': '1', 'y': 2}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L637-L661" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def type(
    self: &#34;Parser[Output[Sequence[KeyValue[str]]]]&#34;, f: Callable[[str], Any]
) -&gt; &#34;Parser[Output[Sequence[KeyValue[str]]]]&#34;:
    &#34;&#34;&#34;
    A wrapper around `apply` that simply applies `f` to the value of the most recently parsed input.
    &gt;&gt;&gt; p1 = option(&#34;x&#34;) &gt;&gt; option(&#34;y&#34;)
    &gt;&gt;&gt; p = p1.type(int)
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)  # converts &#34;1&#34; but not &#34;2&#34;
    {&#39;x&#39;: &#39;1&#39;, &#39;y&#39;: 2}
    &#34;&#34;&#34;

    def g(out: Output[Sequence[KeyValue[str]]]) -&gt; Result[Output]:
        d = out.get
        if not d:
            raise RuntimeError(&#34;Invoked type on a parser that returns no output.&#34;)
        *tail, head = out.get
        try:
            y = f(head.value)
        except Exception as e:
            usage = f&#34;argument {head.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        return Result.return_(Output(Sequence([*tail, KeyValue(head.key, y)])))

    p = self.apply(g)
    return replace(p, usage=self.usage, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.wrap_error"><code class="name flex">
<span>def <span class="ident">wrap_error</span></span>(<span>self, error: ArgumentError) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L663-L664" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrap_error(self, error: ArgumentError) -&gt; &#34;Parser[A_co]&#34;:
    return self.map_error(lambda _: error)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.wrap_help"><code class="name flex">
<span>def <span class="ident">wrap_help</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A_monoid]'", a: Optional[Type[A_monoid]] = None) <span style="white-space: nowrap;">-></span> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~A_monoid]</span>
</code></dt>
<dd>
<div class="desc"><p>This checks for the <code>--help</code> or <code>-h</code> flag before applying <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>.
If either of the flags is present, returns the usage message for <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;help&quot;, help=&quot;Print this help message.&quot;).wrap_help()
&gt;&gt;&gt; p.parse_args(&quot;--help&quot;)
usage: --help
help: Print this help message.
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: --help
help: Print this help message.
</code></pre>
<p>We can use <code>wrap_help</code> to print partial usage messages, e.g. for subcommands:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; subcommand1 = matches(&quot;subcommand1&quot;) &gt;&gt; option(&quot;option1&quot;).wrap_help()
&gt;&gt;&gt; subcommand2 = matches(&quot;subcommand2&quot;) &gt;&gt; option(&quot;option2&quot;).wrap_help()
&gt;&gt;&gt; p = subcommand1 | subcommand2
&gt;&gt;&gt; p.parse_args(&quot;subcommand1&quot;, &quot;-h&quot;)
usage: --option1 OPTION1
&gt;&gt;&gt; p.parse_args(&quot;subcommand2&quot;, &quot;-h&quot;)
usage: --option2 OPTION2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/0a98f2938df54fd424053561ac0eac92d9580127/dollar_lambda/parser.py#L666-L693" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrap_help(
    self: &#34;Parser[A_monoid]&#34;, a: Optional[Type[A_monoid]] = None
) -&gt; &#34;Parser[A_monoid]&#34;:
    &#34;&#34;&#34;
    This checks for the `--help` or `-h` flag before applying `parser`.
    If either of the flags is present, returns the usage message for `parser`.

    &gt;&gt;&gt; p = flag(&#34;help&#34;, help=&#34;Print this help message.&#34;).wrap_help()
    &gt;&gt;&gt; p.parse_args(&#34;--help&#34;)
    usage: --help
    help: Print this help message.
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --help
    help: Print this help message.

    We can use `wrap_help` to print partial usage messages, e.g. for subcommands:
    &gt;&gt;&gt; subcommand1 = matches(&#34;subcommand1&#34;) &gt;&gt; option(&#34;option1&#34;).wrap_help()
    &gt;&gt;&gt; subcommand2 = matches(&#34;subcommand2&#34;) &gt;&gt; option(&#34;option2&#34;).wrap_help()
    &gt;&gt;&gt; p = subcommand1 | subcommand2
    &gt;&gt;&gt; p.parse_args(&#34;subcommand1&#34;, &#34;-h&#34;)
    usage: --option1 OPTION1
    &gt;&gt;&gt; p.parse_args(&#34;subcommand2&#34;, &#34;-h&#34;)
    usage: --option2 OPTION2
    &#34;&#34;&#34;
    _help_parser: Parser[Output[A_monoid]] = help_parser(self.usage, Output.zero(a))

    p = _help_parser &gt;= (lambda _: self)
    return replace(p, usage=self.usage, helps=self.helps)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="dollar-lambda home" href="https://ethanabrooks.github.io/dollar-lambda">
<img src="https://ethanabrooks.github.io/dollar-lambda/logo.png" alt="">
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#highlights">Highlights</a><ul>
<li><a href="#the-command-decorator">The @command decorator</a></li>
<li><a href="#commandtree-for-dynamic-dispatch">CommandTree for dynamic dispatch</a></li>
<li><a href="#lower-level-syntax">Lower-level syntax</a></li>
</ul>
</li>
<li><a href="#tutorial">Tutorial</a><ul>
<li><a href="#an-example-from-argparse">An example from argparse</a></li>
<li><a href="#equivalent-in-lower-level-syntax">Equivalent in lower-level syntax</a></li>
<li><a href="#high-level-parsers">High-Level Parsers</a><ul>
<li><a href="#flag">flag</a></li>
<li><a href="#option">option</a></li>
</ul>
</li>
<li><a href="#parser-combinators">Parser Combinators</a><ul>
<li><a href="#_1">|</a></li>
<li><a href="#nonpositional-and">nonpositional and +</a></li>
</ul>
</li>
<li><a href="#putting-it-all-together">Putting it all together</a></li>
<li><a href="#variations-on-the-example">Variations on the example</a><ul>
<li><a href="#positional-arguments">Positional arguments</a></li>
<li><a href="#variable-numbers-of-arguments">Variable numbers of arguments</a></li>
<li><a href="#many">many</a></li>
<li><a href="#many1">many1</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#commandtree-tutorial">CommandTree Tutorial</a><ul>
<li><a href="#commandtreecommand">CommandTree.command</a></li>
<li><a href="#commandtreesubcommand">CommandTree.subcommand</a></li>
</ul>
</li>
<li><a href="#use-with-config-files">Use with config files</a></li>
<li><a href="#nesting-output">Nesting output</a></li>
<li><a href="#ignoring-arguments">Ignoring arguments</a></li>
<li><a href="#why">Why $λ?</a><ul>
<li><a href="#versatile">Versatile</a></li>
<li><a href="#type-safe">Type-safe</a></li>
<li><a href="#concise">Concise</a></li>
<li><a href="#lightweight">Lightweight</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="dollar_lambda.args" href="args.html">dollar_lambda.args</a></code></li>
<li><code><a title="dollar_lambda.decorators" href="decorators.html">dollar_lambda.decorators</a></code></li>
<li><code><a title="dollar_lambda.error" href="error.html">dollar_lambda.error</a></code></li>
<li><code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code></li>
<li><code><a title="dollar_lambda.result" href="result.html">dollar_lambda.result</a></code></li>
<li><code><a title="dollar_lambda.sequence" href="sequence.html">dollar_lambda.sequence</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="dollar_lambda.apply" href="#dollar_lambda.apply">apply</a></code></li>
<li><code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument</a></code></li>
<li><code><a title="dollar_lambda.command" href="#dollar_lambda.command">command</a></code></li>
<li><code><a title="dollar_lambda.defaults" href="#dollar_lambda.defaults">defaults</a></code></li>
<li><code><a title="dollar_lambda.field" href="#dollar_lambda.field">field</a></code></li>
<li><code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag</a></code></li>
<li><code><a title="dollar_lambda.item" href="#dollar_lambda.item">item</a></code></li>
<li><code><a title="dollar_lambda.matches" href="#dollar_lambda.matches">matches</a></code></li>
<li><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional</a></code></li>
<li><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option</a></code></li>
<li><code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.Args.parse_args" href="#dollar_lambda.Args.parse_args">parse_args</a></code></li>
<li><code><a title="dollar_lambda.Args.parser" href="#dollar_lambda.Args.parser">parser</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.CommandTree.command" href="#dollar_lambda.CommandTree.command">command</a></code></li>
<li><code><a title="dollar_lambda.CommandTree.subcommand" href="#dollar_lambda.CommandTree.subcommand">subcommand</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code></h4>
<ul class="two-column">
<li><code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">__add__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__ge__" href="#dollar_lambda.Parser.__ge__">__ge__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">__or__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">__rshift__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__xor__" href="#dollar_lambda.Parser.__xor__">__xor__</a></code></li>
<li><code><a title="dollar_lambda.Parser.apply" href="#dollar_lambda.Parser.apply">apply</a></code></li>
<li><code><a title="dollar_lambda.Parser.bind" href="#dollar_lambda.Parser.bind">bind</a></code></li>
<li><code><a title="dollar_lambda.Parser.done" href="#dollar_lambda.Parser.done">done</a></code></li>
<li><code><a title="dollar_lambda.Parser.empty" href="#dollar_lambda.Parser.empty">empty</a></code></li>
<li><code><a title="dollar_lambda.Parser.f" href="#dollar_lambda.Parser.f">f</a></code></li>
<li><code><a title="dollar_lambda.Parser.fails" href="#dollar_lambda.Parser.fails">fails</a></code></li>
<li><code><a title="dollar_lambda.Parser.handle_error" href="#dollar_lambda.Parser.handle_error">handle_error</a></code></li>
<li><code><a title="dollar_lambda.Parser.helps" href="#dollar_lambda.Parser.helps">helps</a></code></li>
<li><code><a title="dollar_lambda.Parser.ignore" href="#dollar_lambda.Parser.ignore">ignore</a></code></li>
<li><code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">many</a></code></li>
<li><code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">many1</a></code></li>
<li><code><a title="dollar_lambda.Parser.map_error" href="#dollar_lambda.Parser.map_error">map_error</a></code></li>
<li><code><a title="dollar_lambda.Parser.nesting" href="#dollar_lambda.Parser.nesting">nesting</a></code></li>
<li><code><a title="dollar_lambda.Parser.optional" href="#dollar_lambda.Parser.optional">optional</a></code></li>
<li><code><a title="dollar_lambda.Parser.parse" href="#dollar_lambda.Parser.parse">parse</a></code></li>
<li><code><a title="dollar_lambda.Parser.parse_args" href="#dollar_lambda.Parser.parse_args">parse_args</a></code></li>
<li><code><a title="dollar_lambda.Parser.return_" href="#dollar_lambda.Parser.return_">return_</a></code></li>
<li><code><a title="dollar_lambda.Parser.rshift" href="#dollar_lambda.Parser.rshift">rshift</a></code></li>
<li><code><a title="dollar_lambda.Parser.sat" href="#dollar_lambda.Parser.sat">sat</a></code></li>
<li><code><a title="dollar_lambda.Parser.type" href="#dollar_lambda.Parser.type">type</a></code></li>
<li><code><a title="dollar_lambda.Parser.usage" href="#dollar_lambda.Parser.usage">usage</a></code></li>
<li><code><a title="dollar_lambda.Parser.wrap_error" href="#dollar_lambda.Parser.wrap_error">wrap_error</a></code></li>
<li><code><a title="dollar_lambda.Parser.wrap_help" href="#dollar_lambda.Parser.wrap_help">wrap_help</a></code></li>
<li><code><a title="dollar_lambda.Parser.zero" href="#dollar_lambda.Parser.zero">zero</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</html>
