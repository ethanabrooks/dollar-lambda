<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dollar_lambda.decorators API documentation</title>
<meta name="description" content="Defines the `command` decorator and the `CommandTree` class." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&family=IBM+Plex+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
body {
font-family: 'IBM Plex Sans', sans-serif;
line-height: 1.45;
font-size: 15px;
}
pre, code {
font-family: Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", Monaco, "Courier New", Courier, monospace;
}
p code {
white-space: nowrap;
}
</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:50%;max-height:10em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="file:///Users/ethanbrooks/monad_argparse/docs/dollar_lambda/index.html">
<link rel="icon" href="https://ethanabrooks.github.io/dollar-lambda/logo.png">
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dollar_lambda.decorators</code></h1>
<a href="https://github.com/ethanabrooks/dollar-lambda" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
</svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</header>
<section id="section-intro">
<p>Defines the <code><a title="dollar_lambda.decorators.command" href="#dollar_lambda.decorators.command">command()</a></code> decorator and the <code><a title="dollar_lambda.decorators.CommandTree" href="#dollar_lambda.decorators.CommandTree">CommandTree</a></code> class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/6985236c77c096ca75bd34bac6009a72b619c85c/dollar_lambda/decorators.py#L1-L526" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Defines the `command` decorator and the `CommandTree` class.
&#34;&#34;&#34;
from __future__ import annotations

import operator
import sys
import typing
from dataclasses import dataclass, field, replace
from functools import reduce
from inspect import Parameter, signature
from typing import Any, Callable, Iterator, List, Optional, Type, TypeVar

from pytypeclass import Monoid
from pytypeclass.nonempty_list import NonemptyList

from dollar_lambda import parser as parser_mod
from dollar_lambda.args import _ArgsField
from dollar_lambda.error import ArgumentError
from dollar_lambda.parser import Parse, Parser, matches
from dollar_lambda.result import Result
from dollar_lambda.sequence import KeyValue, Output, Sequence

A = TypeVar(&#34;A&#34;)
B = TypeVar(&#34;B&#34;)
A_co = TypeVar(&#34;A_co&#34;, covariant=True)


def _func_to_parser(
    func: Callable,
    exclude: Optional[List[str]],
    flip_bools: bool,
    help: Optional[typing.Dict[str, str]],
    parsers: Optional[typing.Dict[str, Parser[Output]]],
    repeated: Optional[Parser[Output]],
) -&gt; Parser:
    _exclude = [] if exclude is None else exclude
    _help = {} if help is None else help
    _parsers = {} if parsers is None else parsers

    types = typing.get_type_hints(func)  # see https://peps.python.org/pep-0563/
    p = [
        _parsers.get(
            k,
            _ArgsField(
                name=k,
                default=None if v.default == Parameter.empty else v.default,
                help=_help.get(k),
                type=types.get(k, str),
            ),
        )
        for k, v in signature(func).parameters.items()
        if k not in _exclude
    ]
    return _ArgsField.parser(*p, flip_bools=flip_bools, repeated=repeated)


def command(
    flip_bools: bool = True,
    help: Optional[typing.Dict[str, str]] = None,
    parsers: Optional[typing.Dict[str, Parser[Output]]] = None,
    repeated: Optional[Parser[Output]] = None,
) -&gt; Callable[[Callable], Callable]:
    &#34;&#34;&#34;
    A succinct way to generate a simple `nonpositional` parser. `@command` derives the
    component parsers from the function&#39;s signature and automatically executes the function with
    the parsed arguments, if parsing succeeds:

    &gt;&gt;&gt; @command(help=dict(a=&#34;something about a&#34;))
    ... def f(a: int = 1, b: bool = False):
    ...     return dict(a=a, b=b)
    &gt;&gt;&gt; f(&#34;-a&#34;, &#34;2&#34;, &#34;-b&#34;)
    {&#39;a&#39;: 2, &#39;b&#39;: True}

    If the wrapped function receives no arguments (as in `f()`), the parser will take
    `sys.argv[1:]` as the input.

    Note that `@command` does not handle mutually exclusive arguments or alternative
    arguments.

    Parameters
    ----------
    flip_bools : bool
        For boolean arguments that default to true, this changes the flag from `--{dest}` to `--no-{dest}`:

    help : dict[str, str]
        A dictionary of help strings for the arguments.

    repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
        If provided, this parser gets applied repeatedly (zero or more times) at all positions.

    strings : dict[str, str]
        This dictionary maps variable names to the strings that the parser will look for in the input.

    Examples
    --------

    &gt;&gt;&gt; @command()
    ... def f(cuda: bool = True):
    ...     return dict(cuda=cuda)
    &gt;&gt;&gt; f()
    {&#39;cuda&#39;: True}
    &gt;&gt;&gt; f(&#34;--no-cuda&#34;)  # flip_bools adds --no- to the flag
    {&#39;cuda&#39;: False}

    As the following example demonstrates, when `flip_bools=False` output can be somewhat confusing:

    &gt;&gt;&gt; @command(flip_bools=False)
    ... def f(cuda: bool = True):
    ...     return dict(cuda=cuda)
    &gt;&gt;&gt; f(&#34;--cuda&#34;)
    {&#39;cuda&#39;: False}

    Here is an example using the `help` parameter:

    &gt;&gt;&gt; @command(help=dict(quiet=&#34;Be quiet&#34;))
    ... def f(quiet: bool):
    ...     return dict(quiet=quiet)
    &gt;&gt;&gt; f(&#34;--help&#34;)
    usage: --quiet
    quiet: Be quiet

    Here is an example using the `parser` parameter:

    TODO!
    &#34;&#34;&#34;

    def wrapper(func: Callable) -&gt; Callable:
        p = _func_to_parser(
            func,
            exclude=None,
            flip_bools=flip_bools,
            help=help,
            parsers=parsers,
            repeated=repeated,
        )
        p = p.wrap_help()

        def wrapped(*args) -&gt; Any:
            parsed = p.parse_args(*args)
            if parsed is None:
                return
            return func(**parsed)

        return wrapped

    return wrapper


@dataclass
class _FunctionPair(Monoid[A_co]):
    seq: Sequence[KeyValue[A_co]]
    function: Optional[Callable]

    def __add__(self: &#34;_FunctionPair[A]&#34;, other: &#34;_FunctionPair[B] | Sequence[KeyValue[B]]&#34;) -&gt; &#34;_FunctionPair[A | B]&#34;:  # type: ignore[override]
        return self.add(other)

    def __or__(self: &#34;_FunctionPair[A]&#34;, other: &#34;_FunctionPair[B] | Sequence[KeyValue[B]]&#34;) -&gt; &#34;_FunctionPair[A | B]&#34;:  # type: ignore[override]
        return self.add(other)

    def add(self: &#34;_FunctionPair[A]&#34;, other: &#34;_FunctionPair[B] | Sequence[KeyValue[B]]&#34;) -&gt; &#34;_FunctionPair[A | B]&#34;:  # type: ignore[override]
        if isinstance(other, Sequence):
            function = self.function
            seq = other
        else:
            function = self.function if other.function is None else other.function
            seq = other.seq
        return _FunctionPair(seq=self.seq | seq, function=function)

    @classmethod
    def command(
        cls: Type[&#34;_FunctionPair[Sequence[KeyValue[Any]]]&#34;],
        func: Callable,
        usage: Optional[str] = None,
        help: Optional[typing.Dict[str, str]] = None,
    ) -&gt; Parser[Output[&#34;_FunctionPair[Any]&#34;]]:
        _help = {} if help is None else help

        def f(
            cs: Sequence[str],
        ) -&gt; Result[Parse[Output[_FunctionPair[Sequence[KeyValue[Any]]]]]]:
            return Result.return_(
                Parse(
                    parsed=Output(_FunctionPair(Sequence[KeyValue[Any]].zero(), func)),
                    unparsed=cs,
                )
            )

        return Parser(f, usage=usage, helps=_help)

    @classmethod
    def subcommand(
        cls: Type[&#34;_FunctionPair[A]&#34;],
        func: Callable,
        usage: Optional[str] = None,
        help: Optional[typing.Dict[str, str]] = None,
    ) -&gt; Parser[Output[&#34;_FunctionPair[str]&#34;]]:
        _help = {} if help is None else help

        # def f(
        #     _: Sequence[KeyValue[str]],
        # ) -&gt; Parser[FunctionPair[KeyValue[str]]]:
        #     return Parser[FunctionPair[KeyValue[str]]](g, usage=usage, helps=_help)

        def g(
            cs: Sequence[str],
        ) -&gt; Result[Parse[Output[_FunctionPair[str]]]]:
            return Result.return_(
                Parse(
                    parsed=Output(_FunctionPair(Sequence[KeyValue[str]].zero(), func)),
                    unparsed=cs,
                )
            )

        eq = matches(func.__name__)
        p = eq &gt;= (
            lambda _: Parser[Output[_FunctionPair[str]]](g, usage=usage, helps=_help)
        )
        return replace(p, usage=eq.usage, helps=eq.helps)

    @classmethod
    def zero(cls: Type[Monoid[A]]) -&gt; Monoid[A]:
        return _FunctionPair(Sequence[KeyValue[A]].zero(), function=None)


@dataclass
class _Node:
    can_run: bool
    function: Callable
    flip_bools: bool
    help: Optional[typing.Dict[str, str]]
    parsers: Optional[typing.Dict[str, Parser[Output]]]
    repeated: Optional[Parser[Output]]
    subcommand: bool
    tree: Optional[&#34;CommandTree&#34;]

    def parser(self, *exclude: str) -&gt; Parser[Output[_FunctionPair[Any]]]:
        p1: Parser[Output[_FunctionPair[str]]] = (
            _FunctionPair.subcommand(self.function)
            if self.subcommand
            else _FunctionPair[Any].command(self.function)
        )
        p2: Parser[Output[_FunctionPair[str]]] = _func_to_parser(
            self.function,
            exclude=list(exclude),
            flip_bools=self.flip_bools,
            help=self.help,
            parsers=self.parsers,
            repeated=self.repeated,
        )
        return p1 &gt;&gt; p2

    def variable_names(self) -&gt; Iterator[str]:
        yield from signature(self.function).parameters.keys()


@dataclass
class CommandTree:
    &#34;&#34;&#34;
    Allows parsers to dynamically dispatch their results based on the input. For usage details,
    see the [`CommandTree` tutorial](#commandtree-tutorial).
    &#34;&#34;&#34;

    _children: List[_Node] = field(default_factory=list)
    _can_run: bool = True

    def command(
        self,
        can_run: bool = True,
        flip_bools: bool = True,
        help: Optional[typing.Dict[str, str]] = None,
        parsers: Optional[typing.Dict[str, Parser[Output]]] = None,
        repeated: Optional[Parser[Output]] = None,
    ) -&gt; Callable:
        &#34;&#34;&#34;
        A decorator for adding a function as a child of this tree.

        Parameters
        ----------

        can_run: bool
            Whether the parser will permit the decorated function to run if no further arguments are supplied.

        flip_bools: bool
            Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

        help: dict
            A dictionary of help strings for the arguments.

        repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
            If provided, this parser gets applied repeatedly (zero or more times) at all positions.

        parsers: dict
            TODO

        Examples
        --------
        With `flip_bools` set to `True`:
        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(flip_bools=True)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: --no-b
        b: (default: True)

        With `flip_bools` set to `False`:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(flip_bools=False)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: -b
        b: (default: True)


        With `can_run` set to `True` (the default), we can run `f1` by not passing arguments
        for the `f1`&#39;s children:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(can_run=True)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.command()
        ... def g1(n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: -b -n N

        &gt;&gt;&gt; tree(&#34;-b&#34;)
        {&#39;f1&#39;: {&#39;b&#39;: True}}

        With `can_run` set to `False`, the parser will fail if the child function arguments
        are not supplied:


        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(can_run=False)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.command()
        ... def g1(n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: -b -n N

        &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
        usage: -b -n N
        Expected &#39;-b&#39;. Got &#39;f1&#39;
        &#34;&#34;&#34;
        return self._decorator(
            can_run=can_run,
            flip_bools=flip_bools,
            help=help,
            parsers=parsers,
            repeated=repeated,
            subcommand=False,
        )

    def _decorator(self, **kwargs) -&gt; Callable:
        def wrapper(function: Callable):
            tree = CommandTree()
            self._children.append(_Node(function=function, tree=tree, **kwargs))
            return tree

        return wrapper

    def _parser(self, *variables: str) -&gt; Parser[Output[_FunctionPair[Any]]]:
        if not self._children:
            raise RuntimeError(
                &#34;You must assign children to a CommandTree object in order to use it as a parser.&#34;
            )

        def get_alternatives() -&gt; Iterator[Parser[Output[_FunctionPair[Any]]]]:
            for child in self._children:
                parser: Parser[Output[_FunctionPair[Any]]] = child.parser(*variables)
                if child.tree is not None and child.tree._children:
                    child_parser = child.tree._parser(
                        *variables, *child.variable_names()
                    )
                    if child.can_run:
                        child_parser = (
                            child_parser | Parser[Output[_FunctionPair[Any]]].done()
                        )
                    parser = parser &gt;&gt; child_parser
                yield parser

        return reduce(operator.or_, get_alternatives()).wrap_help()

    def __call__(self, *args: str) -&gt; Any:
        &#34;&#34;&#34;
        Run the parser associated with this tree and execute the
        function associated with a succeeding parser.

        If `args` is empty, uses `sys.argv[1:]`.
        &#34;&#34;&#34;
        _args = args if args or parser_mod.TESTING else sys.argv[1:]
        p = self._parser() &gt;&gt; Parser[Output[_FunctionPair[Any]]].done()
        result = p.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            p.handle_error(result)
            if parser_mod.TESTING:
                return  # type: ignore[return-value]
            else:
                exit()
        assert isinstance(result, NonemptyList)
        pair = result.head.parsed.get
        assert pair.function is not None
        return pair.function(**pair.seq.to_dict())

    def subcommand(
        self,
        can_run: bool = True,
        flip_bools: bool = True,
        help: Optional[typing.Dict[str, str]] = None,
        parsers: Optional[typing.Dict[str, Optional[Parser[Output]]]] = None,
        repeated: Optional[Parser[Output]] = None,
    ) -&gt; Callable:
        &#34;&#34;&#34;
        A decorator for adding a function as a child of this tree.
        As a subcommand, the function&#39;s name must be invoked on the command
        line for the function to be called.

        Parameters
        ----------

        can_run: bool
            Whether the parser will permit the decorated function to run if no further arguments are supplied.

        flip_bools: bool
            Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

        help: Dict[str, str]
            A dictionary of help strings for the arguments.

        repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
            If provided, this parser gets applied repeatedly (zero or more times) at all positions.
            See `nonpositional` for examples.

        parsers: Dict[str, Parser]
            A dictionary reserving arguments for custom parsers. See below for examples.
            See `command` for examples.

        Examples
        --------
        With `flip_bools` set to `True`:
        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(flip_bools=True)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 --no-b
        b: (default: True)

        With `flip_bools` set to `False`:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(flip_bools=False)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 -b
        b: (default: True)

        With `can_run` set to `True` (the default), we can run `f1` by not passing arguments
        for the `f1`&#39;s children:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(can_run=True)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.subcommand()
        ... def g1(b: bool, n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 -b g1 -n N

        &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
        {&#39;f1&#39;: {&#39;b&#39;: True}}

        With `can_run` set to `False`, the parser will fail if the child function arguments
        are not supplied:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(can_run=False)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.subcommand()
        ... def g1(b: bool, n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 -b g1 -n N

        &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
        usage: f1 -b g1 -n N
        The following arguments are required: g1
        &#34;&#34;&#34;
        return self._decorator(
            can_run=can_run,
            flip_bools=flip_bools,
            help=help,
            repeated=repeated,
            parsers=parsers,
            subcommand=True,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dollar_lambda.decorators.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>flip_bools: bool = True, help: Optional[typing.Dict[str, str]] = None, parsers: Optional[typing.Dict[str, Parser[Output]]] = None, repeated: Optional[Parser[Output]] = None) <span style="white-space: nowrap;">-></span> Callable[[Callable], Callable]</span>
</code></dt>
<dd>
<div class="desc"><p>A succinct way to generate a simple <code>nonpositional</code> parser. <code>@command</code> derives the
component parsers from the function's signature and automatically executes the function with
the parsed arguments, if parsing succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(a=&quot;something about a&quot;))
... def f(a: int = 1, b: bool = False):
...     return dict(a=a, b=b)
&gt;&gt;&gt; f(&quot;-a&quot;, &quot;2&quot;, &quot;-b&quot;)
{'a': 2, 'b': True}
</code></pre>
<p>If the wrapped function receives no arguments (as in <code>f()</code>), the parser will take
<code>sys.argv[1:]</code> as the input.</p>
<p>Note that <code>@command</code> does not handle mutually exclusive arguments or alternative
arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>For boolean arguments that default to true, this changes the flag from <code>--{dest}</code> to <code>--no-{dest}</code>:</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>A dictionary of help strings for the arguments.</dd>
<dt><strong><code>repeated</code></strong> :&ensp;<code>Optional[Parser[Sequence[KeyValue[Any]]]]</code></dt>
<dd>If provided, this parser gets applied repeatedly (zero or more times) at all positions.</dd>
<dt><strong><code>strings</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>This dictionary maps variable names to the strings that the parser will look for in the input.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command()
... def f(cuda: bool = True):
...     return dict(cuda=cuda)
&gt;&gt;&gt; f()
{'cuda': True}
&gt;&gt;&gt; f(&quot;--no-cuda&quot;)  # flip_bools adds --no- to the flag
{'cuda': False}
</code></pre>
<p>As the following example demonstrates, when <code>flip_bools=False</code> output can be somewhat confusing:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(flip_bools=False)
... def f(cuda: bool = True):
...     return dict(cuda=cuda)
&gt;&gt;&gt; f(&quot;--cuda&quot;)
{'cuda': False}
</code></pre>
<p>Here is an example using the <code>help</code> parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(quiet=&quot;Be quiet&quot;))
... def f(quiet: bool):
...     return dict(quiet=quiet)
&gt;&gt;&gt; f(&quot;--help&quot;)
usage: --quiet
quiet: Be quiet
</code></pre>
<p>Here is an example using the <code>parser</code> parameter:</p>
<p>TODO!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/6985236c77c096ca75bd34bac6009a72b619c85c/dollar_lambda/decorators.py#L58-L147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def command(
    flip_bools: bool = True,
    help: Optional[typing.Dict[str, str]] = None,
    parsers: Optional[typing.Dict[str, Parser[Output]]] = None,
    repeated: Optional[Parser[Output]] = None,
) -&gt; Callable[[Callable], Callable]:
    &#34;&#34;&#34;
    A succinct way to generate a simple `nonpositional` parser. `@command` derives the
    component parsers from the function&#39;s signature and automatically executes the function with
    the parsed arguments, if parsing succeeds:

    &gt;&gt;&gt; @command(help=dict(a=&#34;something about a&#34;))
    ... def f(a: int = 1, b: bool = False):
    ...     return dict(a=a, b=b)
    &gt;&gt;&gt; f(&#34;-a&#34;, &#34;2&#34;, &#34;-b&#34;)
    {&#39;a&#39;: 2, &#39;b&#39;: True}

    If the wrapped function receives no arguments (as in `f()`), the parser will take
    `sys.argv[1:]` as the input.

    Note that `@command` does not handle mutually exclusive arguments or alternative
    arguments.

    Parameters
    ----------
    flip_bools : bool
        For boolean arguments that default to true, this changes the flag from `--{dest}` to `--no-{dest}`:

    help : dict[str, str]
        A dictionary of help strings for the arguments.

    repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
        If provided, this parser gets applied repeatedly (zero or more times) at all positions.

    strings : dict[str, str]
        This dictionary maps variable names to the strings that the parser will look for in the input.

    Examples
    --------

    &gt;&gt;&gt; @command()
    ... def f(cuda: bool = True):
    ...     return dict(cuda=cuda)
    &gt;&gt;&gt; f()
    {&#39;cuda&#39;: True}
    &gt;&gt;&gt; f(&#34;--no-cuda&#34;)  # flip_bools adds --no- to the flag
    {&#39;cuda&#39;: False}

    As the following example demonstrates, when `flip_bools=False` output can be somewhat confusing:

    &gt;&gt;&gt; @command(flip_bools=False)
    ... def f(cuda: bool = True):
    ...     return dict(cuda=cuda)
    &gt;&gt;&gt; f(&#34;--cuda&#34;)
    {&#39;cuda&#39;: False}

    Here is an example using the `help` parameter:

    &gt;&gt;&gt; @command(help=dict(quiet=&#34;Be quiet&#34;))
    ... def f(quiet: bool):
    ...     return dict(quiet=quiet)
    &gt;&gt;&gt; f(&#34;--help&#34;)
    usage: --quiet
    quiet: Be quiet

    Here is an example using the `parser` parameter:

    TODO!
    &#34;&#34;&#34;

    def wrapper(func: Callable) -&gt; Callable:
        p = _func_to_parser(
            func,
            exclude=None,
            flip_bools=flip_bools,
            help=help,
            parsers=parsers,
            repeated=repeated,
        )
        p = p.wrap_help()

        def wrapped(*args) -&gt; Any:
            parsed = p.parse_args(*args)
            if parsed is None:
                return
            return func(**parsed)

        return wrapped

    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dollar_lambda.decorators.CommandTree"><code class="flex name class">
<span>class <span class="ident">CommandTree</span></span>
</code></dt>
<dd>
<div class="desc"><p>Allows parsers to dynamically dispatch their results based on the input. For usage details,
see the <a href="#commandtree-tutorial"><code>CommandTree</code> tutorial</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/6985236c77c096ca75bd34bac6009a72b619c85c/dollar_lambda/decorators.py#L257-L526" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class CommandTree:
    &#34;&#34;&#34;
    Allows parsers to dynamically dispatch their results based on the input. For usage details,
    see the [`CommandTree` tutorial](#commandtree-tutorial).
    &#34;&#34;&#34;

    _children: List[_Node] = field(default_factory=list)
    _can_run: bool = True

    def command(
        self,
        can_run: bool = True,
        flip_bools: bool = True,
        help: Optional[typing.Dict[str, str]] = None,
        parsers: Optional[typing.Dict[str, Parser[Output]]] = None,
        repeated: Optional[Parser[Output]] = None,
    ) -&gt; Callable:
        &#34;&#34;&#34;
        A decorator for adding a function as a child of this tree.

        Parameters
        ----------

        can_run: bool
            Whether the parser will permit the decorated function to run if no further arguments are supplied.

        flip_bools: bool
            Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

        help: dict
            A dictionary of help strings for the arguments.

        repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
            If provided, this parser gets applied repeatedly (zero or more times) at all positions.

        parsers: dict
            TODO

        Examples
        --------
        With `flip_bools` set to `True`:
        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(flip_bools=True)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: --no-b
        b: (default: True)

        With `flip_bools` set to `False`:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(flip_bools=False)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: -b
        b: (default: True)


        With `can_run` set to `True` (the default), we can run `f1` by not passing arguments
        for the `f1`&#39;s children:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(can_run=True)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.command()
        ... def g1(n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: -b -n N

        &gt;&gt;&gt; tree(&#34;-b&#34;)
        {&#39;f1&#39;: {&#39;b&#39;: True}}

        With `can_run` set to `False`, the parser will fail if the child function arguments
        are not supplied:


        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.command(can_run=False)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.command()
        ... def g1(n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: -b -n N

        &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
        usage: -b -n N
        Expected &#39;-b&#39;. Got &#39;f1&#39;
        &#34;&#34;&#34;
        return self._decorator(
            can_run=can_run,
            flip_bools=flip_bools,
            help=help,
            parsers=parsers,
            repeated=repeated,
            subcommand=False,
        )

    def _decorator(self, **kwargs) -&gt; Callable:
        def wrapper(function: Callable):
            tree = CommandTree()
            self._children.append(_Node(function=function, tree=tree, **kwargs))
            return tree

        return wrapper

    def _parser(self, *variables: str) -&gt; Parser[Output[_FunctionPair[Any]]]:
        if not self._children:
            raise RuntimeError(
                &#34;You must assign children to a CommandTree object in order to use it as a parser.&#34;
            )

        def get_alternatives() -&gt; Iterator[Parser[Output[_FunctionPair[Any]]]]:
            for child in self._children:
                parser: Parser[Output[_FunctionPair[Any]]] = child.parser(*variables)
                if child.tree is not None and child.tree._children:
                    child_parser = child.tree._parser(
                        *variables, *child.variable_names()
                    )
                    if child.can_run:
                        child_parser = (
                            child_parser | Parser[Output[_FunctionPair[Any]]].done()
                        )
                    parser = parser &gt;&gt; child_parser
                yield parser

        return reduce(operator.or_, get_alternatives()).wrap_help()

    def __call__(self, *args: str) -&gt; Any:
        &#34;&#34;&#34;
        Run the parser associated with this tree and execute the
        function associated with a succeeding parser.

        If `args` is empty, uses `sys.argv[1:]`.
        &#34;&#34;&#34;
        _args = args if args or parser_mod.TESTING else sys.argv[1:]
        p = self._parser() &gt;&gt; Parser[Output[_FunctionPair[Any]]].done()
        result = p.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            p.handle_error(result)
            if parser_mod.TESTING:
                return  # type: ignore[return-value]
            else:
                exit()
        assert isinstance(result, NonemptyList)
        pair = result.head.parsed.get
        assert pair.function is not None
        return pair.function(**pair.seq.to_dict())

    def subcommand(
        self,
        can_run: bool = True,
        flip_bools: bool = True,
        help: Optional[typing.Dict[str, str]] = None,
        parsers: Optional[typing.Dict[str, Optional[Parser[Output]]]] = None,
        repeated: Optional[Parser[Output]] = None,
    ) -&gt; Callable:
        &#34;&#34;&#34;
        A decorator for adding a function as a child of this tree.
        As a subcommand, the function&#39;s name must be invoked on the command
        line for the function to be called.

        Parameters
        ----------

        can_run: bool
            Whether the parser will permit the decorated function to run if no further arguments are supplied.

        flip_bools: bool
            Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

        help: Dict[str, str]
            A dictionary of help strings for the arguments.

        repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
            If provided, this parser gets applied repeatedly (zero or more times) at all positions.
            See `nonpositional` for examples.

        parsers: Dict[str, Parser]
            A dictionary reserving arguments for custom parsers. See below for examples.
            See `command` for examples.

        Examples
        --------
        With `flip_bools` set to `True`:
        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(flip_bools=True)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 --no-b
        b: (default: True)

        With `flip_bools` set to `False`:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(flip_bools=False)
        ... def f1(b: bool = True):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 -b
        b: (default: True)

        With `can_run` set to `True` (the default), we can run `f1` by not passing arguments
        for the `f1`&#39;s children:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(can_run=True)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.subcommand()
        ... def g1(b: bool, n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 -b g1 -n N

        &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
        {&#39;f1&#39;: {&#39;b&#39;: True}}

        With `can_run` set to `False`, the parser will fail if the child function arguments
        are not supplied:

        &gt;&gt;&gt; tree = CommandTree()
        ...
        &gt;&gt;&gt; @tree.subcommand(can_run=False)  # &lt;-
        ... def f1(b: bool):
        ...     return dict(f1=dict(b=b))
        ...
        &gt;&gt;&gt; @f1.subcommand()
        ... def g1(b: bool, n: int):
        ...     return dict(g1=dict(b=b, n=n))
        ...
        &gt;&gt;&gt; tree(&#34;-h&#34;)
        usage: f1 -b g1 -n N

        &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
        usage: f1 -b g1 -n N
        The following arguments are required: g1
        &#34;&#34;&#34;
        return self._decorator(
            can_run=can_run,
            flip_bools=flip_bools,
            help=help,
            repeated=repeated,
            parsers=parsers,
            subcommand=True,
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.decorators.CommandTree.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self, can_run: bool = True, flip_bools: bool = True, help: Optional[typing.Dict[str, str]] = None, parsers: Optional[typing.Dict[str, Parser[Output]]] = None, repeated: Optional[Parser[Output]] = None) <span style="white-space: nowrap;">-></span> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>A decorator for adding a function as a child of this tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>can_run</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the parser will permit the decorated function to run if no further arguments are supplied.</dd>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to add <code>--no-&lt;argument&gt;</code> before arguments that default to <code>True</code>.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of help strings for the arguments.</dd>
<dt><strong><code>repeated</code></strong> :&ensp;<code>Optional[Parser[Sequence[KeyValue[Any]]]]</code></dt>
<dd>If provided, this parser gets applied repeatedly (zero or more times) at all positions.</dd>
<dt><strong><code>parsers</code></strong> :&ensp;<code>dict</code></dt>
<dd>TODO</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>With <code>flip_bools</code> set to <code>True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(flip_bools=True)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: --no-b
b: (default: True)
</code></pre>
<p>With <code>flip_bools</code> set to <code>False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(flip_bools=False)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -b
b: (default: True)
</code></pre>
<p>With <code>can_run</code> set to <code>True</code> (the default), we can run <code>f1</code> by not passing arguments
for the <code>f1</code>'s children:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(can_run=True)  # &lt;-
... def f1(b: bool):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; @f1.command()
... def g1(n: int):
...     return dict(g1=dict(b=b, n=n))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -b -n N
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;-b&quot;)
{'f1': {'b': True}}
</code></pre>
<p>With <code>can_run</code> set to <code>False</code>, the parser will fail if the child function arguments
are not supplied:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(can_run=False)  # &lt;-
... def f1(b: bool):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; @f1.command()
... def g1(n: int):
...     return dict(g1=dict(b=b, n=n))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: -b -n N
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;f1&quot;, &quot;-b&quot;)
usage: -b -n N
Expected '-b'. Got 'f1'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/6985236c77c096ca75bd34bac6009a72b619c85c/dollar_lambda/decorators.py#L267-L369" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def command(
    self,
    can_run: bool = True,
    flip_bools: bool = True,
    help: Optional[typing.Dict[str, str]] = None,
    parsers: Optional[typing.Dict[str, Parser[Output]]] = None,
    repeated: Optional[Parser[Output]] = None,
) -&gt; Callable:
    &#34;&#34;&#34;
    A decorator for adding a function as a child of this tree.

    Parameters
    ----------

    can_run: bool
        Whether the parser will permit the decorated function to run if no further arguments are supplied.

    flip_bools: bool
        Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

    help: dict
        A dictionary of help strings for the arguments.

    repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
        If provided, this parser gets applied repeatedly (zero or more times) at all positions.

    parsers: dict
        TODO

    Examples
    --------
    With `flip_bools` set to `True`:
    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command(flip_bools=True)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: --no-b
    b: (default: True)

    With `flip_bools` set to `False`:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command(flip_bools=False)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: -b
    b: (default: True)


    With `can_run` set to `True` (the default), we can run `f1` by not passing arguments
    for the `f1`&#39;s children:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command(can_run=True)  # &lt;-
    ... def f1(b: bool):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; @f1.command()
    ... def g1(n: int):
    ...     return dict(g1=dict(b=b, n=n))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: -b -n N

    &gt;&gt;&gt; tree(&#34;-b&#34;)
    {&#39;f1&#39;: {&#39;b&#39;: True}}

    With `can_run` set to `False`, the parser will fail if the child function arguments
    are not supplied:


    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.command(can_run=False)  # &lt;-
    ... def f1(b: bool):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; @f1.command()
    ... def g1(n: int):
    ...     return dict(g1=dict(b=b, n=n))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: -b -n N

    &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
    usage: -b -n N
    Expected &#39;-b&#39;. Got &#39;f1&#39;
    &#34;&#34;&#34;
    return self._decorator(
        can_run=can_run,
        flip_bools=flip_bools,
        help=help,
        parsers=parsers,
        repeated=repeated,
        subcommand=False,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.decorators.CommandTree.subcommand"><code class="name flex">
<span>def <span class="ident">subcommand</span></span>(<span>self, can_run: bool = True, flip_bools: bool = True, help: Optional[typing.Dict[str, str]] = None, parsers: Optional[typing.Dict[str, Optional[Parser[Output]]]] = None, repeated: Optional[Parser[Output]] = None) <span style="white-space: nowrap;">-></span> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>A decorator for adding a function as a child of this tree.
As a subcommand, the function's name must be invoked on the command
line for the function to be called.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>can_run</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the parser will permit the decorated function to run if no further arguments are supplied.</dd>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to add <code>--no-&lt;argument&gt;</code> before arguments that default to <code>True</code>.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>A dictionary of help strings for the arguments.</dd>
<dt><strong><code>repeated</code></strong> :&ensp;<code>Optional[Parser[Sequence[KeyValue[Any]]]]</code></dt>
<dd>If provided, this parser gets applied repeatedly (zero or more times) at all positions.
See <code>nonpositional</code> for examples.</dd>
<dt><strong><code>parsers</code></strong> :&ensp;<code>Dict[str, Parser]</code></dt>
<dd>A dictionary reserving arguments for custom parsers. See below for examples.
See <code><a title="dollar_lambda.decorators.command" href="#dollar_lambda.decorators.command">command()</a></code> for examples.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>With <code>flip_bools</code> set to <code>True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.subcommand(flip_bools=True)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: f1 --no-b
b: (default: True)
</code></pre>
<p>With <code>flip_bools</code> set to <code>False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.subcommand(flip_bools=False)
... def f1(b: bool = True):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: f1 -b
b: (default: True)
</code></pre>
<p>With <code>can_run</code> set to <code>True</code> (the default), we can run <code>f1</code> by not passing arguments
for the <code>f1</code>'s children:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.subcommand(can_run=True)  # &lt;-
... def f1(b: bool):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; @f1.subcommand()
... def g1(b: bool, n: int):
...     return dict(g1=dict(b=b, n=n))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: f1 -b g1 -n N
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;f1&quot;, &quot;-b&quot;)
{'f1': {'b': True}}
</code></pre>
<p>With <code>can_run</code> set to <code>False</code>, the parser will fail if the child function arguments
are not supplied:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.subcommand(can_run=False)  # &lt;-
... def f1(b: bool):
...     return dict(f1=dict(b=b))
...
&gt;&gt;&gt; @f1.subcommand()
... def g1(b: bool, n: int):
...     return dict(g1=dict(b=b, n=n))
...
&gt;&gt;&gt; tree(&quot;-h&quot;)
usage: f1 -b g1 -n N
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree(&quot;f1&quot;, &quot;-b&quot;)
usage: f1 -b g1 -n N
The following arguments are required: g1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ethanabrooks/dollar-lambda/blob/6985236c77c096ca75bd34bac6009a72b619c85c/dollar_lambda/decorators.py#L422-L526" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def subcommand(
    self,
    can_run: bool = True,
    flip_bools: bool = True,
    help: Optional[typing.Dict[str, str]] = None,
    parsers: Optional[typing.Dict[str, Optional[Parser[Output]]]] = None,
    repeated: Optional[Parser[Output]] = None,
) -&gt; Callable:
    &#34;&#34;&#34;
    A decorator for adding a function as a child of this tree.
    As a subcommand, the function&#39;s name must be invoked on the command
    line for the function to be called.

    Parameters
    ----------

    can_run: bool
        Whether the parser will permit the decorated function to run if no further arguments are supplied.

    flip_bools: bool
        Whether to add `--no-&lt;argument&gt;` before arguments that default to `True`.

    help: Dict[str, str]
        A dictionary of help strings for the arguments.

    repeated: Optional[Parser[Sequence[KeyValue[Any]]]]
        If provided, this parser gets applied repeatedly (zero or more times) at all positions.
        See `nonpositional` for examples.

    parsers: Dict[str, Parser]
        A dictionary reserving arguments for custom parsers. See below for examples.
        See `command` for examples.

    Examples
    --------
    With `flip_bools` set to `True`:
    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.subcommand(flip_bools=True)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: f1 --no-b
    b: (default: True)

    With `flip_bools` set to `False`:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.subcommand(flip_bools=False)
    ... def f1(b: bool = True):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: f1 -b
    b: (default: True)

    With `can_run` set to `True` (the default), we can run `f1` by not passing arguments
    for the `f1`&#39;s children:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.subcommand(can_run=True)  # &lt;-
    ... def f1(b: bool):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; @f1.subcommand()
    ... def g1(b: bool, n: int):
    ...     return dict(g1=dict(b=b, n=n))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: f1 -b g1 -n N

    &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
    {&#39;f1&#39;: {&#39;b&#39;: True}}

    With `can_run` set to `False`, the parser will fail if the child function arguments
    are not supplied:

    &gt;&gt;&gt; tree = CommandTree()
    ...
    &gt;&gt;&gt; @tree.subcommand(can_run=False)  # &lt;-
    ... def f1(b: bool):
    ...     return dict(f1=dict(b=b))
    ...
    &gt;&gt;&gt; @f1.subcommand()
    ... def g1(b: bool, n: int):
    ...     return dict(g1=dict(b=b, n=n))
    ...
    &gt;&gt;&gt; tree(&#34;-h&#34;)
    usage: f1 -b g1 -n N

    &gt;&gt;&gt; tree(&#34;f1&#34;, &#34;-b&#34;)
    usage: f1 -b g1 -n N
    The following arguments are required: g1
    &#34;&#34;&#34;
    return self._decorator(
        can_run=can_run,
        flip_bools=flip_bools,
        help=help,
        repeated=repeated,
        parsers=parsers,
        subcommand=True,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="dollar-lambda home" href="https://ethanabrooks.github.io/dollar-lambda">
<img src="https://ethanabrooks.github.io/dollar-lambda/logo.png" alt="">
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dollar_lambda" href="index.html">dollar_lambda</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dollar_lambda.decorators.command" href="#dollar_lambda.decorators.command">command</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dollar_lambda.decorators.CommandTree" href="#dollar_lambda.decorators.CommandTree">CommandTree</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.decorators.CommandTree.command" href="#dollar_lambda.decorators.CommandTree.command">command</a></code></li>
<li><code><a title="dollar_lambda.decorators.CommandTree.subcommand" href="#dollar_lambda.decorators.CommandTree.subcommand">subcommand</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</html>
