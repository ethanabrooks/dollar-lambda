<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dollar_lambda.parser API documentation</title>
<meta name="description" content="Contains the `Parser` class and functions for building more specialized builder functions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dollar_lambda.parser</code></h1>
</header>
<section id="section-intro">
<p>Contains the <code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a></code> class and functions for building more specialized builder functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Contains the `Parser` class and functions for building more specialized builder functions.
&#34;&#34;&#34;
# pyright: reportGeneralTypeIssues=false
from __future__ import annotations

import operator
import os
import typing
from dataclasses import asdict, dataclass, replace
from functools import lru_cache, partial, reduce
from typing import Any, Callable, Dict, Generator, Optional, Type, TypeVar

from pytypeclass import MonadPlus, Monoid
from pytypeclass.nonempty_list import NonemptyList

from dollar_lambda.error import (
    ArgumentError,
    HelpError,
    MissingError,
    UnequalError,
    UnexpectedError,
)
from dollar_lambda.key_value import KeyValue, KeyValueTuple
from dollar_lambda.parse import Parse
from dollar_lambda.result import Result
from dollar_lambda.sequence import Sequence

A = TypeVar(&#34;A&#34;, bound=Monoid, covariant=True)
B = TypeVar(&#34;B&#34;, bound=Monoid)
C = TypeVar(&#34;C&#34;)
D = TypeVar(&#34;D&#34;, bound=Monoid)

global TESTING
TESTING = os.environ.get(&#34;TESTING&#34;, False)


def empty() -&gt; Parser[Sequence[B]]:
    &#34;&#34;&#34;
    Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
    &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
    {}
    &#34;&#34;&#34;
    return Parser.return_(Sequence([]))


def binary_usage(a: Optional[str], op: str, b: Optional[str], add_brackets=True):
    &#34;&#34;&#34;
    Utility for generating usage strings for binary operators.
    &#34;&#34;&#34;
    no_nones = [x for x in (a, b) if x is not None]
    usage = op.join(no_nones)
    if len(no_nones) &gt; 1 and add_brackets:
        usage = f&#34;[{usage}]&#34;
    return usage or None


__pdoc__ = {}


@dataclass
class Parser(MonadPlus[A]):
    &#34;&#34;&#34;
    Main class powering the argument parser.
    &#34;&#34;&#34;

    __pdoc__[&#34;Parser.__add__&#34;] = True
    __pdoc__[&#34;Parser.__or__&#34;] = True
    __pdoc__[&#34;Parser.__rshift__&#34;] = True
    __pdoc__[&#34;Parser.__ge__&#34;] = True

    f: Callable[[Sequence[str]], Result[Parse[A]]]
    usage: Optional[str]
    helps: Dict[str, str]

    def __add__(
        self: Parser[Sequence[D]], other: Parser[Sequence[B]]
    ) -&gt; Parser[Sequence[D | B]]:
        &#34;&#34;&#34;
        Parse two arguments in either order.
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
        {&#39;verbose&#39;: True, &#39;debug&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
        {&#39;debug&#39;: True, &#39;verbose&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
        usage: --verbose --debug
        Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

        Note that if more than two arguments are chained together with `+`, some combinations will not parse:
        &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
        {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
        usage: -a -b -c
        Expected &#39;-b&#39;. Got &#39;-c&#39;

        This makes more sense when one supplies the implicit parentheses:
        &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

        In order to chain together more than two arguments, use `nonpositional`:
        &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
        {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
        &#34;&#34;&#34;
        p = (self &gt;&gt; other) | (other &gt;&gt; self)
        usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
        return replace(p, usage=usage)

    def __or__(
        self: Parser[A],
        other: Parser[B],
    ) -&gt; Parser[A | B]:
        &#34;&#34;&#34;
        Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

        &gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
        &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
        {&#39;verbose&#39;: True}

        Note that when both arguments are supplied, this will only parse the first:
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        {&#39;verbose&#39;: True}

        If you want this to fail, use `&gt;&gt;` (`Parser.__rshift__`) with `done()` or another parser:
        &gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        usage: [--option OPTION | --verbose]
        Unrecognized argument: --option
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A | B]]:
            return self.parse(cs) | other.parse(cs)

        return Parser(
            f,
            usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
            helps={**self.helps, **other.helps},
        )

    def __rshift__(
        self: Parser[Sequence[D]], p: Parser[Sequence[B]]
    ) -&gt; Parser[Sequence[D | B]]:
        &#34;&#34;&#34;
        This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
        gets handed off to the second parser. If either parser fails, the whole thing fails.

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        usage: first second
        The following arguments are required: second
        &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
        usage: first second
        The following arguments are required: second
        &#34;&#34;&#34;
        # def f(p1: Sequence[D]) -&gt; Parser[Parse[Sequence[D | B]]]:
        #     def g(p2: Sequence[B]) -&gt; Parser[Sequence[D | B]]:
        #         return Parser.return_(p1 + p2)

        #     return p &gt;= g

        # return self &gt;= f
        parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
        return replace(
            parser, usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False)
        )

    def bind(self, f: Callable[[A], Parser[B]]) -&gt; Parser[B]:
        &#34;&#34;&#34;
        Returns a new parser that

        1. applies `self`;
        2. if this succeeds, applies `f` to the parsed component of the result.

        `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
        avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
        `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

        Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
        and we typically prefer using the infix operator to the spelled out method.

        Let&#39;s start with our simplest parser, `argument`:
        &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

        Now let&#39;s use the `equals` parser to write a function that takes the output of `p1` and fails unless
        the next argument is the same as the first:
        &gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Sequence(KeyValue[str]):
        ...     [kv] = kvs
        ...     return equals(kv.value)

        &gt;&gt;&gt; p = p1 &gt;= f
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
        {&#39;a&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        Expected &#39;a&#39;. Got &#39;b&#39;
        &#34;&#34;&#34;

        def h(parse: Parse[A]) -&gt; Result[Parse[B]]:
            return f(parse.parsed).parse(parse.unparsed)

        def g(cs: Sequence[str]) -&gt; Result[Parse[B]]:
            return self.parse(cs) &gt;= h

        return Parser(g, usage=None, helps=self.helps)

    def many(self: &#34;Parser[Sequence[B]]&#34;) -&gt; &#34;Parser[Sequence[B]]&#34;:
        &#34;&#34;&#34;
        Applies `self` zero or more times (like `*` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(return_dict=False)
        []
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, return_dict=False)
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;)]
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)  # return_dict=False allows duplicate keys
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

        Note that if `self` contains `Parser.__or__`, the arguments can be
        heterogenous:
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
        &gt;&gt;&gt; p = p.many()
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, return_dict=False) # mix --verbose and --quiet
        [(&#39;verbose&#39;, True), (&#39;quiet&#39;, True)]
        &#34;&#34;&#34;
        p = self.many1() | empty()
        return replace(p, usage=f&#34;[{self.usage} ...]&#34;)

    def many1(self: &#34;Parser[Sequence[B]]&#34;) -&gt; &#34;Parser[Sequence[B]]&#34;:
        &#34;&#34;&#34;
        Applies `self` one or more times (like `+` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
        {&#39;1-or-more&#39;: &#39;1&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, return_dict=False)  # return_dict=False allows duplicate keys
        [(&#39;1-or-more&#39;, &#39;1&#39;), (&#39;1-or-more&#39;, &#39;2&#39;)]
        &gt;&gt;&gt; p.parse_args()
        usage: 1-or-more [1-or-more ...]
        The following arguments are required: 1-or-more
        &#34;&#34;&#34;

        def g() -&gt; Generator[&#34;Parser[Sequence[B]]&#34;, Sequence[B], None]:
            # noinspection PyTypeChecker
            r1: Sequence[B] = yield self
            # noinspection PyTypeChecker
            r2: Sequence[B] = yield self.many()
            yield Parser[Sequence[B]].return_(r1 + r2)

        @lru_cache()
        def f(cs: tuple):
            return Parser.do(g).parse(Sequence(list(cs)))

        return Parser(
            lambda cs: f(tuple(cs)),
            usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
            helps=self.helps,
        )

    def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A]]:
        &#34;&#34;&#34;
        Applies the parser to the input sequence `cs`.
        &#34;&#34;&#34;
        return self.f(cs)

    def parse_args(
        self: &#34;Parser[Sequence[KeyValue]]&#34;,
        *args: str,
        return_dict: bool = True,
        check_help: bool = True,
    ) -&gt; typing.Sequence[KeyValueTuple] | Dict[str, Any]:
        &#34;&#34;&#34;
        The main way the user extracts parsed results from the parser.

        Parameters
        ----------
        args : str
            A sequence of strings to parse (e.g. `sys.argv[1:]`).
        return_dict : bool
            Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
            The tuples are `KeyValueTuple` namedtuples, with fields `key` and `value`.
        check_help : bool
            Before running the parser, checks if the input string is `--help` or `-h`.
            If it is, returns the usage message.

        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
        usage: a
        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
        usage: a
        &#34;&#34;&#34;
        if check_help:
            return wrap_help(self).parse_args(
                *args, return_dict=return_dict, check_help=False
            )
        result = self.parse(Sequence(list(args))).get
        if isinstance(result, ArgumentError):
            if self.usage and not isinstance(result, HelpError):
                print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in self.usage else &#34; &#34;)
                if &#34;\n&#34; in self.usage:
                    usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in self.usage.split(&#34;\n&#34;)])
                else:
                    usage = self.usage
                print(usage)
            if self.helps:
                for k, v in self.helps.items():
                    print(f&#34;{k}: {v}&#34;)
            if result.usage:
                if isinstance(result, HelpError):
                    print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in result.usage else &#34; &#34;)
                print(result.usage)
            if TESTING:
                return  # type: ignore[return-value]
            else:
                exit()

        nel: NonemptyList[Parse[Sequence[KeyValue]]] = result
        parse: Parse[Sequence[KeyValue]] = nel.head
        kvs: Sequence[KeyValue] = parse.parsed
        if return_dict:
            return {kv.key: kv.value for kv in kvs}
        return [KeyValueTuple(**asdict(kv)) for kv in kvs]

    @classmethod
    def return_(cls, a: A) -&gt; Parser[A]:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
        and always returns `a` as the result. For the most part, the user will not use
        this method unless building custom parsers.

        &gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
        &gt;&gt;&gt; Parser.return_(([KeyValue(&#34;some-key&#34;, &#34;some-value&#34;)])).parse_args()
        {&#39;some-key&#39;: &#39;some-value&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A]]:
            return Result.return_(Parse(a, cs))

        return Parser(f, usage=None, helps={})

    @classmethod
    def zero(cls: Type[Parser[A]], error: Optional[ArgumentError] = None) -&gt; Parser[A]:
        &#34;&#34;&#34;
        This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

        Parameters
        ----------
        error : Optional[ArgumentError]
            Customize the error returned by `zero`.

        &gt;&gt;&gt; Parser.zero().parse_args()
        zero
        &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
        zero
        &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
        This is a test.
        &#34;&#34;&#34;
        return Parser(lambda _: Result.zero(error=error), usage=None, helps={})


E = TypeVar(&#34;E&#34;, bound=MonadPlus)
F = TypeVar(&#34;F&#34;)
G = TypeVar(&#34;G&#34;, covariant=True, bound=MonadPlus)


def apply(f: Callable[[E], Result[G]], parser: Parser[E]) -&gt; Parser[G]:
    &#34;&#34;&#34;
    Take the output of `parser` and apply `f` to it. Convert any errors that arise into `ArgumentError`.
    &#34;&#34;&#34;

    def g(a: E) -&gt; Parser[G]:
        try:
            y = f(a)
        except Exception as e:
            usage = f&#34;An argument {a}: raised exception {e}&#34;
            y = Result(ArgumentError(usage))
        return Parser(
            lambda unparsed: y
            &gt;= (lambda parsed: Result.return_(Parse(parsed, unparsed))),
            usage=parser.usage,
            helps=parser.helps,
        )

    return parser &gt;= g


def apply_item(f: Callable[[str], G], description: str) -&gt; Parser[G]:
    def g(parsed: Sequence[KeyValue[str]]) -&gt; Result[G]:
        [kv] = parsed
        try:
            y = f(kv.value)
        except Exception as e:
            usage = f&#34;argument {kv.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        return Result.return_(y)

    return apply(g, item(description))


def argument(dest: str) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args()
    usage: name
    The following arguments are required: name
    &#34;&#34;&#34;
    return item(dest)


def defaults(**kwargs: Any) -&gt; Parser[Sequence[KeyValue[Any]]]:
    p = Parser.return_(Sequence([KeyValue(k, v) for k, v in kwargs.items()]))
    return replace(p, usage=None)


def done() -&gt; Parser[Sequence[F]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; done().parse_args()
    {}
    &gt;&gt;&gt; done().parse_args(&#34;arg&#34;)
    Unrecognized argument: arg
    &gt;&gt;&gt; (argument(&#34;arg&#34;) &gt;&gt; done()).parse_args(&#34;a&#34;)
    {&#39;arg&#39;: &#39;a&#39;}
    &gt;&gt;&gt; (argument(&#34;arg&#34;) &gt;&gt; done()).parse_args(&#34;a&#34;, &#34;b&#34;)
    usage: arg
    Unrecognized argument: b
    &gt;&gt;&gt; (flag(&#34;arg&#34;).many() &gt;&gt; done()).parse_args(&#34;--arg&#34;, &#34;--arg&#34;, return_dict=False)
    [(&#39;arg&#39;, True), (&#39;arg&#39;, True)]
    &gt;&gt;&gt; (flag(&#34;arg&#34;).many() &gt;&gt; done()).parse_args(&#34;--arg&#34;, &#34;--arg&#34;, &#34;x&#34;)
    usage: [--arg ...]
    Unrecognized argument: x
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[Sequence[F]]]:
        if cs:
            c, *_ = cs
            return Result(
                UnexpectedError(unexpected=c, usage=f&#34;Unrecognized argument: {c}&#34;)
            )
        return Result(NonemptyList(Parse(parsed=Sequence([]), unparsed=cs)))

    return Parser(f, usage=None, helps={})


def equals(s: str, peak=False) -&gt; Parser[Sequence[KeyValue[str]]]:
    if peak:
        return sat_peak(
            predicate=lambda _s: _s == s,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )
    else:
        return sat_item(
            predicate=lambda _s: _s == s,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )


def flag(
    dest: str,
    default: Optional[bool] = None,
    help: Optional[str] = None,
    short: bool = True,
    string: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[bool]]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, default=False)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--verbose&#34;, &#34;--verbose&#34;)
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; flag(&#34;v&#34;, string=&#34;--value&#34;).parse_args(&#34;--value&#34;)
    {&#39;v&#39;: True}

    &gt;&gt;&gt; p1 = flag(&#34;verbose&#34;, default=False) | flag(&#34;quiet&#34;, default=False) | flag(&#34;yes&#34;, default=False)
    &gt;&gt;&gt; p = p1 &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;value&#34;)
    usage: [[--verbose | --quiet] | --yes]
    Unrecognized argument: value
    &gt;&gt;&gt; p.parse_args(&#34;value&#34;)
    usage: [[--verbose | --quiet] | --yes]
    Unrecognized argument: value
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; p1 = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | flag(&#34;yes&#34;)
    &gt;&gt;&gt; p = p1 &gt;&gt; argument(&#34;a&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    usage: [[--verbose | --quiet] | --yes] a
    The following arguments are required: a
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
    usage: [[--verbose | --quiet] | --yes] a
    Expected &#39;--verbose&#39;. Got &#39;a&#39;
    &#34;&#34;&#34;
    if string is None:
        _string = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _string = string

    def f(
        cs: Sequence[str],
        s: str,
    ) -&gt; Result[Parse[Sequence[KeyValue[bool]]]]:
        parser = equals(s) &gt;= (lambda _: defaults(**{dest: not default}))
        return parser.parse(cs)

    parser = Parser(partial(f, s=_string), usage=None, helps={})
    if default is not None:
        parser = parser | defaults(**{dest: default})
    if short:
        short_string = f&#34;-{dest[0]}&#34;
        parser2 = flag(dest, short=False, string=short_string, default=default)
        parser = parser | parser2
    if default:
        help = f&#34;{help + &#39; &#39; if help else &#39;&#39;}(default: {default})&#34;
    helps = {dest: help} if help else {}
    return replace(parser, usage=_string, helps=helps)


def help_parser(usage: str, parsed: B) -&gt; Parser[B]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[B]]:
        result = (equals(&#34;--help&#34;, peak=True) | equals(&#34;-h&#34;, peak=True)).parse(cs)
        if isinstance(result.get, ArgumentError):
            return Result.return_(Parse(parsed=parsed, unparsed=cs))
        return Result(HelpError(usage=usage))

    return Parser(f, usage=None, helps={})


def wrap_help(parser: Parser[Sequence[C]]) -&gt; Parser[Sequence[C]]:
    _help_parser: Parser[Sequence[C]] = help_parser(
        parser.usage or &#34;No usage provided.&#34;, Sequence([])
    )

    p = _help_parser &gt;= (lambda _: parser)
    return replace(p, usage=parser.usage, helps=parser.helps)


def item(
    name: str,
    description: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        if cs:
            head, *tail = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Sequence([KeyValue(name, head)]),
                        unparsed=Sequence(tail),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {description or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})


def nonpositional(*parsers: &#34;Parser[Sequence[F]]&#34;) -&gt; &#34;Parser[Sequence[F]]&#34;:
    &#34;&#34;&#34;
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;debug&#34;, default=False)) &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False, &#39;debug&#39;: False}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    {&#39;verbose&#39;: False, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: False}
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;debug&#34;, default=False)) &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: False}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    {&#39;verbose&#39;: False, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False, &#39;debug&#39;: False}
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;debug&#34;, default=False), argument(&#34;a&#34;)) &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;hello&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;a&#39;: &#39;hello&#39;, &#39;verbose&#39;: True}
    &#34;&#34;&#34;
    if not parsers:
        return empty()

    def get_alternatives():
        for i, head in enumerate(parsers):
            tail = [p for j, p in enumerate(parsers) if j != i]
            yield head &gt;&gt; nonpositional(*tail)

    parser = reduce(operator.or_, get_alternatives())
    sep = &#34; &#34; if len(parsers) &lt;= 3 else &#34;\n&#34;
    return replace(parser, usage=sep.join([p.usage or &#34;&#34; for p in parsers]))


def option(
    dest: str,
    flag: Optional[str] = None,
    default=None,
    help: Optional[str] = None,
    short: bool = True,
    type: Callable[[str], Any] = str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; option(&#34;value&#34;).parse_args(&#34;--value&#34;, &#34;x&#34;)
    {&#39;value&#39;: &#39;x&#39;}
    &gt;&gt;&gt; option(&#34;value&#34;).parse_args(&#34;--value&#34;)
    usage: --value VALUE
    The following arguments are required: VALUE
    &gt;&gt;&gt; option(&#34;value&#34;).parse_args()
    usage: --value VALUE
    The following arguments are required: --value
    &gt;&gt;&gt; option(&#34;value&#34;, default=1).parse_args()
    {&#39;value&#39;: 1}
    &gt;&gt;&gt; option(&#34;value&#34;, default=1).parse_args(&#34;--value&#34;)
    {&#39;value&#39;: 1}
    &gt;&gt;&gt; option(&#34;value&#34;, default=1).parse_args(&#34;--value&#34;, &#34;x&#34;)
    {&#39;value&#39;: &#39;x&#39;}
    &gt;&gt;&gt; option(&#34;v&#34;).parse_args(&#34;-v&#34;, &#34;x&#34;)
    {&#39;v&#39;: &#39;x&#39;}
    &gt;&gt;&gt; option(&#34;v&#34;, flag=&#34;--value&#34;).parse_args(&#34;--value&#34;, &#34;x&#34;)
    {&#39;v&#39;: &#39;x&#39;}
    &#34;&#34;&#34;

    if flag is None:
        _flag = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _flag = flag

    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        parser = equals(_flag) &gt;= (lambda _: item(dest, description=dest.upper()))
        return parser.parse(cs)

    parser = Parser(f, usage=None, helps={})
    if default:
        parser = parser | defaults(**{dest: default})
    if short and len(dest) &gt; 1:
        parser2 = option(dest=dest, short=False, flag=f&#34;-{dest[0]}&#34;, default=None)
        parser = parser | parser2
    if type is not str:
        parser = type_(type, parser)
    helps = {dest: help} if help else {}
    return replace(parser, usage=f&#34;{_flag} {dest.upper()}&#34;, helps=helps)


def peak(
    name: str,
    description: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        if cs:
            head, *_ = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Sequence([KeyValue(name, head)]),
                        unparsed=Sequence(cs),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {description or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})


def sat(
    parser: Parser[E],
    predicate: Callable[[E], bool],
    on_fail: Callable[[E], ArgumentError],
) -&gt; Parser[E]:
    def f(x: E) -&gt; Result[E]:
        return Result(NonemptyList(x) if predicate(x) else on_fail(x))

    return apply(f, parser)


def sat_item(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    def _predicate(parsed: Sequence[KeyValue[str]]) -&gt; bool:
        [kv] = parsed
        return predicate(kv.value)

    def _on_fail(parsed: Sequence[KeyValue[str]]) -&gt; ArgumentError:
        [kv] = parsed
        return on_fail(kv.value)

    return sat(item(name), _predicate, _on_fail)


def sat_peak(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    def _predicate(parsed: Sequence[KeyValue[str]]) -&gt; bool:
        [kv] = parsed
        return predicate(kv.value)

    def _on_fail(parsed: Sequence[KeyValue[str]]) -&gt; ArgumentError:
        [kv] = parsed
        return on_fail(kv.value)

    return sat(peak(name), _predicate, _on_fail)


def type_(
    f: Callable[[str], Any], parser: Parser[Sequence[KeyValue[str]]]
) -&gt; Parser[Sequence[KeyValue[Any]]]:
    def g(
        kvs: Sequence[KeyValue[str]],
    ) -&gt; Result[Sequence[KeyValue[Any]]]:
        head, *tail = kvs.get
        try:
            y = f(head.value)
        except Exception as e:
            usage = f&#34;argument {head.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        head = replace(head, value=y)
        return Result.return_(Sequence([*tail, head]))

    p = apply(g, parser)
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dollar_lambda.parser.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>f: Callable[[E], Result[G]], parser: <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[E]) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[+G]</span>
</code></dt>
<dd>
<div class="desc"><p>Take the output of <code>parser</code> and apply <code>f</code> to it. Convert any errors that arise into <code>ArgumentError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(f: Callable[[E], Result[G]], parser: Parser[E]) -&gt; Parser[G]:
    &#34;&#34;&#34;
    Take the output of `parser` and apply `f` to it. Convert any errors that arise into `ArgumentError`.
    &#34;&#34;&#34;

    def g(a: E) -&gt; Parser[G]:
        try:
            y = f(a)
        except Exception as e:
            usage = f&#34;An argument {a}: raised exception {e}&#34;
            y = Result(ArgumentError(usage))
        return Parser(
            lambda unparsed: y
            &gt;= (lambda parsed: Result.return_(Parse(parsed, unparsed))),
            usage=parser.usage,
            helps=parser.helps,
        )

    return parser &gt;= g</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.apply_item"><code class="name flex">
<span>def <span class="ident">apply_item</span></span>(<span>f: Callable[[str], G], description: str) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[+G]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_item(f: Callable[[str], G], description: str) -&gt; Parser[G]:
    def g(parsed: Sequence[KeyValue[str]]) -&gt; Result[G]:
        [kv] = parsed
        try:
            y = f(kv.value)
        except Exception as e:
            usage = f&#34;argument {kv.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        return Result.return_(y)

    return apply(g, item(description))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.argument"><code class="name flex">
<span>def <span class="ident">argument</span></span>(<span>dest: str) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;name&quot;).parse_args(&quot;Alice&quot;)
{'name': 'Alice'}
&gt;&gt;&gt; argument(&quot;name&quot;).parse_args()
usage: name
The following arguments are required: name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def argument(dest: str) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args()
    usage: name
    The following arguments are required: name
    &#34;&#34;&#34;
    return item(dest)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.binary_usage"><code class="name flex">
<span>def <span class="ident">binary_usage</span></span>(<span>a: Optional[str], op: str, b: Optional[str], add_brackets=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility for generating usage strings for binary operators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def binary_usage(a: Optional[str], op: str, b: Optional[str], add_brackets=True):
    &#34;&#34;&#34;
    Utility for generating usage strings for binary operators.
    &#34;&#34;&#34;
    no_nones = [x for x in (a, b) if x is not None]
    usage = op.join(no_nones)
    if len(no_nones) &gt; 1 and add_brackets:
        usage = f&#34;[{usage}]&#34;
    return usage or None</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.defaults"><code class="name flex">
<span>def <span class="ident">defaults</span></span>(<span>**kwargs: Any) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defaults(**kwargs: Any) -&gt; Parser[Sequence[KeyValue[Any]]]:
    p = Parser.return_(Sequence([KeyValue(k, v) for k, v in kwargs.items()]))
    return replace(p, usage=None)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~F]]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; done().parse_args()
{}
&gt;&gt;&gt; done().parse_args(&quot;arg&quot;)
Unrecognized argument: arg
&gt;&gt;&gt; (argument(&quot;arg&quot;) &gt;&gt; done()).parse_args(&quot;a&quot;)
{'arg': 'a'}
&gt;&gt;&gt; (argument(&quot;arg&quot;) &gt;&gt; done()).parse_args(&quot;a&quot;, &quot;b&quot;)
usage: arg
Unrecognized argument: b
&gt;&gt;&gt; (flag(&quot;arg&quot;).many() &gt;&gt; done()).parse_args(&quot;--arg&quot;, &quot;--arg&quot;, return_dict=False)
[('arg', True), ('arg', True)]
&gt;&gt;&gt; (flag(&quot;arg&quot;).many() &gt;&gt; done()).parse_args(&quot;--arg&quot;, &quot;--arg&quot;, &quot;x&quot;)
usage: [--arg ...]
Unrecognized argument: x
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done() -&gt; Parser[Sequence[F]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; done().parse_args()
    {}
    &gt;&gt;&gt; done().parse_args(&#34;arg&#34;)
    Unrecognized argument: arg
    &gt;&gt;&gt; (argument(&#34;arg&#34;) &gt;&gt; done()).parse_args(&#34;a&#34;)
    {&#39;arg&#39;: &#39;a&#39;}
    &gt;&gt;&gt; (argument(&#34;arg&#34;) &gt;&gt; done()).parse_args(&#34;a&#34;, &#34;b&#34;)
    usage: arg
    Unrecognized argument: b
    &gt;&gt;&gt; (flag(&#34;arg&#34;).many() &gt;&gt; done()).parse_args(&#34;--arg&#34;, &#34;--arg&#34;, return_dict=False)
    [(&#39;arg&#39;, True), (&#39;arg&#39;, True)]
    &gt;&gt;&gt; (flag(&#34;arg&#34;).many() &gt;&gt; done()).parse_args(&#34;--arg&#34;, &#34;--arg&#34;, &#34;x&#34;)
    usage: [--arg ...]
    Unrecognized argument: x
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[Sequence[F]]]:
        if cs:
            c, *_ = cs
            return Result(
                UnexpectedError(unexpected=c, usage=f&#34;Unrecognized argument: {c}&#34;)
            )
        return Result(NonemptyList(Parse(parsed=Sequence([]), unparsed=cs)))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~B]]</span>
</code></dt>
<dd>
<div class="desc"><p>Always returns {}, no matter the input. Mostly useful for use in <code><a title="dollar_lambda.parser.nonpositional" href="#dollar_lambda.parser.nonpositional">nonpositional()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; empty().parse_args(&quot;any&quot;, &quot;arguments&quot;)
{}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty() -&gt; Parser[Sequence[B]]:
    &#34;&#34;&#34;
    Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
    &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
    {}
    &#34;&#34;&#34;
    return Parser.return_(Sequence([]))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.equals"><code class="name flex">
<span>def <span class="ident">equals</span></span>(<span>s: str, peak=False) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equals(s: str, peak=False) -&gt; Parser[Sequence[KeyValue[str]]]:
    if peak:
        return sat_peak(
            predicate=lambda _s: _s == s,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )
    else:
        return sat_item(
            predicate=lambda _s: _s == s,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.flag"><code class="name flex">
<span>def <span class="ident">flag</span></span>(<span>dest: str, default: Optional[bool] = None, help: Optional[str] = None, short: bool = True, string: Optional[str] = None) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[bool]]]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;, default=False)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
&gt;&gt;&gt; p.parse_args()
{'verbose': False}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--verbose&quot;, &quot;--verbose&quot;)
{'verbose': True}
&gt;&gt;&gt; flag(&quot;v&quot;, string=&quot;--value&quot;).parse_args(&quot;--value&quot;)
{'v': True}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;verbose&quot;, default=False) | flag(&quot;quiet&quot;, default=False) | flag(&quot;yes&quot;, default=False)
&gt;&gt;&gt; p = p1 &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;value&quot;)
usage: [[--verbose | --quiet] | --yes]
Unrecognized argument: value
&gt;&gt;&gt; p.parse_args(&quot;value&quot;)
usage: [[--verbose | --quiet] | --yes]
Unrecognized argument: value
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
&gt;&gt;&gt; p1 = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;) | flag(&quot;yes&quot;)
&gt;&gt;&gt; p = p1 &gt;&gt; argument(&quot;a&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
usage: [[--verbose | --quiet] | --yes] a
The following arguments are required: a
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)
usage: [[--verbose | --quiet] | --yes] a
Expected '--verbose'. Got 'a'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flag(
    dest: str,
    default: Optional[bool] = None,
    help: Optional[str] = None,
    short: bool = True,
    string: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[bool]]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, default=False)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--verbose&#34;, &#34;--verbose&#34;)
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; flag(&#34;v&#34;, string=&#34;--value&#34;).parse_args(&#34;--value&#34;)
    {&#39;v&#39;: True}

    &gt;&gt;&gt; p1 = flag(&#34;verbose&#34;, default=False) | flag(&#34;quiet&#34;, default=False) | flag(&#34;yes&#34;, default=False)
    &gt;&gt;&gt; p = p1 &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;value&#34;)
    usage: [[--verbose | --quiet] | --yes]
    Unrecognized argument: value
    &gt;&gt;&gt; p.parse_args(&#34;value&#34;)
    usage: [[--verbose | --quiet] | --yes]
    Unrecognized argument: value
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; p1 = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | flag(&#34;yes&#34;)
    &gt;&gt;&gt; p = p1 &gt;&gt; argument(&#34;a&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    usage: [[--verbose | --quiet] | --yes] a
    The following arguments are required: a
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
    usage: [[--verbose | --quiet] | --yes] a
    Expected &#39;--verbose&#39;. Got &#39;a&#39;
    &#34;&#34;&#34;
    if string is None:
        _string = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _string = string

    def f(
        cs: Sequence[str],
        s: str,
    ) -&gt; Result[Parse[Sequence[KeyValue[bool]]]]:
        parser = equals(s) &gt;= (lambda _: defaults(**{dest: not default}))
        return parser.parse(cs)

    parser = Parser(partial(f, s=_string), usage=None, helps={})
    if default is not None:
        parser = parser | defaults(**{dest: default})
    if short:
        short_string = f&#34;-{dest[0]}&#34;
        parser2 = flag(dest, short=False, string=short_string, default=default)
        parser = parser | parser2
    if default:
        help = f&#34;{help + &#39; &#39; if help else &#39;&#39;}(default: {default})&#34;
    helps = {dest: help} if help else {}
    return replace(parser, usage=_string, helps=helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.help_parser"><code class="name flex">
<span>def <span class="ident">help_parser</span></span>(<span>usage: str, parsed: B) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[~B]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def help_parser(usage: str, parsed: B) -&gt; Parser[B]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[B]]:
        result = (equals(&#34;--help&#34;, peak=True) | equals(&#34;-h&#34;, peak=True)).parse(cs)
        if isinstance(result.get, ArgumentError):
            return Result.return_(Parse(parsed=parsed, unparsed=cs))
        return Result(HelpError(usage=usage))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.item"><code class="name flex">
<span>def <span class="ident">item</span></span>(<span>name: str, description: Optional[str] = None) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item(
    name: str,
    description: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        if cs:
            head, *tail = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Sequence([KeyValue(name, head)]),
                        unparsed=Sequence(tail),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {description or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.nonpositional"><code class="name flex">
<span>def <span class="ident">nonpositional</span></span>(<span>*parsers: "'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[F]]'") ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~F]]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;debug&quot;, default=False)) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--debug&quot;)
{'verbose': True, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;, &quot;--verbose&quot;)
{'debug': True, 'verbose': True}
&gt;&gt;&gt; p.parse_args()
{'verbose': False, 'debug': False}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;)
{'verbose': False, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True, 'debug': False}
&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;debug&quot;, default=False)) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--debug&quot;)
{'verbose': True, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True, 'debug': False}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;)
{'verbose': False, 'debug': True}
&gt;&gt;&gt; p.parse_args()
{'verbose': False, 'debug': False}
&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;debug&quot;, default=False), argument(&quot;a&quot;)) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;, &quot;hello&quot;, &quot;--verbose&quot;)
{'debug': True, 'a': 'hello', 'verbose': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nonpositional(*parsers: &#34;Parser[Sequence[F]]&#34;) -&gt; &#34;Parser[Sequence[F]]&#34;:
    &#34;&#34;&#34;
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;debug&#34;, default=False)) &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False, &#39;debug&#39;: False}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    {&#39;verbose&#39;: False, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: False}
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;debug&#34;, default=False)) &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: False}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    {&#39;verbose&#39;: False, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False, &#39;debug&#39;: False}
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;debug&#34;, default=False), argument(&#34;a&#34;)) &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;hello&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;a&#39;: &#39;hello&#39;, &#39;verbose&#39;: True}
    &#34;&#34;&#34;
    if not parsers:
        return empty()

    def get_alternatives():
        for i, head in enumerate(parsers):
            tail = [p for j, p in enumerate(parsers) if j != i]
            yield head &gt;&gt; nonpositional(*tail)

    parser = reduce(operator.or_, get_alternatives())
    sep = &#34; &#34; if len(parsers) &lt;= 3 else &#34;\n&#34;
    return replace(parser, usage=sep.join([p.usage or &#34;&#34; for p in parsers]))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.option"><code class="name flex">
<span>def <span class="ident">option</span></span>(<span>dest: str, flag: Optional[str] = None, default=None, help: Optional[str] = None, short: bool = True, type: Callable[[str], Any] = builtins.str) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;value&quot;).parse_args(&quot;--value&quot;, &quot;x&quot;)
{'value': 'x'}
&gt;&gt;&gt; option(&quot;value&quot;).parse_args(&quot;--value&quot;)
usage: --value VALUE
The following arguments are required: VALUE
&gt;&gt;&gt; option(&quot;value&quot;).parse_args()
usage: --value VALUE
The following arguments are required: --value
&gt;&gt;&gt; option(&quot;value&quot;, default=1).parse_args()
{'value': 1}
&gt;&gt;&gt; option(&quot;value&quot;, default=1).parse_args(&quot;--value&quot;)
{'value': 1}
&gt;&gt;&gt; option(&quot;value&quot;, default=1).parse_args(&quot;--value&quot;, &quot;x&quot;)
{'value': 'x'}
&gt;&gt;&gt; option(&quot;v&quot;).parse_args(&quot;-v&quot;, &quot;x&quot;)
{'v': 'x'}
&gt;&gt;&gt; option(&quot;v&quot;, flag=&quot;--value&quot;).parse_args(&quot;--value&quot;, &quot;x&quot;)
{'v': 'x'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def option(
    dest: str,
    flag: Optional[str] = None,
    default=None,
    help: Optional[str] = None,
    short: bool = True,
    type: Callable[[str], Any] = str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; option(&#34;value&#34;).parse_args(&#34;--value&#34;, &#34;x&#34;)
    {&#39;value&#39;: &#39;x&#39;}
    &gt;&gt;&gt; option(&#34;value&#34;).parse_args(&#34;--value&#34;)
    usage: --value VALUE
    The following arguments are required: VALUE
    &gt;&gt;&gt; option(&#34;value&#34;).parse_args()
    usage: --value VALUE
    The following arguments are required: --value
    &gt;&gt;&gt; option(&#34;value&#34;, default=1).parse_args()
    {&#39;value&#39;: 1}
    &gt;&gt;&gt; option(&#34;value&#34;, default=1).parse_args(&#34;--value&#34;)
    {&#39;value&#39;: 1}
    &gt;&gt;&gt; option(&#34;value&#34;, default=1).parse_args(&#34;--value&#34;, &#34;x&#34;)
    {&#39;value&#39;: &#39;x&#39;}
    &gt;&gt;&gt; option(&#34;v&#34;).parse_args(&#34;-v&#34;, &#34;x&#34;)
    {&#39;v&#39;: &#39;x&#39;}
    &gt;&gt;&gt; option(&#34;v&#34;, flag=&#34;--value&#34;).parse_args(&#34;--value&#34;, &#34;x&#34;)
    {&#39;v&#39;: &#39;x&#39;}
    &#34;&#34;&#34;

    if flag is None:
        _flag = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _flag = flag

    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        parser = equals(_flag) &gt;= (lambda _: item(dest, description=dest.upper()))
        return parser.parse(cs)

    parser = Parser(f, usage=None, helps={})
    if default:
        parser = parser | defaults(**{dest: default})
    if short and len(dest) &gt; 1:
        parser2 = option(dest=dest, short=False, flag=f&#34;-{dest[0]}&#34;, default=None)
        parser = parser | parser2
    if type is not str:
        parser = type_(type, parser)
    helps = {dest: help} if help else {}
    return replace(parser, usage=f&#34;{_flag} {dest.upper()}&#34;, helps=helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.peak"><code class="name flex">
<span>def <span class="ident">peak</span></span>(<span>name: str, description: Optional[str] = None) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak(
    name: str,
    description: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        if cs:
            head, *_ = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Sequence([KeyValue(name, head)]),
                        unparsed=Sequence(cs),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {description or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.sat"><code class="name flex">
<span>def <span class="ident">sat</span></span>(<span>parser: <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[E], predicate: Callable[[E], bool], on_fail: Callable[[E], ArgumentError]) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[~E]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sat(
    parser: Parser[E],
    predicate: Callable[[E], bool],
    on_fail: Callable[[E], ArgumentError],
) -&gt; Parser[E]:
    def f(x: E) -&gt; Result[E]:
        return Result(NonemptyList(x) if predicate(x) else on_fail(x))

    return apply(f, parser)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.sat_item"><code class="name flex">
<span>def <span class="ident">sat_item</span></span>(<span>predicate: Callable[[str], bool], on_fail: Callable[[str], ArgumentError], name: str) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sat_item(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    def _predicate(parsed: Sequence[KeyValue[str]]) -&gt; bool:
        [kv] = parsed
        return predicate(kv.value)

    def _on_fail(parsed: Sequence[KeyValue[str]]) -&gt; ArgumentError:
        [kv] = parsed
        return on_fail(kv.value)

    return sat(item(name), _predicate, _on_fail)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.sat_peak"><code class="name flex">
<span>def <span class="ident">sat_peak</span></span>(<span>predicate: Callable[[str], bool], on_fail: Callable[[str], ArgumentError], name: str) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sat_peak(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    def _predicate(parsed: Sequence[KeyValue[str]]) -&gt; bool:
        [kv] = parsed
        return predicate(kv.value)

    def _on_fail(parsed: Sequence[KeyValue[str]]) -&gt; ArgumentError:
        [kv] = parsed
        return on_fail(kv.value)

    return sat(peak(name), _predicate, _on_fail)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.type_"><code class="name flex">
<span>def <span class="ident">type_</span></span>(<span>f: Callable[[str], Any], parser: <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[KeyValue[str]]]) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_(
    f: Callable[[str], Any], parser: Parser[Sequence[KeyValue[str]]]
) -&gt; Parser[Sequence[KeyValue[Any]]]:
    def g(
        kvs: Sequence[KeyValue[str]],
    ) -&gt; Result[Sequence[KeyValue[Any]]]:
        head, *tail = kvs.get
        try:
            y = f(head.value)
        except Exception as e:
            usage = f&#34;argument {head.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        head = replace(head, value=y)
        return Result.return_(Sequence([*tail, head]))

    p = apply(g, parser)
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.wrap_help"><code class="name flex">
<span>def <span class="ident">wrap_help</span></span>(<span>parser: <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[C]]) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~C]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_help(parser: Parser[Sequence[C]]) -&gt; Parser[Sequence[C]]:
    _help_parser: Parser[Sequence[C]] = help_parser(
        parser.usage or &#34;No usage provided.&#34;, Sequence([])
    )

    p = _help_parser &gt;= (lambda _: parser)
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dollar_lambda.parser.Parser"><code class="flex name class">
<span>class <span class="ident">Parser</span></span>
<span>(</span><span>f: Callable[[Sequence[str]], Result[Parse[A]]], usage: Optional[str], helps: Dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Main class powering the argument parser.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Parser(MonadPlus[A]):
    &#34;&#34;&#34;
    Main class powering the argument parser.
    &#34;&#34;&#34;

    __pdoc__[&#34;Parser.__add__&#34;] = True
    __pdoc__[&#34;Parser.__or__&#34;] = True
    __pdoc__[&#34;Parser.__rshift__&#34;] = True
    __pdoc__[&#34;Parser.__ge__&#34;] = True

    f: Callable[[Sequence[str]], Result[Parse[A]]]
    usage: Optional[str]
    helps: Dict[str, str]

    def __add__(
        self: Parser[Sequence[D]], other: Parser[Sequence[B]]
    ) -&gt; Parser[Sequence[D | B]]:
        &#34;&#34;&#34;
        Parse two arguments in either order.
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
        {&#39;verbose&#39;: True, &#39;debug&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
        {&#39;debug&#39;: True, &#39;verbose&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
        usage: --verbose --debug
        Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

        Note that if more than two arguments are chained together with `+`, some combinations will not parse:
        &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
        {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
        usage: -a -b -c
        Expected &#39;-b&#39;. Got &#39;-c&#39;

        This makes more sense when one supplies the implicit parentheses:
        &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

        In order to chain together more than two arguments, use `nonpositional`:
        &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
        {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
        &#34;&#34;&#34;
        p = (self &gt;&gt; other) | (other &gt;&gt; self)
        usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
        return replace(p, usage=usage)

    def __or__(
        self: Parser[A],
        other: Parser[B],
    ) -&gt; Parser[A | B]:
        &#34;&#34;&#34;
        Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

        &gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
        &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
        {&#39;verbose&#39;: True}

        Note that when both arguments are supplied, this will only parse the first:
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        {&#39;verbose&#39;: True}

        If you want this to fail, use `&gt;&gt;` (`Parser.__rshift__`) with `done()` or another parser:
        &gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        usage: [--option OPTION | --verbose]
        Unrecognized argument: --option
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A | B]]:
            return self.parse(cs) | other.parse(cs)

        return Parser(
            f,
            usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
            helps={**self.helps, **other.helps},
        )

    def __rshift__(
        self: Parser[Sequence[D]], p: Parser[Sequence[B]]
    ) -&gt; Parser[Sequence[D | B]]:
        &#34;&#34;&#34;
        This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
        gets handed off to the second parser. If either parser fails, the whole thing fails.

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        usage: first second
        The following arguments are required: second
        &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
        usage: first second
        The following arguments are required: second
        &#34;&#34;&#34;
        # def f(p1: Sequence[D]) -&gt; Parser[Parse[Sequence[D | B]]]:
        #     def g(p2: Sequence[B]) -&gt; Parser[Sequence[D | B]]:
        #         return Parser.return_(p1 + p2)

        #     return p &gt;= g

        # return self &gt;= f
        parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
        return replace(
            parser, usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False)
        )

    def bind(self, f: Callable[[A], Parser[B]]) -&gt; Parser[B]:
        &#34;&#34;&#34;
        Returns a new parser that

        1. applies `self`;
        2. if this succeeds, applies `f` to the parsed component of the result.

        `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
        avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
        `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

        Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
        and we typically prefer using the infix operator to the spelled out method.

        Let&#39;s start with our simplest parser, `argument`:
        &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

        Now let&#39;s use the `equals` parser to write a function that takes the output of `p1` and fails unless
        the next argument is the same as the first:
        &gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Sequence(KeyValue[str]):
        ...     [kv] = kvs
        ...     return equals(kv.value)

        &gt;&gt;&gt; p = p1 &gt;= f
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
        {&#39;a&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        Expected &#39;a&#39;. Got &#39;b&#39;
        &#34;&#34;&#34;

        def h(parse: Parse[A]) -&gt; Result[Parse[B]]:
            return f(parse.parsed).parse(parse.unparsed)

        def g(cs: Sequence[str]) -&gt; Result[Parse[B]]:
            return self.parse(cs) &gt;= h

        return Parser(g, usage=None, helps=self.helps)

    def many(self: &#34;Parser[Sequence[B]]&#34;) -&gt; &#34;Parser[Sequence[B]]&#34;:
        &#34;&#34;&#34;
        Applies `self` zero or more times (like `*` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(return_dict=False)
        []
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, return_dict=False)
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;)]
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)  # return_dict=False allows duplicate keys
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

        Note that if `self` contains `Parser.__or__`, the arguments can be
        heterogenous:
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
        &gt;&gt;&gt; p = p.many()
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, return_dict=False) # mix --verbose and --quiet
        [(&#39;verbose&#39;, True), (&#39;quiet&#39;, True)]
        &#34;&#34;&#34;
        p = self.many1() | empty()
        return replace(p, usage=f&#34;[{self.usage} ...]&#34;)

    def many1(self: &#34;Parser[Sequence[B]]&#34;) -&gt; &#34;Parser[Sequence[B]]&#34;:
        &#34;&#34;&#34;
        Applies `self` one or more times (like `+` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
        {&#39;1-or-more&#39;: &#39;1&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, return_dict=False)  # return_dict=False allows duplicate keys
        [(&#39;1-or-more&#39;, &#39;1&#39;), (&#39;1-or-more&#39;, &#39;2&#39;)]
        &gt;&gt;&gt; p.parse_args()
        usage: 1-or-more [1-or-more ...]
        The following arguments are required: 1-or-more
        &#34;&#34;&#34;

        def g() -&gt; Generator[&#34;Parser[Sequence[B]]&#34;, Sequence[B], None]:
            # noinspection PyTypeChecker
            r1: Sequence[B] = yield self
            # noinspection PyTypeChecker
            r2: Sequence[B] = yield self.many()
            yield Parser[Sequence[B]].return_(r1 + r2)

        @lru_cache()
        def f(cs: tuple):
            return Parser.do(g).parse(Sequence(list(cs)))

        return Parser(
            lambda cs: f(tuple(cs)),
            usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
            helps=self.helps,
        )

    def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A]]:
        &#34;&#34;&#34;
        Applies the parser to the input sequence `cs`.
        &#34;&#34;&#34;
        return self.f(cs)

    def parse_args(
        self: &#34;Parser[Sequence[KeyValue]]&#34;,
        *args: str,
        return_dict: bool = True,
        check_help: bool = True,
    ) -&gt; typing.Sequence[KeyValueTuple] | Dict[str, Any]:
        &#34;&#34;&#34;
        The main way the user extracts parsed results from the parser.

        Parameters
        ----------
        args : str
            A sequence of strings to parse (e.g. `sys.argv[1:]`).
        return_dict : bool
            Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
            The tuples are `KeyValueTuple` namedtuples, with fields `key` and `value`.
        check_help : bool
            Before running the parser, checks if the input string is `--help` or `-h`.
            If it is, returns the usage message.

        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
        usage: a
        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
        usage: a
        &#34;&#34;&#34;
        if check_help:
            return wrap_help(self).parse_args(
                *args, return_dict=return_dict, check_help=False
            )
        result = self.parse(Sequence(list(args))).get
        if isinstance(result, ArgumentError):
            if self.usage and not isinstance(result, HelpError):
                print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in self.usage else &#34; &#34;)
                if &#34;\n&#34; in self.usage:
                    usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in self.usage.split(&#34;\n&#34;)])
                else:
                    usage = self.usage
                print(usage)
            if self.helps:
                for k, v in self.helps.items():
                    print(f&#34;{k}: {v}&#34;)
            if result.usage:
                if isinstance(result, HelpError):
                    print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in result.usage else &#34; &#34;)
                print(result.usage)
            if TESTING:
                return  # type: ignore[return-value]
            else:
                exit()

        nel: NonemptyList[Parse[Sequence[KeyValue]]] = result
        parse: Parse[Sequence[KeyValue]] = nel.head
        kvs: Sequence[KeyValue] = parse.parsed
        if return_dict:
            return {kv.key: kv.value for kv in kvs}
        return [KeyValueTuple(**asdict(kv)) for kv in kvs]

    @classmethod
    def return_(cls, a: A) -&gt; Parser[A]:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
        and always returns `a` as the result. For the most part, the user will not use
        this method unless building custom parsers.

        &gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
        &gt;&gt;&gt; Parser.return_(([KeyValue(&#34;some-key&#34;, &#34;some-value&#34;)])).parse_args()
        {&#39;some-key&#39;: &#39;some-value&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A]]:
            return Result.return_(Parse(a, cs))

        return Parser(f, usage=None, helps={})

    @classmethod
    def zero(cls: Type[Parser[A]], error: Optional[ArgumentError] = None) -&gt; Parser[A]:
        &#34;&#34;&#34;
        This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

        Parameters
        ----------
        error : Optional[ArgumentError]
            Customize the error returned by `zero`.

        &gt;&gt;&gt; Parser.zero().parse_args()
        zero
        &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
        zero
        &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
        This is a test.
        &#34;&#34;&#34;
        return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pytypeclass.monoid.MonadPlus</li>
<li>pytypeclass.monad.Monad</li>
<li>pytypeclass.monoid.Monoid</li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.parser.Parser.f"><code class="name">var <span class="ident">f</span> : Callable[[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[str]], <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parse.Parse" href="parse.html#dollar_lambda.parse.Parse">Parse</a>[+A]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.parser.Parser.helps"><code class="name">var <span class="ident">helps</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.parser.Parser.usage"><code class="name">var <span class="ident">usage</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dollar_lambda.parser.Parser.return_"><code class="name flex">
<span>def <span class="ident">return_</span></span>(<span>a: A) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[+A]</span>
</code></dt>
<dd>
<div class="desc"><p>This method is required to make <code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. It consumes none of the input
and always returns <code>a</code> as the result. For the most part, the user will not use
this method unless building custom parsers.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
&gt;&gt;&gt; Parser.return_(([KeyValue(&quot;some-key&quot;, &quot;some-value&quot;)])).parse_args()
{'some-key': 'some-value'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def return_(cls, a: A) -&gt; Parser[A]:  # type: ignore[misc]
    # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
    &#34;&#34;&#34;
    This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
    and always returns `a` as the result. For the most part, the user will not use
    this method unless building custom parsers.

    &gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
    &gt;&gt;&gt; Parser.return_(([KeyValue(&#34;some-key&#34;, &#34;some-value&#34;)])).parse_args()
    {&#39;some-key&#39;: &#39;some-value&#39;}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[A]]:
        return Result.return_(Parse(a, cs))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.zero"><code class="name flex">
<span>def <span class="ident">zero</span></span>(<span>error: Optional[ArgumentError] = None) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[+A]</span>
</code></dt>
<dd>
<div class="desc"><p>This parser always fails. This method is necessary to make <code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13"><code>Monoid</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>error</code></strong> :&ensp;<code>Optional[ArgumentError]</code></dt>
<dd>Customize the error returned by <code>zero</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.zero().parse_args()
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero().parse_args(&quot;a&quot;)
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero(error=ArgumentError(&quot;This is a test.&quot;)).parse_args(&quot;a&quot;)
This is a test.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def zero(cls: Type[Parser[A]], error: Optional[ArgumentError] = None) -&gt; Parser[A]:
    &#34;&#34;&#34;
    This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

    Parameters
    ----------
    error : Optional[ArgumentError]
        Customize the error returned by `zero`.

    &gt;&gt;&gt; Parser.zero().parse_args()
    zero
    &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
    zero
    &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
    This is a test.
    &#34;&#34;&#34;
    return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.parser.Parser.__add__"><code class="name flex">
<span>def <span class="ident">__add__</span></span>(<span>self: <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[D]], other: <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[B]]) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[D | B]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse two arguments in either order.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;debug&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--debug&quot;)
{'verbose': True, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;, &quot;--verbose&quot;)
{'debug': True, 'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;)
usage: --verbose --debug
Expected '--verbose'. Got '--debug'
</code></pre>
<p>Note that if more than two arguments are chained together with <code>+</code>, some combinations will not parse:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;a&quot;) + flag(&quot;b&quot;) + flag(&quot;c&quot;)
&gt;&gt;&gt; p.parse_args(&quot;-c&quot;, &quot;-a&quot;, &quot;-b&quot;)   # this works
{'c': True, 'a': True, 'b': True}
&gt;&gt;&gt; p.parse_args(&quot;-a&quot;, &quot;-c&quot;, &quot;-b&quot;)   # this doesn't
usage: -a -b -c
Expected '-b'. Got '-c'
</code></pre>
<p>This makes more sense when one supplies the implicit parentheses:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (flag(&quot;a&quot;) + flag(&quot;b&quot;)) + flag(&quot;c&quot;)
</code></pre>
<p>In order to chain together more than two arguments, use <code><a title="dollar_lambda.parser.nonpositional" href="#dollar_lambda.parser.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;a&quot;), flag(&quot;b&quot;), flag(&quot;c&quot;))
&gt;&gt;&gt; p.parse_args(&quot;-a&quot;, &quot;-c&quot;, &quot;-b&quot;)
{'a': True, 'c': True, 'b': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __add__(
    self: Parser[Sequence[D]], other: Parser[Sequence[B]]
) -&gt; Parser[Sequence[D | B]]:
    &#34;&#34;&#34;
    Parse two arguments in either order.
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    usage: --verbose --debug
    Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

    Note that if more than two arguments are chained together with `+`, some combinations will not parse:
    &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
    {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
    usage: -a -b -c
    Expected &#39;-b&#39;. Got &#39;-c&#39;

    This makes more sense when one supplies the implicit parentheses:
    &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

    In order to chain together more than two arguments, use `nonpositional`:
    &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
    {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
    &#34;&#34;&#34;
    p = (self &gt;&gt; other) | (other &gt;&gt; self)
    usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
    return replace(p, usage=usage)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.__or__"><code class="name flex">
<span>def <span class="ident">__or__</span></span>(<span>self: <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[A], other: <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[B]) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[A | B]</span>
</code></dt>
<dd>
<div class="desc"><p>Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
&gt;&gt;&gt; p = option(&quot;option&quot;) | flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--option&quot;, &quot;x&quot;)
{'option': 'x'}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<p>Note that when both arguments are supplied, this will only parse the first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--option&quot;, &quot;x&quot;)
{'verbose': True}
</code></pre>
<p>If you want this to fail, use <code>&gt;&gt;</code> (<code><a title="dollar_lambda.parser.Parser.__rshift__" href="#dollar_lambda.parser.Parser.__rshift__">Parser.__rshift__()</a></code>) with <code><a title="dollar_lambda.parser.done" href="#dollar_lambda.parser.done">done()</a></code> or another parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&quot;--verbose&quot;, &quot;--option&quot;, &quot;x&quot;)
usage: [--option OPTION | --verbose]
Unrecognized argument: --option
&gt;&gt;&gt; p.parse_args(&quot;--option&quot;, &quot;x&quot;)
{'option': 'x'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __or__(
    self: Parser[A],
    other: Parser[B],
) -&gt; Parser[A | B]:
    &#34;&#34;&#34;
    Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

    &gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
    &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
    {&#39;option&#39;: &#39;x&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}

    Note that when both arguments are supplied, this will only parse the first:
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
    {&#39;verbose&#39;: True}

    If you want this to fail, use `&gt;&gt;` (`Parser.__rshift__`) with `done()` or another parser:
    &gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
    usage: [--option OPTION | --verbose]
    Unrecognized argument: --option
    &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
    {&#39;option&#39;: &#39;x&#39;}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[A | B]]:
        return self.parse(cs) | other.parse(cs)

    return Parser(
        f,
        usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
        helps={**self.helps, **other.helps},
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.__rshift__"><code class="name flex">
<span>def <span class="ident">__rshift__</span></span>(<span>self: <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[D]], p: <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[B]]) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[D | B]]</span>
</code></dt>
<dd>
<div class="desc"><p>This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
gets handed off to the second parser. If either parser fails, the whole thing fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;first&quot;) &gt;&gt; argument(&quot;second&quot;)
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
{'first': 'a', 'second': 'b'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)
usage: first second
The following arguments are required: second
&gt;&gt;&gt; p.parse_args(&quot;b&quot;)
usage: first second
The following arguments are required: second
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __rshift__(
    self: Parser[Sequence[D]], p: Parser[Sequence[B]]
) -&gt; Parser[Sequence[D | B]]:
    &#34;&#34;&#34;
    This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
    gets handed off to the second parser. If either parser fails, the whole thing fails.

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
    usage: first second
    The following arguments are required: second
    &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
    usage: first second
    The following arguments are required: second
    &#34;&#34;&#34;
    # def f(p1: Sequence[D]) -&gt; Parser[Parse[Sequence[D | B]]]:
    #     def g(p2: Sequence[B]) -&gt; Parser[Sequence[D | B]]:
    #         return Parser.return_(p1 + p2)

    #     return p &gt;= g

    # return self &gt;= f
    parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
    return replace(
        parser, usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False)
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.bind"><code class="name flex">
<span>def <span class="ident">bind</span></span>(<span>self, f: Callable[[A], <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[B]]) ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[~B]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new parser that</p>
<ol>
<li>applies <code>self</code>;</li>
<li>if this succeeds, applies <code>f</code> to the parsed component of the result.</li>
</ol>
<p><code>bind</code> is one of the functions that makes <code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. But most users will
avoid using it directly, preferring higher level combinators like <code>&gt;&gt;</code> (<code><a title="dollar_lambda.parser.Parser.__rshift__" href="#dollar_lambda.parser.Parser.__rshift__">Parser.__rshift__()</a></code>),
<code>|</code> (<code><a title="dollar_lambda.parser.Parser.__or__" href="#dollar_lambda.parser.Parser.__or__">Parser.__or__()</a></code>) and <code>+</code> (<code><a title="dollar_lambda.parser.Parser.__add__" href="#dollar_lambda.parser.Parser.__add__">Parser.__add__()</a></code>).</p>
<p>Note that <code>&gt;=</code> as a synonym for <code>bind</code> (as defined in <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26"><code>pytypeclass</code></a>)
and we typically prefer using the infix operator to the spelled out method.</p>
<p>Let's start with our simplest parser, <code><a title="dollar_lambda.parser.argument" href="#dollar_lambda.parser.argument">argument()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = argument(&quot;some_dest&quot;)
</code></pre>
<p>Now let's use the <code><a title="dollar_lambda.parser.equals" href="#dollar_lambda.parser.equals">equals()</a></code> parser to write a function that takes the output of <code>p1</code> and fails unless
the next argument is the same as the first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Sequence(KeyValue[str]):
...     [kv] = kvs
...     return equals(kv.value)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = p1 &gt;= f
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;a&quot;)
{'a': 'a'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
Expected 'a'. Got 'b'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind(self, f: Callable[[A], Parser[B]]) -&gt; Parser[B]:
    &#34;&#34;&#34;
    Returns a new parser that

    1. applies `self`;
    2. if this succeeds, applies `f` to the parsed component of the result.

    `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
    avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
    `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

    Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
    and we typically prefer using the infix operator to the spelled out method.

    Let&#39;s start with our simplest parser, `argument`:
    &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

    Now let&#39;s use the `equals` parser to write a function that takes the output of `p1` and fails unless
    the next argument is the same as the first:
    &gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Sequence(KeyValue[str]):
    ...     [kv] = kvs
    ...     return equals(kv.value)

    &gt;&gt;&gt; p = p1 &gt;= f
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
    {&#39;a&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    Expected &#39;a&#39;. Got &#39;b&#39;
    &#34;&#34;&#34;

    def h(parse: Parse[A]) -&gt; Result[Parse[B]]:
        return f(parse.parsed).parse(parse.unparsed)

    def g(cs: Sequence[str]) -&gt; Result[Parse[B]]:
        return self.parse(cs) &gt;= h

    return Parser(g, usage=None, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.many"><code class="name flex">
<span>def <span class="ident">many</span></span>(<span>self: "'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[B]]'") ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~B]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> zero or more times (like <code>*</code> in regexes).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(return_dict=False)
[]
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, return_dict=False)
[('as-many-as-you-like', 'a')]
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;, return_dict=False)  # return_dict=False allows duplicate keys
[('as-many-as-you-like', 'a'), ('as-many-as-you-like', 'b')]
</code></pre>
<p>Note that if <code>self</code> contains <code><a title="dollar_lambda.parser.Parser.__or__" href="#dollar_lambda.parser.Parser.__or__">Parser.__or__()</a></code>, the arguments can be
heterogenous:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p = p.many()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;, return_dict=False) # mix --verbose and --quiet
[('verbose', True), ('quiet', True)]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def many(self: &#34;Parser[Sequence[B]]&#34;) -&gt; &#34;Parser[Sequence[B]]&#34;:
    &#34;&#34;&#34;
    Applies `self` zero or more times (like `*` in regexes).

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(return_dict=False)
    []
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, return_dict=False)
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;)]
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)  # return_dict=False allows duplicate keys
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

    Note that if `self` contains `Parser.__or__`, the arguments can be
    heterogenous:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
    &gt;&gt;&gt; p = p.many()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, return_dict=False) # mix --verbose and --quiet
    [(&#39;verbose&#39;, True), (&#39;quiet&#39;, True)]
    &#34;&#34;&#34;
    p = self.many1() | empty()
    return replace(p, usage=f&#34;[{self.usage} ...]&#34;)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.many1"><code class="name flex">
<span>def <span class="ident">many1</span></span>(<span>self: "'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[B]]'") ‑> <a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~B]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> one or more times (like <code>+</code> in regexes).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;1-or-more&quot;).many1()
&gt;&gt;&gt; p.parse_args(&quot;1&quot;)
{'1-or-more': '1'}
&gt;&gt;&gt; p.parse_args(&quot;1&quot;, &quot;2&quot;, return_dict=False)  # return_dict=False allows duplicate keys
[('1-or-more', '1'), ('1-or-more', '2')]
&gt;&gt;&gt; p.parse_args()
usage: 1-or-more [1-or-more ...]
The following arguments are required: 1-or-more
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def many1(self: &#34;Parser[Sequence[B]]&#34;) -&gt; &#34;Parser[Sequence[B]]&#34;:
    &#34;&#34;&#34;
    Applies `self` one or more times (like `+` in regexes).

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
    {&#39;1-or-more&#39;: &#39;1&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, return_dict=False)  # return_dict=False allows duplicate keys
    [(&#39;1-or-more&#39;, &#39;1&#39;), (&#39;1-or-more&#39;, &#39;2&#39;)]
    &gt;&gt;&gt; p.parse_args()
    usage: 1-or-more [1-or-more ...]
    The following arguments are required: 1-or-more
    &#34;&#34;&#34;

    def g() -&gt; Generator[&#34;Parser[Sequence[B]]&#34;, Sequence[B], None]:
        # noinspection PyTypeChecker
        r1: Sequence[B] = yield self
        # noinspection PyTypeChecker
        r2: Sequence[B] = yield self.many()
        yield Parser[Sequence[B]].return_(r1 + r2)

    @lru_cache()
    def f(cs: tuple):
        return Parser.do(g).parse(Sequence(list(cs)))

    return Parser(
        lambda cs: f(tuple(cs)),
        usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
        helps=self.helps,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, cs: Sequence[str]) ‑> <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parse.Parse" href="parse.html#dollar_lambda.parse.Parse">Parse</a>[+A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the parser to the input sequence <code>cs</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A]]:
    &#34;&#34;&#34;
    Applies the parser to the input sequence `cs`.
    &#34;&#34;&#34;
    return self.f(cs)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.parser.Parser.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>self: "'<a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a>[Sequence[KeyValue]]'", *args: str, return_dict: bool = True, check_help: bool = True) ‑> typing.Sequence[KeyValueTuple] | Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>The main way the user extracts parsed results from the parser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>str</code></dt>
<dd>A sequence of strings to parse (e.g. <code>sys.argv[1:]</code>).</dd>
<dt><strong><code>return_dict</code></strong> :&ensp;<code>bool</code></dt>
<dd>Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
The tuples are <code>KeyValueTuple</code> namedtuples, with fields <code>key</code> and <code>value</code>.</dd>
<dt><strong><code>check_help</code></strong> :&ensp;<code>bool</code></dt>
<dd>Before running the parser, checks if the input string is <code>--help</code> or <code>-h</code>.
If it is, returns the usage message.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;, return_dict=False)
[('as-many-as-you-like', 'a'), ('as-many-as-you-like', 'b')]
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;-h&quot;)
**```usage```** :&amp;ensp;&lt;code&gt;a&lt;/code&gt;
:   &amp;nbsp;


&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;--help&quot;)
**```usage```** :&amp;ensp;&lt;code&gt;a&lt;/code&gt;
:   &amp;nbsp;


</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_args(
    self: &#34;Parser[Sequence[KeyValue]]&#34;,
    *args: str,
    return_dict: bool = True,
    check_help: bool = True,
) -&gt; typing.Sequence[KeyValueTuple] | Dict[str, Any]:
    &#34;&#34;&#34;
    The main way the user extracts parsed results from the parser.

    Parameters
    ----------
    args : str
        A sequence of strings to parse (e.g. `sys.argv[1:]`).
    return_dict : bool
        Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
        The tuples are `KeyValueTuple` namedtuples, with fields `key` and `value`.
    check_help : bool
        Before running the parser, checks if the input string is `--help` or `-h`.
        If it is, returns the usage message.

    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
    usage: a
    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
    usage: a
    &#34;&#34;&#34;
    if check_help:
        return wrap_help(self).parse_args(
            *args, return_dict=return_dict, check_help=False
        )
    result = self.parse(Sequence(list(args))).get
    if isinstance(result, ArgumentError):
        if self.usage and not isinstance(result, HelpError):
            print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in self.usage else &#34; &#34;)
            if &#34;\n&#34; in self.usage:
                usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in self.usage.split(&#34;\n&#34;)])
            else:
                usage = self.usage
            print(usage)
        if self.helps:
            for k, v in self.helps.items():
                print(f&#34;{k}: {v}&#34;)
        if result.usage:
            if isinstance(result, HelpError):
                print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in result.usage else &#34; &#34;)
            print(result.usage)
        if TESTING:
            return  # type: ignore[return-value]
        else:
            exit()

    nel: NonemptyList[Parse[Sequence[KeyValue]]] = result
    parse: Parse[Sequence[KeyValue]] = nel.head
    kvs: Sequence[KeyValue] = parse.parsed
    if return_dict:
        return {kv.key: kv.value for kv in kvs}
    return [KeyValueTuple(**asdict(kv)) for kv in kvs]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dollar_lambda" href="index.html">dollar_lambda</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="dollar_lambda.parser.apply" href="#dollar_lambda.parser.apply">apply</a></code></li>
<li><code><a title="dollar_lambda.parser.apply_item" href="#dollar_lambda.parser.apply_item">apply_item</a></code></li>
<li><code><a title="dollar_lambda.parser.argument" href="#dollar_lambda.parser.argument">argument</a></code></li>
<li><code><a title="dollar_lambda.parser.binary_usage" href="#dollar_lambda.parser.binary_usage">binary_usage</a></code></li>
<li><code><a title="dollar_lambda.parser.defaults" href="#dollar_lambda.parser.defaults">defaults</a></code></li>
<li><code><a title="dollar_lambda.parser.done" href="#dollar_lambda.parser.done">done</a></code></li>
<li><code><a title="dollar_lambda.parser.empty" href="#dollar_lambda.parser.empty">empty</a></code></li>
<li><code><a title="dollar_lambda.parser.equals" href="#dollar_lambda.parser.equals">equals</a></code></li>
<li><code><a title="dollar_lambda.parser.flag" href="#dollar_lambda.parser.flag">flag</a></code></li>
<li><code><a title="dollar_lambda.parser.help_parser" href="#dollar_lambda.parser.help_parser">help_parser</a></code></li>
<li><code><a title="dollar_lambda.parser.item" href="#dollar_lambda.parser.item">item</a></code></li>
<li><code><a title="dollar_lambda.parser.nonpositional" href="#dollar_lambda.parser.nonpositional">nonpositional</a></code></li>
<li><code><a title="dollar_lambda.parser.option" href="#dollar_lambda.parser.option">option</a></code></li>
<li><code><a title="dollar_lambda.parser.peak" href="#dollar_lambda.parser.peak">peak</a></code></li>
<li><code><a title="dollar_lambda.parser.sat" href="#dollar_lambda.parser.sat">sat</a></code></li>
<li><code><a title="dollar_lambda.parser.sat_item" href="#dollar_lambda.parser.sat_item">sat_item</a></code></li>
<li><code><a title="dollar_lambda.parser.sat_peak" href="#dollar_lambda.parser.sat_peak">sat_peak</a></code></li>
<li><code><a title="dollar_lambda.parser.type_" href="#dollar_lambda.parser.type_">type_</a></code></li>
<li><code><a title="dollar_lambda.parser.wrap_help" href="#dollar_lambda.parser.wrap_help">wrap_help</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dollar_lambda.parser.Parser" href="#dollar_lambda.parser.Parser">Parser</a></code></h4>
<ul class="two-column">
<li><code><a title="dollar_lambda.parser.Parser.__add__" href="#dollar_lambda.parser.Parser.__add__">__add__</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.__or__" href="#dollar_lambda.parser.Parser.__or__">__or__</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.__rshift__" href="#dollar_lambda.parser.Parser.__rshift__">__rshift__</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.bind" href="#dollar_lambda.parser.Parser.bind">bind</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.f" href="#dollar_lambda.parser.Parser.f">f</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.helps" href="#dollar_lambda.parser.Parser.helps">helps</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.many" href="#dollar_lambda.parser.Parser.many">many</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.many1" href="#dollar_lambda.parser.Parser.many1">many1</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.parse" href="#dollar_lambda.parser.Parser.parse">parse</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.parse_args" href="#dollar_lambda.parser.Parser.parse_args">parse_args</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.return_" href="#dollar_lambda.parser.Parser.return_">return_</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.usage" href="#dollar_lambda.parser.Parser.usage">usage</a></code></li>
<li><code><a title="dollar_lambda.parser.Parser.zero" href="#dollar_lambda.parser.Parser.zero">zero</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
