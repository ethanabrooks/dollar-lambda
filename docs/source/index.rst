.. $λ documentation master file, created by
   sphinx-quickstart on Mon Apr  4 12:45:01 2022.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Welcome to $λ's documentation!
==============================

This package provides an alternative to
`argparse <https://docs.python.org/3/library/argparse.html>`_ based
on parser combinators and functional first principles. Arguably, ``$λ``
is way more expressive than any reasonable person would ever need... but
even if it's not the parser that we need, it's the parser we deserve.

Installation
============

.. code-block:: console

  pip install dollar-lambda

Highlights
==========

``$λ`` comes with syntactic sugar that came make building parsers
completely boilerplate-free. For complex parsing situations that exceed
the expressive capacity of this syntax, the user can also drop down to
the lower-level syntax that lies behind the sugar, which can handle any
reasonable amount of logical complexity.

The :py:func:`@command<dollar_lambda.command>` decorator
---------------------------------------------------------

For the vast majority of parsing patterns, :py:class:`@command<dollar_lambda.command>` is the most
concise way to define a parser:

>>> from dollar_lambda import command, parser
>>> @command()
... def main(x: int, dev: bool = False, prod: bool = False):
...     print(dict(x=x, dev=dev, prod=prod))

Here is the help text generated by this parser:

>>> main("-h")
usage: -x X --dev --prod

And here it is in action:

>>> main("-x", "1", "-dev")
{'x': 1, 'dev': True, 'prod': False}

Ordinarily you would provide ``main`` no arguments and it would get them
from the command line.

>>> import sys
>>> sys.argv[1:] = ["-x", "1", "-dev"] # simulate command line input
>>> parser.TESTING = False # This is unnecessary outside of doctests
>>> main()
{'x': 1, 'dev': True, 'prod': False}

In this document we'll feed the strings directly for the sake of
brevity.

>>> parser.TESTING = True

Use the ``parsers`` argument to add custom logic to this parser:

>>> from dollar_lambda import flag
>>> @command(parsers=dict(kwargs=(flag("dev") | flag("prod"))))
... def main(x: int, **kwargs):
...     print(dict(x=x, **kwargs))

This parser requires either a ``--dev`` or ``--prod`` flag and maps it
to the ``kwargs`` argument:

>>> main("-h")
usage: -x X [--dev | --prod]
>>> main("-x", "1", "-dev")
{'x': 1, 'dev': True}
>>> main("-x", "1", "-prod")
{'x': 1, 'prod': True}
>>> main("-x", "1")
usage: -x X [--dev | --prod]
The following arguments are required: --dev

.. _CommandTree for:

:py:class:`CommandTree<dollar_lambda.CommandTree>` for dynamic dispatch
-----------------------------------------------------------------------

For many programs, a user will want to use one entrypoint for one set of
arguments, and another for another set of arguments. Returning to our
example, let's say we wanted to execute ``prod_function`` when the user
provides the ``--prod`` flag, and ``dev_function`` when the user
provides the ``--dev`` flag:

>>> from dollar_lambda import CommandTree
>>> tree = CommandTree()
>>> @tree.command()
... def base_function(x: int):
...     print("Ran base_function with arguments:", dict(x=x))
...
>>> @base_function.command()
... def prod_function(x: int, prod: bool):
...     print("Ran prod_function with arguments:", dict(x=x, prod=prod))
...
>>> @base_function.command()
... def dev_function(x: int, dev: bool):
...     print("Ran dev_function with arguments:", dict(x=x, dev=dev))

Let's see how this parser handles different inputs. If we provide the
``--prod`` flag, ``$λ`` automatically invokes ``prod_function`` with the
parsed arguments:

>>> tree("-x", "1", "-prod")
Ran prod_function with arguments: {'x': 1, 'prod': True}

If we provide the ``--dev`` flag, ``$λ`` invokes ``dev_function``:

>>> tree("-x", "1", "-dev")
Ran dev_function with arguments: {'x': 1, 'dev': True}

With this configuration, the parser will run ``base_function`` if
neither ``--prod`` nor ``--dev`` are given:

>>> tree("-x", "1")
Ran base_function with arguments: {'x': 1}

As with ``main`` in the previous example, you would ordinarily provide
``tree`` no arguments and it would get them from the command line.

There are many other ways to use :py:class:`CommandTree<dollar_lambda.CommandTree>`,
including some that make use of the ``base_function``. To learn more, we recommend the
:doc:`command_tree`.

Lower-level syntax
------------------

:py:meth:`@command<dollar_lambda.command>` and :py:class:`CommandTree<dollar_lambda.CommandTree>`
cover many use cases, but they are both syntactic sugar for a lower-level interface
that is far more expressive.

Suppose you want to implement a parser that first tries to parse an
option (a flag that takes an argument), ``-x X`` and if that fails,
tries to parse the input as a variadic sequence of floats:

>>> from dollar_lambda import option, argument
>>> p = option("x", type=int) | argument("y", type=float).many()

We go over this syntax in greater detail in the
`tutorial <#tutorial>`__. For now, suffice to say that :py:func:`argument<dollar_lambda.argument>`.
defines a positional argument, :py:meth:`many<dollar_lambda.Parser.many>`.
allows parsers to be applied zero or more times, and
:py:meth:`|<dollar_lambda.Parser.__or__>` expresses alternatives.

Here is the help text:

>>> p.parse_args("-h")
usage: [-x X | [Y ...]]

As promised, this succeeds:

>>> p.parse_args("-x", "1")
{'x': 1}

And this succeeds:

>>> p.parse_args("1", "2", "3")
{'y': [1.0, 2.0, 3.0]}

Again, you would ordinarily provide :py:meth:`parse_args<dollar_lambda.Parser.parse_args>`
no arguments and it would get them from the command line:

>>> sys.argv[1:] = ["-x", "1"] # simulate command line input
>>> parser.TESTING = False # unnecessary outside of doctests
>>> p.parse_args()
{'x': 1}
>>> parser.TESTING = True

.. toctree::
   :hidden:

   tutorial
   variations
   command_tree
   config
   nesting
   ignoring
   why
   api
