<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dollar_lambda API documentation</title>
<meta name="description" content="This package provides an alternative to [`argparse`](https://docs.python.org/3/library/argparse.html) based on functional first principles.
This means â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>dollar_lambda</code></h1>
</header>
<section id="section-intro">
<p>This package provides an alternative to <a href="https://docs.python.org/3/library/argparse.html"><code>argparse</code></a> based on functional first principles.
This means that this package can handle many kinds of argument-parsing patterns that are either very awkward, difficult, or impossible with <code>argparse</code>.</p>
<h1 id="tutorial">Tutorial</h1>
<p>Here is an example developed in the <code>argparse</code> tutorial:</p>
<pre><code>import argparse
parser = argparse.ArgumentParser(description=&quot;calculate X to the power of Y&quot;)
group = parser.add_mutually_exclusive_group(required=True)
group.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;)
group.add_argument(&quot;-q&quot;, &quot;--quiet&quot;, action=&quot;store_true&quot;)
parser.add_argument(&quot;x&quot;, type=int, help=&quot;the base&quot;)
parser.add_argument(&quot;y&quot;, type=int, help=&quot;the exponent&quot;)
args = parser.parse_args()
</code></pre>
<p>Here is the equivalent in this package:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
</code></pre>
<p>It succeeds for either <code>--verbose</code> or <code>--quiet</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(**p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;))
{'x': 1, 'y': 2, 'verbose': True, 'quiet': False}
&gt;&gt;&gt; main(**p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;))
{'x': 1, 'y': 2, 'verbose': False, 'quiet': True}
</code></pre>
<p>But fails for both:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--quiet&quot;)
usage: [--verbose | --quiet] -x X -y Y
x: the base
y: the exponent
Unrecognized argument: --quiet
</code></pre>
<p>And fails for neither:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)
usage: [--verbose | --quiet] -x X -y Y
x: the base
y: the exponent
Expected '--verbose'. Got '-x'
</code></pre>
<p>Let's walk through this step by step. First, let's learn what <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code>, <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> and <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> do.</p>
<h2 id="high-level-parsers">High-Level Parsers</h2>
<p>These three functions create high-level parsers. <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> binds a boolean value to a variable
whereas <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> binds an arbitrary value to a variable. <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> does not bind any values to variables,
but causes the parser to fail in some cases.</p>
<h3 id="flag"><code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code></h3>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<p>By default <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> fails when it does not receive expected input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose
</code></pre>
<p>Alternately, you can set a default value:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;, default=False).parse_args()
{'verbose': False}
</code></pre>
<h3 id="option"><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code></h3>
<p><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> is similar but takes an argument:
By default, <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> expects a single <code>-</code> for single-character variable names (as in <code>-x</code>),
as opposed to <code>--</code> for longer names (as in <code>--xenophon</code>):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;).parse_args(&quot;-x&quot;, &quot;1&quot;)
{'x': '1'}
&gt;&gt;&gt; option(&quot;xenophon&quot;).parse_args(&quot;--xenophon&quot;, &quot;1&quot;)
{'xenophon': '1'}
</code></pre>
<p>Use the <code>type</code> argument to convert the input to a different type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;, type=int).parse_args(&quot;-x&quot;, &quot;1&quot;)  # converts &quot;1&quot; to an int
{'x': 1}
</code></pre>
<h3 id="done"><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code></h3>
<p>Without <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> the parser will not complain about leftover (unparsed) input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True}
</code></pre>
<p><code>--quiet</code> is not parsed here but this does not cause the parser to fail.
If we want to prevent leftover inputs, we can use <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) &gt;&gt; done()).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
usage: --verbose
Unrecognized argument: --quiet
</code></pre>
<p><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> is usually necessary to get <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> to behave in the way that you expect,
but more on that later.</p>
<h2 id="parser-combinators">Parser Combinators</h2>
<p>Parser combinators are functions that combine multiple parsers into new, more complex parsers.
Our example uses three such functions: <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>, <code>|</code> or <code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>,
and <code>&gt;&gt;</code> or <code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code>.</p>
<h3 id="parser__or__"><code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code></h3>
<p>The <code>|</code> operator is used for alternatives. Specifically, it will try the first parser,
and if that fails, try the second:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;) # flag(&quot;verbose&quot;) fails
{'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;) # flag(&quot;verbose&quot;) succeeds
{'verbose': True}
</code></pre>
<p>By default one of the two flags would be required to prevent failure:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args() # neither flag is provided so this fails
usage: [--verbose | --quiet]
The following arguments are required: --verbose
</code></pre>
<p>To permit the omission of both flags, use <code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty()</a></code> or supply a default value:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;) | empty()).parse_args() # flags fail, but empty() succeeds
{}
&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;, default=False)).parse_args() # flag(&quot;verbose&quot;) fails but flag(&quot;quiet&quot;, default=False) succeeds
{'quiet': False}
</code></pre>
<p>This is just sugar for</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;) | defaults(quiet=False)).parse_args() # flag(&quot;verbose&quot;) fails but flag(&quot;quiet&quot;, default=False) succeeds
{'quiet': False}
</code></pre>
<h3 id="parser__rshift__"><code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code></h3>
<p>The <code>&gt;&gt;</code> operator is used for sequential composition. It applies the first parser and then
hands the output of the first parser to the second parser. If either parser fails, the composition fails:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--something-else&quot;)  # first parser will fail
usage: --verbose
Expected '--verbose'. Got '--something-else'
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--something-else&quot;)  # second parser will fail
usage: --verbose
Unrecognized argument: --something-else
</code></pre>
<h3 id="nonpositional"><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code></h3>
<p>This function takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<p>For just two parsers you can use <code>+</code>, or <code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code>, instead of <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<p>This will not cover all permutations for more than two parsers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;) + option(&quot;x&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;--quiet&quot;)
usage: --verbose --quiet -x X
Expected '--quiet'. Got '-x'
</code></pre>
<p>To see why note the implicit parentheses:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;)) + option(&quot;x&quot;)
</code></pre>
<p>In order to cover the case where <code>-x</code> comes between <code>--verbose</code> and <code>--quiet</code>,
use <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;), option(&quot;x&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;--quiet&quot;)  # works
{'verbose': True, 'x': '1', 'quiet': True}
</code></pre>
<p>If alternatives or defaults appear among the arguments to <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>, you will probably want
to add <code>&gt;&gt;</code> followed by <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> (or another parser) after <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>. Otherwise,
the parser will not behave as expected:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # you expect this to bind &lt;code&gt;True&lt;/code&gt; to &lt;code&gt;verbose&lt;/code&gt;, but it doesn't
{'verbose': False, 'quiet': True}
</code></pre>
<p>Why is happening? There are two permutions:</p>
<ul>
<li><code>flag("verbose", default=False) &gt;&gt; flag("quiet")</code> and</li>
<li><code>flag("quiet") &gt;&gt; flag("verbose", default=False)</code> </li>
</ul>
<p>In our example, both permutations are actually succeeding. This first succeeds by falling
back to the default, and leaving the last word of the input, <code>--verbose</code>, unparsed.
Either interpretation is valid, and <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> returns one arbitrarily &ndash; just not the one we expected.</p>
<p>Now let's add <code>&gt;&gt; done()</code> to the end:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;quiet&quot;)) &gt;&gt; done()
</code></pre>
<p>This ensures that the first permutation will fail because the leftover <code>--verbose</code> input will
cause the <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> parser to fail:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)
{'quiet': True, 'verbose': True}
</code></pre>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>Let's recall the original example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
</code></pre>
<p>As we've seen <code>flag("verbose") | flag("quiet")</code> succeeds on either <code>--verbose</code> or <code>--quiet</code>
(but one or the other is required).</p>
<p><code>option("x", type=int)</code> succeeds on <code>-x X</code>, where <code>X</code> is
some integer, binding that integer to the variable <code>"x"</code>. Similarly for <code>option("y", type=int)</code>.</p>
<p><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> takes the three parsers:</p>
<ul>
<li><code>flag("verbose") | flag("quiet")</code></li>
<li><code>option("x", type=int)</code></li>
<li><code>option("y", type=int)</code></li>
</ul>
<p>and applies them in every order, until some order succeeds.
Finally <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> ensures that only one of these parser permutations will succeed, preventing ambiguity.</p>
<h2 id="alternative-syntax">Alternative syntax</h2>
<h3 id="args"><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code></h3>
<p>There are two alternative ways to express the same functionality. First, if there were many more
arguments to <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>, we might want to use <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code>, which is sugar for <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>
and slightly less expressive:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dataclasses import dataclass
&gt;&gt;&gt; @dataclass  # make sure not to forget this!
... class MyArgs(Args):
...    x: int = field(help=&quot;the base&quot;)
...    y: int = field(help=&quot;the exponent&quot;)
</code></pre>
<p>Make sure to import <code><a title="dollar_lambda.field" href="#dollar_lambda.field">field()</a></code> from <code><a title="dollar_lambda" href="#dollar_lambda">dollar_lambda</a></code>, not from <code>dataclasses</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p = MyArgs.parser() + p1 &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True}
</code></pre>
<h3 id="defaults"><code><a title="dollar_lambda.defaults" href="#dollar_lambda.defaults">defaults()</a></code></h3>
<p>In our examples, default values are defined in a separate <code>main</code> function. Some users will
prefer defining defaults in the parser definition, as in most parsing libraries.
In many cases, one can do this using <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass  # make sure not to forget this!
... class MyArgs(Args):
...    x: int = field(help=&quot;the base&quot;, default=1)
...    y: int = field(help=&quot;the exponent&quot;, default=2)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args()
{'x': 1, 'y': 2}
</code></pre>
<p>But since the logic of our original example is a bit more complicated, we will need to use the <code><a title="dollar_lambda.defaults" href="#dollar_lambda.defaults">defaults()</a></code>
parser instead. Here is how:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (
...         flag(&quot;verbose&quot;) + defaults(quiet=False)  # either --verbose and default &quot;quiet&quot; to False
...         | flag(&quot;quiet&quot;) + defaults(verbose=False)  # or --quiet and default &quot;verbose&quot; to False
...     ),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... ) &gt;&gt; done()
</code></pre>
<p>Now we don't need a separate function to provide default values:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'quiet': False}
</code></pre>
<h2 id="variations-on-the-example">Variations on the example</h2>
<h3 id="something-argparse-cant-do">Something <code>argparse</code> can't do</h3>
<p>What if there was a special argument, <code>verbosity</code>,
that only makes sense if the user chooses <code>--verbose</code>?</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&quot;verbose&quot;) + option(&quot;verbosity&quot;, type=int)) | flag(&quot;quiet&quot;)),
...         option(&quot;x&quot;, type=int),
...         option(&quot;y&quot;, type=int),
...     )
...     &gt;&gt; done()
... )
</code></pre>
<p>Remember that <code>+</code> or <code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code> evaluates two parsers in both orders
and stopping at the first order that succeeds. So this allows us to
supply <code>--verbose</code> and <code>--verbosity</code> in any order.</p>
<p>Now:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;)
{'x': 1, 'y': 2, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbosity&quot;, &quot;3&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
usage: [--verbose --verbosity VERBOSITY | --quiet] -x X -y Y
Expected '--verbose'. Got '-x'
</code></pre>
<h3 id="parsermany"><code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code></h3>
<p>What if we want to specify verbosity by the number of times that <code>--verbose</code> appears?
For this we need <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code>. Before showing how we could use <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> in this setting,
let's look at how it works.</p>
<p><code>parser.many</code> takes <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> and tries to apply it as many times as possible.
<code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> is a bit like the <code>*</code> pattern, if you are familiar with regexes.
<code>parser.many</code> always succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p.parse_args(&quot;blah&quot;)  # still succeeds
{}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;blah&quot;)  # still succeeds
{'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--verbose&quot;, return_dict=False)
[('verbose', True), ('verbose', True)]
</code></pre>
<p>As you can see, <code>return_dict=False</code> returns a list of tuples instead of a dict, so that you
can have duplicate keys.</p>
<p>Now returning to the original example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (
...     nonpositional(
...         flag(&quot;verbose&quot;).many(),
...         option(&quot;x&quot;, type=int),
...         option(&quot;y&quot;, type=int),
...     )
...     &gt;&gt; done()
... )
&gt;&gt;&gt; args = p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbose&quot;, return_dict=False)
&gt;&gt;&gt; args
[('x', 1), ('y', 2), ('verbose', True), ('verbose', True)]
&gt;&gt;&gt; verbosity = args.count(('verbose', True))
&gt;&gt;&gt; verbosity
2
</code></pre>
<h3 id="parsermany1"><code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">Parser.many1()</a></code></h3>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&quot;verbose&quot;).many1()) | flag(&quot;quiet&quot;)),
...         option(&quot;x&quot;, type=int),
...         option(&quot;y&quot;, type=int),
...     )
...     &gt;&gt; done()
... )
</code></pre>
<p>You can also customize the order of the arguments:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (
...     (
...         flag(&quot;verbose&quot;) + defaults(quiet=False)
...         | flag(&quot;quiet&quot;) + defaults(verbose=False)
...     )
...     &gt;&gt; option(&quot;x&quot;, type=int)  # note &gt;&gt; on this line
...     &gt;&gt; option(&quot;y&quot;, type=int)  # and this line
...     &gt;&gt; done()
... )
</code></pre>
<p>Now <code>--quiet</code> and <code>--verbose</code> must appear before <code>-x</code>, and <code>-x</code> must appear before <code>-y</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)
{'verbose': True, 'quiet': False, 'x': 1, 'y': 2}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;--verbose&quot;, &quot;-y&quot;, &quot;2&quot;)
usage: [--verbose | --quiet] -x X -y Y
Expected '--verbose'. Got '-x'
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;-x&quot;, &quot;1&quot;)
usage: [--verbose | --quiet] -x X -y Y
Expected '-x'. Got '-y'
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This package provides an alternative to [`argparse`](https://docs.python.org/3/library/argparse.html) based on functional first principles.
This means that this package can handle many kinds of argument-parsing patterns that are either very awkward, difficult, or impossible with `argparse`.

# Tutorial
Here is an example developed in the `argparse` tutorial:

```
import argparse
parser = argparse.ArgumentParser(description=&#34;calculate X to the power of Y&#34;)
group = parser.add_mutually_exclusive_group(required=True)
group.add_argument(&#34;-v&#34;, &#34;--verbose&#34;, action=&#34;store_true&#34;)
group.add_argument(&#34;-q&#34;, &#34;--quiet&#34;, action=&#34;store_true&#34;)
parser.add_argument(&#34;x&#34;, type=int, help=&#34;the base&#34;)
parser.add_argument(&#34;y&#34;, type=int, help=&#34;the exponent&#34;)
args = parser.parse_args()
```

Here is the equivalent in this package:

&gt;&gt;&gt; p = nonpositional(
...     (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)),
...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)

It succeeds for either `--verbose` or `--quiet`:
&gt;&gt;&gt; main(**p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;))
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}
&gt;&gt;&gt; main(**p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;))
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: False, &#39;quiet&#39;: True}

But fails for both:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--quiet&#34;)
usage: [--verbose | --quiet] -x X -y Y
x: the base
y: the exponent
Unrecognized argument: --quiet

And fails for neither:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)
usage: [--verbose | --quiet] -x X -y Y
x: the base
y: the exponent
Expected &#39;--verbose&#39;. Got &#39;-x&#39;

Let&#39;s walk through this step by step. First, let&#39;s learn what `flag`, `option` and `done` do.

## High-Level Parsers
These three functions create high-level parsers. `flag` binds a boolean value to a variable
whereas `option` binds an arbitrary value to a variable. `done` does not bind any values to variables,
but causes the parser to fail in some cases.

### `flag`
&gt;&gt;&gt; p = flag(&#34;verbose&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
{&#39;verbose&#39;: True}

By default `flag` fails when it does not receive expected input:
&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose

Alternately, you can set a default value:
&gt;&gt;&gt; flag(&#34;verbose&#34;, default=False).parse_args()
{&#39;verbose&#39;: False}

### `option`
`option` is similar but takes an argument:
By default, `option` expects a single `-` for single-character variable names (as in `-x`),
as opposed to `--` for longer names (as in `--xenophon`):

&gt;&gt;&gt; option(&#34;x&#34;).parse_args(&#34;-x&#34;, &#34;1&#34;)
{&#39;x&#39;: &#39;1&#39;}
&gt;&gt;&gt; option(&#34;xenophon&#34;).parse_args(&#34;--xenophon&#34;, &#34;1&#34;)
{&#39;xenophon&#39;: &#39;1&#39;}

Use the `type` argument to convert the input to a different type:
&gt;&gt;&gt; option(&#34;x&#34;, type=int).parse_args(&#34;-x&#34;, &#34;1&#34;)  # converts &#34;1&#34; to an int
{&#39;x&#39;: 1}

### `done`
Without `done` the parser will not complain about leftover (unparsed) input:

&gt;&gt;&gt; flag(&#34;verbose&#34;).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True}

`--quiet` is not parsed here but this does not cause the parser to fail.
If we want to prevent leftover inputs, we can use `done`:

&gt;&gt;&gt; (flag(&#34;verbose&#34;) &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
usage: --verbose
Unrecognized argument: --quiet

`done` is usually necessary to get `nonpositional` to behave in the way that you expect,
but more on that later.

## Parser Combinators
Parser combinators are functions that combine multiple parsers into new, more complex parsers.
Our example uses three such functions: `nonpositional`, `|` or `Parser.__or__`,
and `&gt;&gt;` or `Parser.__rshift__`.

### `Parser.__or__`

The `|` operator is used for alternatives. Specifically, it will try the first parser,
and if that fails, try the second:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;) # flag(&#34;verbose&#34;) fails
{&#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;) # flag(&#34;verbose&#34;) succeeds
{&#39;verbose&#39;: True}

By default one of the two flags would be required to prevent failure:
&gt;&gt;&gt; p.parse_args() # neither flag is provided so this fails
usage: [--verbose | --quiet]
The following arguments are required: --verbose

To permit the omission of both flags, use `empty` or supply a default value:

&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | empty()).parse_args() # flags fail, but empty() succeeds
{}
&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;, default=False)).parse_args() # flag(&#34;verbose&#34;) fails but flag(&#34;quiet&#34;, default=False) succeeds
{&#39;quiet&#39;: False}

This is just sugar for

&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | defaults(quiet=False)).parse_args() # flag(&#34;verbose&#34;) fails but flag(&#34;quiet&#34;, default=False) succeeds
{&#39;quiet&#39;: False}

### `Parser.__rshift__`

The `&gt;&gt;` operator is used for sequential composition. It applies the first parser and then
hands the output of the first parser to the second parser. If either parser fails, the composition fails:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
{&#39;verbose&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--something-else&#34;)  # first parser will fail
usage: --verbose
Expected &#39;--verbose&#39;. Got &#39;--something-else&#39;
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--something-else&#34;)  # second parser will fail
usage: --verbose
Unrecognized argument: --something-else

### `nonpositional`
This function takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:

&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

For just two parsers you can use `+`, or `Parser.__add__`, instead of `nonpositional`:
&gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

This will not cover all permutations for more than two parsers:
&gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;) + option(&#34;x&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;--quiet&#34;)
usage: --verbose --quiet -x X
Expected &#39;--quiet&#39;. Got &#39;-x&#39;

To see why note the implicit parentheses:
&gt;&gt;&gt; p = (flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;)) + option(&#34;x&#34;)

In order to cover the case where `-x` comes between `--verbose` and `--quiet`,
use `nonpositional`:
&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;), option(&#34;x&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;--quiet&#34;)  # works
{&#39;verbose&#39;: True, &#39;x&#39;: &#39;1&#39;, &#39;quiet&#39;: True}

If alternatives or defaults appear among the arguments to `nonpositional`, you will probably want
to add `&gt;&gt;` followed by `done` (or another parser) after `nonpositional`. Otherwise,
the parser will not behave as expected:

&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;quiet&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # you expect this to bind `True` to `verbose`, but it doesn&#39;t
{&#39;verbose&#39;: False, &#39;quiet&#39;: True}

Why is happening? There are two permutions:

- `flag(&#34;verbose&#34;, default=False) &gt;&gt; flag(&#34;quiet&#34;)` and
- `flag(&#34;quiet&#34;) &gt;&gt; flag(&#34;verbose&#34;, default=False)`

In our example, both permutations are actually succeeding. This first succeeds by falling
back to the default, and leaving the last word of the input, `--verbose`, unparsed.
Either interpretation is valid, and `nonpositional` returns one arbitrarily -- just not the one we expected.

Now let&#39;s add `&gt;&gt; done()` to the end:
&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;quiet&#34;)) &gt;&gt; done()

This ensures that the first permutation will fail because the leftover `--verbose` input will
cause the `done` parser to fail:
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

## Putting it all together
Let&#39;s recall the original example:

&gt;&gt;&gt; p = nonpositional(
...     (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)),
...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)

As we&#39;ve seen `flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)` succeeds on either `--verbose` or `--quiet`
(but one or the other is required).

`option(&#34;x&#34;, type=int)` succeeds on `-x X`, where `X` is
some integer, binding that integer to the variable `&#34;x&#34;`. Similarly for `option(&#34;y&#34;, type=int)`.

`nonpositional` takes the three parsers:

- `flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)`
- `option(&#34;x&#34;, type=int)`
- `option(&#34;y&#34;, type=int)`

and applies them in every order, until some order succeeds.
Finally `done()` ensures that only one of these parser permutations will succeed, preventing ambiguity.

## Alternative syntax

### `Args`

There are two alternative ways to express the same functionality. First, if there were many more
arguments to `nonpositional`, we might want to use `Args`, which is sugar for `nonpositional`
and slightly less expressive:

&gt;&gt;&gt; from dataclasses import dataclass
&gt;&gt;&gt; @dataclass  # make sure not to forget this!
... class MyArgs(Args):
...    x: int = field(help=&#34;the base&#34;)
...    y: int = field(help=&#34;the exponent&#34;)

Make sure to import `field` from `dollar_lambda`, not from `dataclasses`.

&gt;&gt;&gt; p1 = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
&gt;&gt;&gt; p = MyArgs.parser() + p1 &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True}

### `defaults`

In our examples, default values are defined in a separate `main` function. Some users will
prefer defining defaults in the parser definition, as in most parsing libraries.
In many cases, one can do this using `Args`:

&gt;&gt;&gt; @dataclass  # make sure not to forget this!
... class MyArgs(Args):
...    x: int = field(help=&#34;the base&#34;, default=1)
...    y: int = field(help=&#34;the exponent&#34;, default=2)

&gt;&gt;&gt; MyArgs.parse_args()
{&#39;x&#39;: 1, &#39;y&#39;: 2}

But since the logic of our original example is a bit more complicated, we will need to use the `defaults`
parser instead. Here is how:

&gt;&gt;&gt; p = nonpositional(
...     (
...         flag(&#34;verbose&#34;) + defaults(quiet=False)  # either --verbose and default &#34;quiet&#34; to False
...         | flag(&#34;quiet&#34;) + defaults(verbose=False)  # or --quiet and default &#34;verbose&#34; to False
...     ),
...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
... ) &gt;&gt; done()

Now we don&#39;t need a separate function to provide default values:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}

## Variations on the example
### Something `argparse` can&#39;t do

What if there was a special argument, `verbosity`,
that only makes sense if the user chooses `--verbose`?

&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&#34;verbose&#34;) + option(&#34;verbosity&#34;, type=int)) | flag(&#34;quiet&#34;)),
...         option(&#34;x&#34;, type=int),
...         option(&#34;y&#34;, type=int),
...     )
...     &gt;&gt; done()
... )

Remember that `+` or `Parser.__add__` evaluates two parsers in both orders
and stopping at the first order that succeeds. So this allows us to
supply `--verbose` and `--verbosity` in any order.

Now:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbosity&#34;, &#34;3&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;verbosity&#39;: 3}
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
usage: [--verbose --verbosity VERBOSITY | --quiet] -x X -y Y
Expected &#39;--verbose&#39;. Got &#39;-x&#39;

### `Parser.many`

What if we want to specify verbosity by the number of times that `--verbose` appears?
For this we need `Parser.many`. Before showing how we could use `Parser.many` in this setting,
let&#39;s look at how it works.

`parser.many` takes `parser` and tries to apply it as many times as possible.
`Parser.many` is a bit like the `*` pattern, if you are familiar with regexes.
`parser.many` always succeeds:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p.parse_args(&#34;blah&#34;)  # still succeeds
{}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;blah&#34;)  # still succeeds
{&#39;verbose&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--verbose&#34;, return_dict=False)
[(&#39;verbose&#39;, True), (&#39;verbose&#39;, True)]

As you can see, `return_dict=False` returns a list of tuples instead of a dict, so that you
can have duplicate keys.

Now returning to the original example:

&gt;&gt;&gt; p = (
...     nonpositional(
...         flag(&#34;verbose&#34;).many(),
...         option(&#34;x&#34;, type=int),
...         option(&#34;y&#34;, type=int),
...     )
...     &gt;&gt; done()
... )
&gt;&gt;&gt; args = p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbose&#34;, return_dict=False)
&gt;&gt;&gt; args
[(&#39;x&#39;, 1), (&#39;y&#39;, 2), (&#39;verbose&#39;, True), (&#39;verbose&#39;, True)]
&gt;&gt;&gt; verbosity = args.count((&#39;verbose&#39;, True))
&gt;&gt;&gt; verbosity
2

### `Parser.many1`



&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&#34;verbose&#34;).many1()) | flag(&#34;quiet&#34;)),
...         option(&#34;x&#34;, type=int),
...         option(&#34;y&#34;, type=int),
...     )
...     &gt;&gt; done()
... )

You can also customize the order of the arguments:
&gt;&gt;&gt; p = (
...     (
...         flag(&#34;verbose&#34;) + defaults(quiet=False)
...         | flag(&#34;quiet&#34;) + defaults(verbose=False)
...     )
...     &gt;&gt; option(&#34;x&#34;, type=int)  # note &gt;&gt; on this line
...     &gt;&gt; option(&#34;y&#34;, type=int)  # and this line
...     &gt;&gt; done()
... )

Now `--quiet` and `--verbose` must appear before `-x`, and `-x` must appear before `-y`:
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)
{&#39;verbose&#39;: True, &#39;quiet&#39;: False, &#39;x&#39;: 1, &#39;y&#39;: 2}
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;--verbose&#34;, &#34;-y&#34;, &#34;2&#34;)
usage: [--verbose | --quiet] -x X -y Y
Expected &#39;--verbose&#39;. Got &#39;-x&#39;
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;-x&#34;, &#34;1&#34;)
usage: [--verbose | --quiet] -x X -y Y
Expected &#39;-x&#39;. Got &#39;-y&#39;
&#34;&#34;&#34;


__pdoc__ = {}

from dollar_lambda.args import Args, field
from dollar_lambda.decorators import CommandTree, command
from dollar_lambda.parser import (
    Parser,
    apply,
    apply_item,
    argument,
    defaults,
    done,
    empty,
    equals,
    flag,
    item,
    nonpositional,
    option,
    sat,
    sat_item,
    type_,
    wrap_help,
)

__all__ = [
    &#34;Parser&#34;,
    &#34;empty&#34;,
    &#34;apply&#34;,
    &#34;apply_item&#34;,
    &#34;argument&#34;,
    &#34;done&#34;,
    &#34;equals&#34;,
    &#34;flag&#34;,
    &#34;item&#34;,
    &#34;nonpositional&#34;,
    &#34;option&#34;,
    &#34;sat&#34;,
    &#34;sat_item&#34;,
    &#34;type_&#34;,
    &#34;Args&#34;,
    &#34;defaults&#34;,
    &#34;field&#34;,
    &#34;wrap_help&#34;,
    &#34;command&#34;,
    &#34;CommandTree&#34;,
]


__pdoc__[&#34;Parser.__add__&#34;] = True
__pdoc__[&#34;Parser.__or__&#34;] = True
__pdoc__[&#34;Parser.__rshift__&#34;] = True
__pdoc__[&#34;Parser.__ge__&#34;] = True</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="dollar_lambda.args" href="args.html">dollar_lambda.args</a></code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> is sugar for the <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> function and removes much of the boilerplate
from defining parsers with many arguments.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.decorators" href="decorators.html">dollar_lambda.decorators</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.error" href="error.html">dollar_lambda.error</a></code></dt>
<dd>
<div class="desc"><p>Contains definitions for errors which can be raised by parsers.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.key_value" href="key_value.html">dollar_lambda.key_value</a></code></dt>
<dd>
<div class="desc"><p>Argument parsers generate a sequence of <code>KeyValue</code> pairs that store mappings from variable names to values.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code></dt>
<dd>
<div class="desc"><p>Contains the <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> class and functions for building more specialized builder functions.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.result" href="result.html">dollar_lambda.result</a></code></dt>
<dd>
<div class="desc"><p>Results represent either success or failure (an exception). This is how errors get bubbled up during the parsing process.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.sequence" href="sequence.html">dollar_lambda.sequence</a></code></dt>
<dd>
<div class="desc"><p>A <code>Sequence</code> is a strongly-typed immutable list that implements <code>MonadPlus</code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dollar_lambda.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>f:Â Callable[[Monoid1],Â Result[Monoid_co]], parser:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Monoid1]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+Monoid_co]</span>
</code></dt>
<dd>
<div class="desc"><p>Take the output of <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> and apply <code>f</code> to it. Convert any errors that arise into <code>ArgumentError</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(
    f: Callable[[Monoid1], Result[Monoid_co]], parser: Parser[Monoid1]
) -&gt; Parser[Monoid_co]:
    &#34;&#34;&#34;
    Take the output of `parser` and apply `f` to it. Convert any errors that arise into `ArgumentError`.
    &#34;&#34;&#34;

    def g(a: Monoid1) -&gt; Parser[Monoid_co]:
        try:
            y = f(a)
        except Exception as e:
            usage = f&#34;An argument {a}: raised exception {e}&#34;
            y = Result(ArgumentError(usage))
        return Parser(
            lambda unparsed: y
            &gt;= (lambda parsed: Result.return_(Parse(parsed, unparsed))),
            usage=parser.usage,
            helps=parser.helps,
        )

    p = parser &gt;= g
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.apply_item"><code class="name flex">
<span>def <span class="ident">apply_item</span></span>(<span>f:Â Callable[[str],Â Monoid_co], description:Â str) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+Monoid_co]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_item(f: Callable[[str], Monoid_co], description: str) -&gt; Parser[Monoid_co]:
    def g(parsed: Sequence[KeyValue[str]]) -&gt; Result[Monoid_co]:
        [kv] = parsed
        try:
            y = f(kv.value)
        except Exception as e:
            usage = f&#34;argument {kv.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        return Result.return_(y)

    return apply(g, item(description))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.argument"><code class="name flex">
<span>def <span class="ident">argument</span></span>(<span>dest:Â str) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;name&quot;).parse_args(&quot;Alice&quot;)
{'name': 'Alice'}
&gt;&gt;&gt; argument(&quot;name&quot;).parse_args()
usage: name
The following arguments are required: name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def argument(dest: str) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args()
    usage: name
    The following arguments are required: name
    &#34;&#34;&#34;
    return item(dest)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>flip_bools:Â boolÂ =Â True, help:Â Optional[Dict[str,Â str]]Â =Â None, types:Â Optional[Dict[str,Â Callable[[str],Â Any]]]Â =Â None) â€‘>Â Callable[[Callable],Â Callable]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(a=&quot;something about a&quot;), types=dict(a=lambda x: int(x) + 1))
... def f(a: int = 1, b: bool = False):
...     print(dict(a=a, b=b))
&gt;&gt;&gt; f(&quot;-a&quot;, &quot;2&quot;, &quot;-b&quot;)
{'a': 3, 'b': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable[[Callable], Callable]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; @command(help=dict(a=&#34;something about a&#34;), types=dict(a=lambda x: int(x) + 1))
    ... def f(a: int = 1, b: bool = False):
    ...     print(dict(a=a, b=b))
    &gt;&gt;&gt; f(&#34;-a&#34;, &#34;2&#34;, &#34;-b&#34;)
    {&#39;a&#39;: 3, &#39;b&#39;: True}
    &#34;&#34;&#34;

    def wrapper(func: Callable) -&gt; Callable:
        p = func_to_parser(func, flip_bools=flip_bools, help=help, types=types)

        def wrapped(*args) -&gt; Any:
            parsed = p.parse_args(*args)
            assert isinstance(parsed, Dict), parsed
            return func(**parsed)

        return wrapped

    return wrapper</code></pre>
</details>
</dd>
<dt id="dollar_lambda.defaults"><code class="name flex">
<span>def <span class="ident">defaults</span></span>(<span>**kwargs:Â Any) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defaults(**kwargs: Any) -&gt; Parser[Sequence[KeyValue[Any]]]:
    p = Parser.return_(Sequence([KeyValue(k, v) for k, v in kwargs.items()]))
    return replace(p, usage=None)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; done().parse_args()
{}
&gt;&gt;&gt; done().parse_args(&quot;arg&quot;)
Unrecognized argument: arg
&gt;&gt;&gt; (argument(&quot;arg&quot;) &gt;&gt; done()).parse_args(&quot;a&quot;)
{'arg': 'a'}
&gt;&gt;&gt; (argument(&quot;arg&quot;) &gt;&gt; done()).parse_args(&quot;a&quot;, &quot;b&quot;)
usage: arg
Unrecognized argument: b
&gt;&gt;&gt; (flag(&quot;arg&quot;).many() &gt;&gt; done()).parse_args(&quot;--arg&quot;, &quot;--arg&quot;, return_dict=False)
[('arg', True), ('arg', True)]
&gt;&gt;&gt; (flag(&quot;arg&quot;).many() &gt;&gt; done()).parse_args(&quot;--arg&quot;, &quot;--arg&quot;, &quot;x&quot;)
usage: [--arg ...]
Unrecognized argument: x
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done() -&gt; Parser[Sequence[A]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; done().parse_args()
    {}
    &gt;&gt;&gt; done().parse_args(&#34;arg&#34;)
    Unrecognized argument: arg
    &gt;&gt;&gt; (argument(&#34;arg&#34;) &gt;&gt; done()).parse_args(&#34;a&#34;)
    {&#39;arg&#39;: &#39;a&#39;}
    &gt;&gt;&gt; (argument(&#34;arg&#34;) &gt;&gt; done()).parse_args(&#34;a&#34;, &#34;b&#34;)
    usage: arg
    Unrecognized argument: b
    &gt;&gt;&gt; (flag(&#34;arg&#34;).many() &gt;&gt; done()).parse_args(&#34;--arg&#34;, &#34;--arg&#34;, return_dict=False)
    [(&#39;arg&#39;, True), (&#39;arg&#39;, True)]
    &gt;&gt;&gt; (flag(&#34;arg&#34;).many() &gt;&gt; done()).parse_args(&#34;--arg&#34;, &#34;--arg&#34;, &#34;x&#34;)
    usage: [--arg ...]
    Unrecognized argument: x
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[Sequence[A]]]:
        if cs:
            c, *_ = cs
            return Result(
                UnexpectedError(unexpected=c, usage=f&#34;Unrecognized argument: {c}&#34;)
            )
        return Result(NonemptyList(Parse(parsed=Sequence([]), unparsed=cs)))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Always returns {}, no matter the input. Mostly useful for use in <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; empty().parse_args(&quot;any&quot;, &quot;arguments&quot;)
{}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty() -&gt; Parser[Sequence]:
    &#34;&#34;&#34;
    Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
    &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
    {}
    &#34;&#34;&#34;
    return Parser[Sequence[A]].empty()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.equals"><code class="name flex">
<span>def <span class="ident">equals</span></span>(<span>s:Â str, peak=False) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equals(s: str, peak=False) -&gt; Parser[Sequence[KeyValue[str]]]:
    if peak:
        return sat_peak(
            predicate=lambda _s: _s == s,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )
    else:
        return sat_item(
            predicate=lambda _s: _s == s,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.field"><code class="name flex">
<span>def <span class="ident">field</span></span>(<span>metadata:Â Optional[dict]Â =Â None, type:Â Union[type,Â Callable[[str],Â Any],Â ForwardRef(None)]Â =Â None, help:Â Optional[str]Â =Â None, **kwargs) â€‘>Â dataclasses.Field</span>
</code></dt>
<dd>
<div class="desc"><p>This is a thin wrapper around <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.field</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>metadata</code></strong> :&ensp;<code>str</code></dt>
<dd>Identical to the <code>metadata</code> argument for <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.field</code></a>.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Optional[Union[type, Callable[[str], Any]]]</code></dt>
<dd>A function that takes a string and returns a value just like the <code>type</code> argument for
<a href="https://docs.python.org/3/library/argparse.html#type"><code>ArgumentParser.add_argument</code></a>.</dd>
<dt><strong><code>help</code></strong> :&ensp;<code>str</code></dt>
<dd>An optional help string for the argument.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>dataclasses.Field</code> object that can be used in place of a default argument as
described in the <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.Field</code> documentation</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field(
    metadata: Optional[dict] = None,
    type: Optional[Union[type, Callable[[str], Any]]] = None,
    help: Optional[str] = None,
    **kwargs,
) -&gt; Field:
    &#34;&#34;&#34;
    This is a thin wrapper around [`dataclasses.field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).

    Parameters
    ----------
    metadata : str
        Identical to the `metadata` argument for [`dataclasses.field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).
    type : Optional[Union[type, Callable[[str], Any]]]
        A function that takes a string and returns a value just like the `type` argument for
        [`ArgumentParser.add_argument`](https://docs.python.org/3/library/argparse.html#type).
    help : str
        An optional help string for the argument.

    Returns
    -------
    A `dataclasses.Field` object that can be used in place of a default argument as
    described in the [`dataclasses.Field` documentation](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).

    &#34;&#34;&#34;
    if metadata is None:
        metadata = {}
    if type is not None:
        metadata.update(type=type)
    if help is not None:
        metadata.update(help=help)
    return dataclasses.field(metadata=metadata, **kwargs)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.flag"><code class="name flex">
<span>def <span class="ident">flag</span></span>(<span>dest:Â str, default:Â Optional[bool]Â =Â None, help:Â Optional[str]Â =Â None, short:Â boolÂ =Â True, string:Â Optional[str]Â =Â None) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[bool]]]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;, default=False)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
&gt;&gt;&gt; p.parse_args()
{'verbose': False}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--verbose&quot;, &quot;--verbose&quot;)
{'verbose': True}
&gt;&gt;&gt; flag(&quot;v&quot;, string=&quot;--value&quot;).parse_args(&quot;--value&quot;)
{'v': True}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;verbose&quot;, default=False) | flag(&quot;quiet&quot;, default=False) | flag(&quot;yes&quot;, default=False)
&gt;&gt;&gt; p = p1 &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;value&quot;)
usage: [[--verbose | --quiet] | --yes]
Unrecognized argument: value
&gt;&gt;&gt; p.parse_args(&quot;value&quot;)
usage: [[--verbose | --quiet] | --yes]
Unrecognized argument: value
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
&gt;&gt;&gt; p1 = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;) | flag(&quot;yes&quot;)
&gt;&gt;&gt; p = p1 &gt;&gt; argument(&quot;a&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
usage: [[--verbose | --quiet] | --yes] a
The following arguments are required: a
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)
usage: [[--verbose | --quiet] | --yes] a
Expected '--verbose'. Got 'a'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flag(
    dest: str,
    default: Optional[bool] = None,
    help: Optional[str] = None,
    short: bool = True,
    string: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[bool]]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, default=False)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--verbose&#34;, &#34;--verbose&#34;)
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; flag(&#34;v&#34;, string=&#34;--value&#34;).parse_args(&#34;--value&#34;)
    {&#39;v&#39;: True}

    &gt;&gt;&gt; p1 = flag(&#34;verbose&#34;, default=False) | flag(&#34;quiet&#34;, default=False) | flag(&#34;yes&#34;, default=False)
    &gt;&gt;&gt; p = p1 &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;value&#34;)
    usage: [[--verbose | --quiet] | --yes]
    Unrecognized argument: value
    &gt;&gt;&gt; p.parse_args(&#34;value&#34;)
    usage: [[--verbose | --quiet] | --yes]
    Unrecognized argument: value
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; p1 = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | flag(&#34;yes&#34;)
    &gt;&gt;&gt; p = p1 &gt;&gt; argument(&#34;a&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    usage: [[--verbose | --quiet] | --yes] a
    The following arguments are required: a
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
    usage: [[--verbose | --quiet] | --yes] a
    Expected &#39;--verbose&#39;. Got &#39;a&#39;
    &#34;&#34;&#34;
    if string is None:
        _string = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _string = string

    def f(
        cs: Sequence[str],
        s: str,
    ) -&gt; Result[Parse[Sequence[KeyValue[bool]]]]:
        parser = equals(s) &gt;= (lambda _: defaults(**{dest: not default}))
        return parser.parse(cs)

    parser = Parser(partial(f, s=_string), usage=None, helps={})
    if default is not None:
        parser = parser | defaults(**{dest: default})
    if short:
        short_string = f&#34;-{dest[0]}&#34;
        parser2 = flag(dest, short=False, string=short_string, default=default)
        parser = parser | parser2
    if default:
        help = f&#34;{help + &#39; &#39; if help else &#39;&#39;}(default: {default})&#34;
    helps = {dest: help} if help else {}
    return replace(parser, usage=_string, helps=helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.item"><code class="name flex">
<span>def <span class="ident">item</span></span>(<span>name:Â str, description:Â Optional[str]Â =Â None) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item(
    name: str,
    description: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        if cs:
            head, *tail = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Sequence([KeyValue(name, head)]),
                        unparsed=Sequence(tail),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {description or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.nonpositional"><code class="name flex">
<span>def <span class="ident">nonpositional</span></span>(<span>*parsers:Â "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]]'") â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;debug&quot;, default=False)) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--debug&quot;)
{'verbose': True, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;, &quot;--verbose&quot;)
{'debug': True, 'verbose': True}
&gt;&gt;&gt; p.parse_args()
{'verbose': False, 'debug': False}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;)
{'verbose': False, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True, 'debug': False}
&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;debug&quot;, default=False)) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--debug&quot;)
{'verbose': True, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True, 'debug': False}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;)
{'verbose': False, 'debug': True}
&gt;&gt;&gt; p.parse_args()
{'verbose': False, 'debug': False}
&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;debug&quot;, default=False), argument(&quot;a&quot;)) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;, &quot;hello&quot;, &quot;--verbose&quot;)
{'debug': True, 'a': 'hello', 'verbose': True}
&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;))
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: --verbose
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nonpositional(*parsers: &#34;Parser[Sequence[A]]&#34;) -&gt; &#34;Parser[Sequence[A]]&#34;:
    &#34;&#34;&#34;
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;debug&#34;, default=False)) &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False, &#39;debug&#39;: False}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    {&#39;verbose&#39;: False, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: False}
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;debug&#34;, default=False)) &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: False}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    {&#39;verbose&#39;: False, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False, &#39;debug&#39;: False}
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;debug&#34;, default=False), argument(&#34;a&#34;)) &gt;&gt; done()
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;hello&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;a&#39;: &#39;hello&#39;, &#39;verbose&#39;: True}
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --verbose
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}
    &#34;&#34;&#34;
    if not parsers:
        return empty()

    def get_alternatives():
        for i, head in enumerate(parsers):
            tail = [p for j, p in enumerate(parsers) if j != i]
            yield head &gt;&gt; nonpositional(*tail)

    parser = reduce(operator.or_, get_alternatives())
    sep = &#34; &#34; if len(parsers) &lt;= 3 else &#34;\n&#34;
    return replace(parser, usage=sep.join([p.usage or &#34;&#34; for p in parsers]))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.option"><code class="name flex">
<span>def <span class="ident">option</span></span>(<span>dest:Â str, flag:Â Optional[str]Â =Â None, default=None, help:Â Optional[str]Â =Â None, short:Â boolÂ =Â True, type:Â Callable[[str],Â Any]Â =Â builtins.str) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;value&quot;).parse_args(&quot;--value&quot;, &quot;x&quot;)
{'value': 'x'}
&gt;&gt;&gt; option(&quot;value&quot;).parse_args(&quot;--value&quot;)
usage: --value VALUE
The following arguments are required: VALUE
&gt;&gt;&gt; option(&quot;value&quot;).parse_args()
usage: --value VALUE
The following arguments are required: --value
&gt;&gt;&gt; option(&quot;value&quot;, default=1).parse_args()
{'value': 1}
&gt;&gt;&gt; option(&quot;value&quot;, default=1).parse_args(&quot;--value&quot;)
{'value': 1}
&gt;&gt;&gt; option(&quot;value&quot;, default=1).parse_args(&quot;--value&quot;, &quot;x&quot;)
{'value': 'x'}
&gt;&gt;&gt; option(&quot;v&quot;).parse_args(&quot;-v&quot;, &quot;x&quot;)
{'v': 'x'}
&gt;&gt;&gt; option(&quot;v&quot;, flag=&quot;--value&quot;).parse_args(&quot;--value&quot;, &quot;x&quot;)
{'v': 'x'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def option(
    dest: str,
    flag: Optional[str] = None,
    default=None,
    help: Optional[str] = None,
    short: bool = True,
    type: Callable[[str], Any] = str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; option(&#34;value&#34;).parse_args(&#34;--value&#34;, &#34;x&#34;)
    {&#39;value&#39;: &#39;x&#39;}
    &gt;&gt;&gt; option(&#34;value&#34;).parse_args(&#34;--value&#34;)
    usage: --value VALUE
    The following arguments are required: VALUE
    &gt;&gt;&gt; option(&#34;value&#34;).parse_args()
    usage: --value VALUE
    The following arguments are required: --value
    &gt;&gt;&gt; option(&#34;value&#34;, default=1).parse_args()
    {&#39;value&#39;: 1}
    &gt;&gt;&gt; option(&#34;value&#34;, default=1).parse_args(&#34;--value&#34;)
    {&#39;value&#39;: 1}
    &gt;&gt;&gt; option(&#34;value&#34;, default=1).parse_args(&#34;--value&#34;, &#34;x&#34;)
    {&#39;value&#39;: &#39;x&#39;}
    &gt;&gt;&gt; option(&#34;v&#34;).parse_args(&#34;-v&#34;, &#34;x&#34;)
    {&#39;v&#39;: &#39;x&#39;}
    &gt;&gt;&gt; option(&#34;v&#34;, flag=&#34;--value&#34;).parse_args(&#34;--value&#34;, &#34;x&#34;)
    {&#39;v&#39;: &#39;x&#39;}
    &#34;&#34;&#34;

    if flag is None:
        _flag = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _flag = flag

    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        parser = equals(_flag) &gt;= (lambda _: item(dest, description=dest.upper()))
        return parser.parse(cs)

    parser = Parser(f, usage=None, helps={})
    if default:
        parser = parser | defaults(**{dest: default})
    if short and len(dest) &gt; 1:
        parser2 = option(dest=dest, short=False, flag=f&#34;-{dest[0]}&#34;, default=None)
        parser = parser | parser2
    if type is not str:
        parser = type_(type, parser)
    helps = {dest: help} if help else {}
    return replace(parser, usage=f&#34;{_flag} {dest.upper()}&#34;, helps=helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.sat"><code class="name flex">
<span>def <span class="ident">sat</span></span>(<span>parser:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Monoid1], predicate:Â Callable[[Monoid1],Â bool], on_fail:Â Callable[[Monoid1],Â ArgumentError]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~Monoid1]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sat(
    parser: Parser[Monoid1],
    predicate: Callable[[Monoid1], bool],
    on_fail: Callable[[Monoid1], ArgumentError],
) -&gt; Parser[Monoid1]:
    def f(x: Monoid1) -&gt; Result[Monoid1]:
        return Result(NonemptyList(x) if predicate(x) else on_fail(x))

    return apply(f, parser)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.sat_item"><code class="name flex">
<span>def <span class="ident">sat_item</span></span>(<span>predicate:Â Callable[[str],Â bool], on_fail:Â Callable[[str],Â ArgumentError], name:Â str) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sat_item(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    def _predicate(parsed: Sequence[KeyValue[str]]) -&gt; bool:
        [kv] = parsed
        return predicate(kv.value)

    def _on_fail(parsed: Sequence[KeyValue[str]]) -&gt; ArgumentError:
        [kv] = parsed
        return on_fail(kv.value)

    return sat(item(name), _predicate, _on_fail)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.type_"><code class="name flex">
<span>def <span class="ident">type_</span></span>(<span>f:Â Callable[[str],Â Any], parser:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[KeyValue[str]]]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_(
    f: Callable[[str], Any], parser: Parser[Sequence[KeyValue[str]]]
) -&gt; Parser[Sequence[KeyValue[Any]]]:
    def g(
        kvs: Sequence[KeyValue[str]],
    ) -&gt; Result[Sequence[KeyValue[Any]]]:
        head, *tail = kvs.get
        try:
            y = f(head.value)
        except Exception as e:
            usage = f&#34;argument {head.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        head = replace(head, value=y)
        return Result.return_(Sequence([*tail, head]))

    p = apply(g, parser)
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.wrap_help"><code class="name flex">
<span>def <span class="ident">wrap_help</span></span>(<span>parser:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~A]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_help(parser: Parser[A]) -&gt; Parser[A]:
    _help_parser: Parser[Sequence[A]] = help_parser(
        parser.usage or &#34;No usage provided.&#34;, Sequence([])
    )

    p = _help_parser &gt;= (lambda _: parser)
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dollar_lambda.Args"><code class="flex name class">
<span>class <span class="ident">Args</span></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> is sugar for the <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> function and removes much of the boilerplate
from defining parsers with many arguments.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     t: bool = False
...     f: bool = True
...     i: int = 1
...     s: str = &quot;a&quot;
&gt;&gt;&gt; p = MyArgs()
</code></pre>
<p>By using the <code><a title="dollar_lambda.Args.parser" href="#dollar_lambda.Args.parser">Args.parser()</a></code> method, <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> can take advantage of all the same
combinators as other parsers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument
&gt;&gt;&gt; p = MyArgs.parser()
&gt;&gt;&gt; p1 = p &gt;&gt; argument(&quot;a&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;-t&quot;, &quot;hello&quot;)
{'t': True, 'f': True, 'i': 1, 's': 'a', 'a': 'hello'}
</code></pre>
<p>Note that when the default value of an argument is <code>True</code>, <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> will, by default
add <code>--no-</code> to the front of the flag (while still assigning the value to the original key):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--no-f&quot;)
{'t': False, 'f': False, 'i': 1, 's': 'a'}
</code></pre>
<p>To suppress this behavior, set <code>flip_bools=False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parser(flip_bools=False).parse_args(&quot;--no-t&quot;, &quot;-f&quot;, &quot;-i&quot;, &quot;2&quot;, &quot;-s&quot;, &quot;b&quot;)
{'t': False, 'f': True, 'i': 1, 's': 'a'}
</code></pre>
<p>To supply other metadata, like <code>help</code> text and more complex <code>type</code> converters, use <code><a title="dollar_lambda.field" href="#dollar_lambda.field">field()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     n: int = field(default=0, help=&quot;a number to increment&quot;, type=lambda x: 1 + int(x))
&gt;&gt;&gt; MyArgs.parse_args(&quot;-n&quot;, &quot;1&quot;)
{'n': 2}
&gt;&gt;&gt; MyArgs.parse_args()
usage: -n N
n: a number to increment
The following arguments are required: -n
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Args:
    &#34;&#34;&#34;
    `Args` is sugar for the `nonpositional` function and removes much of the boilerplate
    from defining parsers with many arguments.

    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     t: bool = False
    ...     f: bool = True
    ...     i: int = 1
    ...     s: str = &#34;a&#34;
    &gt;&gt;&gt; p = MyArgs()

    By using the `Args.parser()` method, `Args` can take advantage of all the same
    combinators as other parsers:

    &gt;&gt;&gt; from dollar_lambda import argument
    &gt;&gt;&gt; p = MyArgs.parser()
    &gt;&gt;&gt; p1 = p &gt;&gt; argument(&#34;a&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;-t&#34;, &#34;hello&#34;)
    {&#39;t&#39;: True, &#39;f&#39;: True, &#39;i&#39;: 1, &#39;s&#39;: &#39;a&#39;, &#39;a&#39;: &#39;hello&#39;}

    Note that when the default value of an argument is `True`, `Args` will, by default
    add `--no-` to the front of the flag (while still assigning the value to the original key):
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--no-f&#34;)
    {&#39;t&#39;: False, &#39;f&#39;: False, &#39;i&#39;: 1, &#39;s&#39;: &#39;a&#39;}

    To suppress this behavior, set `flip_bools=False`:
    &gt;&gt;&gt; MyArgs.parser(flip_bools=False).parse_args(&#34;--no-t&#34;, &#34;-f&#34;, &#34;-i&#34;, &#34;2&#34;, &#34;-s&#34;, &#34;b&#34;)
    {&#39;t&#39;: False, &#39;f&#39;: True, &#39;i&#39;: 1, &#39;s&#39;: &#39;a&#39;}

    To supply other metadata, like `help` text and more complex `type` converters, use `field`:
    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     n: int = field(default=0, help=&#34;a number to increment&#34;, type=lambda x: 1 + int(x))
    &gt;&gt;&gt; MyArgs.parse_args(&#34;-n&#34;, &#34;1&#34;)
    {&#39;n&#39;: 2}
    &gt;&gt;&gt; MyArgs.parse_args()
    usage: -n N
    n: a number to increment
    The following arguments are required: -n
    &#34;&#34;&#34;

    @classmethod
    def parser(cls, flip_bools: bool = True) -&gt; Parser[Sequence[KeyValue[Any]]]:
        return ArgsField.nonpositional(
            *[ArgsField.parse(field) for field in fields(cls)], flip_bools=flip_bools
        )

    @classmethod
    def parse_args(cls, *args):
        return (cls.parser() &gt;&gt; done()).parse_args(*args)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="dollar_lambda.Args.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_args(cls, *args):
    return (cls.parser() &gt;&gt; done()).parse_args(*args)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Args.parser"><code class="name flex">
<span>def <span class="ident">parser</span></span>(<span>flip_bools:Â boolÂ =Â True) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parser(cls, flip_bools: bool = True) -&gt; Parser[Sequence[KeyValue[Any]]]:
    return ArgsField.nonpositional(
        *[ArgsField.parse(field) for field in fields(cls)], flip_bools=flip_bools
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.CommandTree"><code class="flex name class">
<span>class <span class="ident">CommandTree</span></span>
<span>(</span><span>children:Â List[<a title="dollar_lambda.decorators.Node" href="decorators.html#dollar_lambda.decorators.Node">Node</a>]Â =Â &lt;factory&gt;, required:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.subcommand()
... def f2(b: bool):
...     return dict(f2=dict(b=b))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree.main(&quot;-h&quot;)
usage: [-a A | f2 -b]
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
&gt;&gt;&gt; tree.main(&quot;f2&quot;, &quot;-b&quot;)
{'f2': {'b': True}}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @f1.subcommand(required=False)
... def f2(a: int, b: bool):
...     return dict(f2=dict(a=a, b=b))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @f1.subcommand(required=False)
... def f3(a: int, c: str):
...     return dict(f3=dict(a=a, c=c))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree.main(&quot;-h&quot;)
usage: -a A [f2 -b | f3 -c C]
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;, &quot;f2&quot;, &quot;-b&quot;)
{'f2': {'a': 1, 'b': True}}
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;, &quot;f3&quot;, &quot;-c&quot;, &quot;x&quot;)
{'f3': {'a': 1, 'c': 'x'}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class CommandTree:
    &#34;&#34;&#34;
    &gt;&gt;&gt; tree = CommandTree()

    &gt;&gt;&gt; @tree.command()
    ... def f1(a: int):
    ...     return dict(f1=dict(a=a))

    &gt;&gt;&gt; @tree.subcommand()
    ... def f2(b: bool):
    ...     return dict(f2=dict(b=b))

    &gt;&gt;&gt; tree.main(&#34;-h&#34;)
    usage: [-a A | f2 -b]
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;)
    {&#39;f1&#39;: {&#39;a&#39;: 1}}
    &gt;&gt;&gt; tree.main(&#34;f2&#34;, &#34;-b&#34;)
    {&#39;f2&#39;: {&#39;b&#39;: True}}

    &gt;&gt;&gt; tree = CommandTree()

    &gt;&gt;&gt; @tree.command()
    ... def f1(a: int):
    ...     return dict(f1=dict(a=a))

    &gt;&gt;&gt; @f1.subcommand(required=False)
    ... def f2(a: int, b: bool):
    ...     return dict(f2=dict(a=a, b=b))

    &gt;&gt;&gt; @f1.subcommand(required=False)
    ... def f3(a: int, c: str):
    ...     return dict(f3=dict(a=a, c=c))

    &gt;&gt;&gt; tree.main(&#34;-h&#34;)
    usage: -a A [f2 -b | f3 -c C]
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;)
    {&#39;f1&#39;: {&#39;a&#39;: 1}}
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;, &#34;f2&#34;, &#34;-b&#34;)
    {&#39;f2&#39;: {&#39;a&#39;: 1, &#39;b&#39;: True}}
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;, &#34;f3&#34;, &#34;-c&#34;, &#34;x&#34;)
    {&#39;f3&#39;: {&#39;a&#39;: 1, &#39;c&#39;: &#39;x&#39;}}
    &#34;&#34;&#34;

    children: List[Node] = field(default_factory=list)
    required: bool = False

    def command(
        self,
        flip_bools: bool = True,
        help: Optional[Dict[str, str]] = None,
        required: bool = False,
        types: Optional[Dict[str, Callable[[str], Any]]] = None,
    ) -&gt; Callable:
        return self.decorator(
            flip_bools=flip_bools,
            help=help,
            required=required,
            types=types,
            subcommand=False,
        )

    def decorator(self, **kwargs) -&gt; Callable:
        def wrapper(function: Callable):
            tree = CommandTree()
            self.children.append(Node(function=function, tree=tree, **kwargs))
            return tree

        return wrapper

    def parser(self, *variables: str) -&gt; Parser[FunctionPair[KeyValue[Any]]]:
        if not self.children:
            raise RuntimeError(
                &#34;You must assign children to a CommandTree object in order to use it as a parser.&#34;
            )

        def get_alternatives() -&gt; Iterator[Parser[FunctionPair[KeyValue[Any]]]]:
            if not self.required:
                yield cast(Parser[FunctionPair[KeyValue[Any]]], empty())
            for child in self.children:
                parser: Parser[FunctionPair[KeyValue[Any]]] = child.parser(*variables)
                if child.tree is not None and child.tree.children:
                    parser = cast(
                        Parser[FunctionPair[KeyValue[Any]]],
                        parser
                        &gt;&gt; child.tree.parser(*variables, *child.variable_names()),
                    )
                yield parser

        return wrap_help(reduce(operator.or_, get_alternatives()))

    def main(self, *args: str) -&gt; Any:
        _args = args if args or parser_mod.TESTING else sys.argv[1:]
        p = self.parser() &gt;&gt; done()
        result = p.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            p.handle_error(result)
            if parser_mod.TESTING:
                return  # type: ignore[return-value]
            else:
                exit()
        assert isinstance(result, NonemptyList)
        pair = cast(FunctionPair, result.head.parsed)
        return pair.function(**{kv.key: kv.value for kv in pair.get})

    def subcommand(
        self,
        flip_bools: bool = True,
        help: Optional[Dict[str, str]] = None,
        required: bool = False,
        types: Optional[Dict[str, Callable[[str], Any]]] = None,
    ) -&gt; Callable:
        return self.decorator(
            flip_bools=flip_bools,
            help=help,
            required=required,
            types=types,
            subcommand=True,
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.CommandTree.children"><code class="name">var <span class="ident">children</span> :Â List[<a title="dollar_lambda.decorators.Node" href="decorators.html#dollar_lambda.decorators.Node">Node</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.CommandTree.required"><code class="name">var <span class="ident">required</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.CommandTree.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self, flip_bools:Â boolÂ =Â True, help:Â Optional[Dict[str,Â str]]Â =Â None, required:Â boolÂ =Â False, types:Â Optional[Dict[str,Â Callable[[str],Â Any]]]Â =Â None) â€‘>Â Callable</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(
    self,
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    required: bool = False,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable:
    return self.decorator(
        flip_bools=flip_bools,
        help=help,
        required=required,
        types=types,
        subcommand=False,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.CommandTree.decorator"><code class="name flex">
<span>def <span class="ident">decorator</span></span>(<span>self, **kwargs) â€‘>Â Callable</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decorator(self, **kwargs) -&gt; Callable:
    def wrapper(function: Callable):
        tree = CommandTree()
        self.children.append(Node(function=function, tree=tree, **kwargs))
        return tree

    return wrapper</code></pre>
</details>
</dd>
<dt id="dollar_lambda.CommandTree.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, *args:Â str) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self, *args: str) -&gt; Any:
    _args = args if args or parser_mod.TESTING else sys.argv[1:]
    p = self.parser() &gt;&gt; done()
    result = p.parse(Sequence(list(_args))).get
    if isinstance(result, ArgumentError):
        p.handle_error(result)
        if parser_mod.TESTING:
            return  # type: ignore[return-value]
        else:
            exit()
    assert isinstance(result, NonemptyList)
    pair = cast(FunctionPair, result.head.parsed)
    return pair.function(**{kv.key: kv.value for kv in pair.get})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.CommandTree.parser"><code class="name flex">
<span>def <span class="ident">parser</span></span>(<span>self, *variables:Â str) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.decorators.FunctionPair" href="decorators.html#dollar_lambda.decorators.FunctionPair">FunctionPair</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parser(self, *variables: str) -&gt; Parser[FunctionPair[KeyValue[Any]]]:
    if not self.children:
        raise RuntimeError(
            &#34;You must assign children to a CommandTree object in order to use it as a parser.&#34;
        )

    def get_alternatives() -&gt; Iterator[Parser[FunctionPair[KeyValue[Any]]]]:
        if not self.required:
            yield cast(Parser[FunctionPair[KeyValue[Any]]], empty())
        for child in self.children:
            parser: Parser[FunctionPair[KeyValue[Any]]] = child.parser(*variables)
            if child.tree is not None and child.tree.children:
                parser = cast(
                    Parser[FunctionPair[KeyValue[Any]]],
                    parser
                    &gt;&gt; child.tree.parser(*variables, *child.variable_names()),
                )
            yield parser

    return wrap_help(reduce(operator.or_, get_alternatives()))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.CommandTree.subcommand"><code class="name flex">
<span>def <span class="ident">subcommand</span></span>(<span>self, flip_bools:Â boolÂ =Â True, help:Â Optional[Dict[str,Â str]]Â =Â None, required:Â boolÂ =Â False, types:Â Optional[Dict[str,Â Callable[[str],Â Any]]]Â =Â None) â€‘>Â Callable</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subcommand(
    self,
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    required: bool = False,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable:
    return self.decorator(
        flip_bools=flip_bools,
        help=help,
        required=required,
        types=types,
        subcommand=True,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.Parser"><code class="flex name class">
<span>class <span class="ident">Parser</span></span>
<span>(</span><span>f:Â Callable[[Sequence[str]],Â Result[Parse[A_co]]], usage:Â Optional[str], helps:Â Dict[str,Â str])</span>
</code></dt>
<dd>
<div class="desc"><p>Main class powering the argument parser.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Parser(MonadPlus[A_co]):
    &#34;&#34;&#34;
    Main class powering the argument parser.
    &#34;&#34;&#34;

    __pdoc__[&#34;Parser.__add__&#34;] = True
    __pdoc__[&#34;Parser.__or__&#34;] = True
    __pdoc__[&#34;Parser.__rshift__&#34;] = True
    __pdoc__[&#34;Parser.__ge__&#34;] = True

    f: Callable[[Sequence[str]], Result[Parse[A_co]]]
    usage: Optional[str]
    helps: Dict[str, str]

    def __add__(
        self: Parser[Sequence[A]], other: Parser[Sequence[B]]
    ) -&gt; Parser[Sequence[A | B]]:
        &#34;&#34;&#34;
        Parse two arguments in either order.
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
        {&#39;verbose&#39;: True, &#39;debug&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
        {&#39;debug&#39;: True, &#39;verbose&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
        usage: --verbose --debug
        Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

        Note that if more than two arguments are chained together with `+`, some combinations will not parse:
        &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
        {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
        usage: -a -b -c
        Expected &#39;-b&#39;. Got &#39;-c&#39;

        This makes more sense when one supplies the implicit parentheses:
        &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

        In order to chain together more than two arguments, use `nonpositional`:
        &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
        {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
        &#34;&#34;&#34;
        p = (self &gt;&gt; other) | (other &gt;&gt; self)
        usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
        return replace(p, usage=usage)

    def __or__(
        self: Parser[A_co],
        other: Parser[B],
    ) -&gt; Parser[A_co | B]:
        &#34;&#34;&#34;
        Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

        &gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
        &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
        {&#39;verbose&#39;: True}

        Note that when both arguments are supplied, this will only parse the first:
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        {&#39;verbose&#39;: True}

        If you want this to fail, use `&gt;&gt;` (`Parser.__rshift__`) with `done()` or another parser:
        &gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        usage: [--option OPTION | --verbose]
        Unrecognized argument: --option
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A_co | B]]:
            return self.parse(cs) | other.parse(cs)

        return Parser(
            f,
            usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
            helps={**self.helps, **other.helps},
        )

    def __rshift__(
        self: Parser[Sequence[A]], p: Parser[Sequence[B]]
    ) -&gt; Parser[Sequence[A | B]]:
        &#34;&#34;&#34;
        This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
        gets handed off to the second parser. If either parser fails, the whole thing fails.

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        usage: first second
        The following arguments are required: second
        &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
        usage: first second
        The following arguments are required: second
        &#34;&#34;&#34;
        # def f(p1: Sequence[D]) -&gt; Parser[Parse[Sequence[D | B]]]:
        #     def g(p2: Sequence[B]) -&gt; Parser[Sequence[D | B]]:
        #         return Parser.return_(p1 + p2)

        #     return p &gt;= g

        # return self &gt;= f
        parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
        return replace(
            parser,
            usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False),
            helps={**self.helps, **p.helps},
        )

    def bind(self, f: Callable[[A_co], Parser[B]]) -&gt; Parser[B]:
        &#34;&#34;&#34;
        Returns a new parser that

        1. applies `self`;
        2. if this succeeds, applies `f` to the parsed component of the result.

        `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
        avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
        `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

        Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
        and we typically prefer using the infix operator to the spelled out method.

        Let&#39;s start with our simplest parser, `argument`:
        &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

        Now let&#39;s use the `equals` parser to write a function that takes the output of `p1` and fails unless
        the next argument is the same as the first:
        &gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Sequence(KeyValue[str]):
        ...     [kv] = kvs
        ...     return equals(kv.value)

        &gt;&gt;&gt; p = p1 &gt;= f
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
        {&#39;a&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        Expected &#39;a&#39;. Got &#39;b&#39;
        &#34;&#34;&#34;

        def h(parse: Parse[A_co]) -&gt; Result[Parse[B]]:
            return f(parse.parsed).parse(parse.unparsed)

        def g(cs: Sequence[str]) -&gt; Result[Parse[B]]:
            return self.parse(cs) &gt;= h

        return Parser(g, usage=None, helps=self.helps)

    @classmethod
    def empty(cls: Type[Parser[Sequence[A]]]) -&gt; Parser[Sequence[A]]:
        &#34;&#34;&#34;
        Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
        &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
        {}
        &#34;&#34;&#34;
        return cls.return_(Sequence([]))

    def handle_error(self, error: ArgumentError) -&gt; None:
        if self.usage and not isinstance(error, HelpError):
            print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in self.usage else &#34; &#34;)
            if &#34;\n&#34; in self.usage:
                usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in self.usage.split(&#34;\n&#34;)])
            else:
                usage = self.usage
            print(usage)
        if self.helps:
            for k, v in self.helps.items():
                print(f&#34;{k}: {v}&#34;)
        if error.usage:
            if isinstance(error, HelpError):
                print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in error.usage else &#34; &#34;)
            print(error.usage)

    def many(self: Parser[Sequence[Monoid1]]) -&gt; Parser[Sequence[Monoid1]]:
        &#34;&#34;&#34;
        Applies `self` zero or more times (like `*` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(return_dict=False)
        []
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, return_dict=False)
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;)]
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)  # return_dict=False allows duplicate keys
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

        Note that if `self` contains `Parser.__or__`, the arguments can be
        heterogenous:
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
        &gt;&gt;&gt; p = p.many()
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, return_dict=False) # mix --verbose and --quiet
        [(&#39;verbose&#39;, True), (&#39;quiet&#39;, True)]
        &#34;&#34;&#34;
        p = self.many1() | self.empty()
        return replace(p, usage=f&#34;[{self.usage} ...]&#34;)

    def many1(self: Parser[Sequence[Monoid1]]) -&gt; Parser[Sequence[Monoid1]]:
        &#34;&#34;&#34;
        Applies `self` one or more times (like `+` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
        {&#39;1-or-more&#39;: &#39;1&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, return_dict=False)  # return_dict=False allows duplicate keys
        [(&#39;1-or-more&#39;, &#39;1&#39;), (&#39;1-or-more&#39;, &#39;2&#39;)]
        &gt;&gt;&gt; p.parse_args()
        usage: 1-or-more [1-or-more ...]
        The following arguments are required: 1-or-more
        &#34;&#34;&#34;

        def g() -&gt; Generator[&#34;Parser[Sequence[Monoid1]]&#34;, Sequence[Monoid1], None]:
            # noinspection PyTypeChecker
            r1: Sequence[Monoid1] = yield self
            # noinspection PyTypeChecker
            r2: Sequence[Monoid1] = yield self.many()
            yield Parser[Sequence[Monoid1]].return_(r1 + r2)

        @lru_cache()
        def f(cs: tuple):
            return Parser.do(g).parse(Sequence(list(cs)))

        return Parser(
            lambda cs: f(tuple(cs)),
            usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
            helps=self.helps,
        )

    def optional(self: Parser[Sequence[A]]) -&gt; Parser[Sequence[A]]:
        return self | self.empty()

    def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        &#34;&#34;&#34;
        Applies the parser to the input sequence `cs`.
        &#34;&#34;&#34;
        return self.f(cs)

    def parse_args(
        self: &#34;Parser[Sequence[KeyValue]]&#34;,
        *args: str,
        return_dict: bool = True,
        check_help: bool = True,
    ) -&gt; typing.Sequence[KeyValueTuple] | Dict[str, Any]:
        &#34;&#34;&#34;
        The main way the user extracts parsed results from the parser.

        Parameters
        ----------
        args : str
            A sequence of strings to parse (e.g. `sys.argv[1:]`).
        return_dict : bool
            Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
            The tuples are `KeyValueTuple` namedtuples, with fields `key` and `value`.
        check_help : bool
            Before running the parser, checks if the input string is `--help` or `-h`.
            If it is, returns the usage message.

        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
        usage: a
        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
        usage: a
        &#34;&#34;&#34;
        _args = args if args or TESTING else sys.argv[1:]
        if check_help:
            return wrap_help(self).parse_args(
                *_args, return_dict=return_dict, check_help=False
            )
        result = self.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            self.handle_error(result)
            if TESTING:
                return  # type: ignore[return-value]
            else:
                exit()

        kvs = result.head.parsed
        if return_dict:
            return {kv.key: kv.value for kv in kvs}
        return [KeyValueTuple(**asdict(kv)) for kv in kvs]

    @classmethod
    def return_(cls, a: A_co) -&gt; Parser[A_co]:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
        and always returns `a` as the result. For the most part, the user will not use
        this method unless building custom parsers.

        &gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
        &gt;&gt;&gt; Parser.return_(([KeyValue(&#34;some-key&#34;, &#34;some-value&#34;)])).parse_args()
        {&#39;some-key&#39;: &#39;some-value&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
            return Result.return_(Parse(a, cs))

        return Parser(f, usage=None, helps={})

    @classmethod
    def zero(cls, error: Optional[ArgumentError] = None) -&gt; Parser[A_co]:
        &#34;&#34;&#34;
        This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

        Parameters
        ----------
        error : Optional[ArgumentError]
            Customize the error returned by `zero`.

        &gt;&gt;&gt; Parser.zero().parse_args()
        zero
        &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
        zero
        &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
        This is a test.
        &#34;&#34;&#34;
        return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pytypeclass.monoid.MonadPlus</li>
<li>pytypeclass.monad.Monad</li>
<li>pytypeclass.monoid.Monoid</li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.Parser.f"><code class="name">var <span class="ident">f</span> :Â Callable[[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[str]],Â <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="parser.html#dollar_lambda.parser.Parse">Parse</a>[+A_co]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.Parser.helps"><code class="name">var <span class="ident">helps</span> :Â Dict[str,Â str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.Parser.usage"><code class="name">var <span class="ident">usage</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dollar_lambda.Parser.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Always returns {}, no matter the input. Mostly useful for use in <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; empty().parse_args(&quot;any&quot;, &quot;arguments&quot;)
{}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty(cls: Type[Parser[Sequence[A]]]) -&gt; Parser[Sequence[A]]:
    &#34;&#34;&#34;
    Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
    &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
    {}
    &#34;&#34;&#34;
    return cls.return_(Sequence([]))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.return_"><code class="name flex">
<span>def <span class="ident">return_</span></span>(<span>a:Â A_co) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"><p>This method is required to make <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. It consumes none of the input
and always returns <code>a</code> as the result. For the most part, the user will not use
this method unless building custom parsers.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
&gt;&gt;&gt; Parser.return_(([KeyValue(&quot;some-key&quot;, &quot;some-value&quot;)])).parse_args()
{'some-key': 'some-value'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def return_(cls, a: A_co) -&gt; Parser[A_co]:  # type: ignore[misc]
    # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
    &#34;&#34;&#34;
    This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
    and always returns `a` as the result. For the most part, the user will not use
    this method unless building custom parsers.

    &gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
    &gt;&gt;&gt; Parser.return_(([KeyValue(&#34;some-key&#34;, &#34;some-value&#34;)])).parse_args()
    {&#39;some-key&#39;: &#39;some-value&#39;}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        return Result.return_(Parse(a, cs))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.zero"><code class="name flex">
<span>def <span class="ident">zero</span></span>(<span>error:Â Optional[ArgumentError]Â =Â None) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"><p>This parser always fails. This method is necessary to make <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13"><code>Monoid</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>error</code></strong> :&ensp;<code>Optional[ArgumentError]</code></dt>
<dd>Customize the error returned by <code>zero</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.zero().parse_args()
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero().parse_args(&quot;a&quot;)
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero(error=ArgumentError(&quot;This is a test.&quot;)).parse_args(&quot;a&quot;)
This is a test.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def zero(cls, error: Optional[ArgumentError] = None) -&gt; Parser[A_co]:
    &#34;&#34;&#34;
    This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

    Parameters
    ----------
    error : Optional[ArgumentError]
        Customize the error returned by `zero`.

    &gt;&gt;&gt; Parser.zero().parse_args()
    zero
    &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
    zero
    &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
    This is a test.
    &#34;&#34;&#34;
    return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.Parser.__add__"><code class="name flex">
<span>def <span class="ident">__add__</span></span>(<span>self:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]], other:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[B]]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[typing.Union[~A,Â ~B]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse two arguments in either order.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;debug&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--debug&quot;)
{'verbose': True, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;, &quot;--verbose&quot;)
{'debug': True, 'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;)
usage: --verbose --debug
Expected '--verbose'. Got '--debug'
</code></pre>
<p>Note that if more than two arguments are chained together with <code>+</code>, some combinations will not parse:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;a&quot;) + flag(&quot;b&quot;) + flag(&quot;c&quot;)
&gt;&gt;&gt; p.parse_args(&quot;-c&quot;, &quot;-a&quot;, &quot;-b&quot;)   # this works
{'c': True, 'a': True, 'b': True}
&gt;&gt;&gt; p.parse_args(&quot;-a&quot;, &quot;-c&quot;, &quot;-b&quot;)   # this doesn't
usage: -a -b -c
Expected '-b'. Got '-c'
</code></pre>
<p>This makes more sense when one supplies the implicit parentheses:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (flag(&quot;a&quot;) + flag(&quot;b&quot;)) + flag(&quot;c&quot;)
</code></pre>
<p>In order to chain together more than two arguments, use <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;a&quot;), flag(&quot;b&quot;), flag(&quot;c&quot;))
&gt;&gt;&gt; p.parse_args(&quot;-a&quot;, &quot;-c&quot;, &quot;-b&quot;)
{'a': True, 'c': True, 'b': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __add__(
    self: Parser[Sequence[A]], other: Parser[Sequence[B]]
) -&gt; Parser[Sequence[A | B]]:
    &#34;&#34;&#34;
    Parse two arguments in either order.
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    usage: --verbose --debug
    Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

    Note that if more than two arguments are chained together with `+`, some combinations will not parse:
    &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
    {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
    usage: -a -b -c
    Expected &#39;-b&#39;. Got &#39;-c&#39;

    This makes more sense when one supplies the implicit parentheses:
    &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

    In order to chain together more than two arguments, use `nonpositional`:
    &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
    {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
    &#34;&#34;&#34;
    p = (self &gt;&gt; other) | (other &gt;&gt; self)
    usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
    return replace(p, usage=usage)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__or__"><code class="name flex">
<span>def <span class="ident">__or__</span></span>(<span>self:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A_co], other:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[B]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[typing.Union[+A_co,Â ~B]]</span>
</code></dt>
<dd>
<div class="desc"><p>Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
&gt;&gt;&gt; p = option(&quot;option&quot;) | flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--option&quot;, &quot;x&quot;)
{'option': 'x'}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<p>Note that when both arguments are supplied, this will only parse the first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--option&quot;, &quot;x&quot;)
{'verbose': True}
</code></pre>
<p>If you want this to fail, use <code>&gt;&gt;</code> (<code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code>) with <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> or another parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&quot;--verbose&quot;, &quot;--option&quot;, &quot;x&quot;)
usage: [--option OPTION | --verbose]
Unrecognized argument: --option
&gt;&gt;&gt; p.parse_args(&quot;--option&quot;, &quot;x&quot;)
{'option': 'x'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __or__(
    self: Parser[A_co],
    other: Parser[B],
) -&gt; Parser[A_co | B]:
    &#34;&#34;&#34;
    Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

    &gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
    &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
    {&#39;option&#39;: &#39;x&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}

    Note that when both arguments are supplied, this will only parse the first:
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
    {&#39;verbose&#39;: True}

    If you want this to fail, use `&gt;&gt;` (`Parser.__rshift__`) with `done()` or another parser:
    &gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
    usage: [--option OPTION | --verbose]
    Unrecognized argument: --option
    &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
    {&#39;option&#39;: &#39;x&#39;}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[A_co | B]]:
        return self.parse(cs) | other.parse(cs)

    return Parser(
        f,
        usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
        helps={**self.helps, **other.helps},
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__rshift__"><code class="name flex">
<span>def <span class="ident">__rshift__</span></span>(<span>self:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]], p:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[B]]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[typing.Union[~A,Â ~B]]]</span>
</code></dt>
<dd>
<div class="desc"><p>This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
gets handed off to the second parser. If either parser fails, the whole thing fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;first&quot;) &gt;&gt; argument(&quot;second&quot;)
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
{'first': 'a', 'second': 'b'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)
usage: first second
The following arguments are required: second
&gt;&gt;&gt; p.parse_args(&quot;b&quot;)
usage: first second
The following arguments are required: second
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __rshift__(
    self: Parser[Sequence[A]], p: Parser[Sequence[B]]
) -&gt; Parser[Sequence[A | B]]:
    &#34;&#34;&#34;
    This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
    gets handed off to the second parser. If either parser fails, the whole thing fails.

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
    usage: first second
    The following arguments are required: second
    &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
    usage: first second
    The following arguments are required: second
    &#34;&#34;&#34;
    # def f(p1: Sequence[D]) -&gt; Parser[Parse[Sequence[D | B]]]:
    #     def g(p2: Sequence[B]) -&gt; Parser[Sequence[D | B]]:
    #         return Parser.return_(p1 + p2)

    #     return p &gt;= g

    # return self &gt;= f
    parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
    return replace(
        parser,
        usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False),
        helps={**self.helps, **p.helps},
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.bind"><code class="name flex">
<span>def <span class="ident">bind</span></span>(<span>self, f:Â Callable[[A_co],Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[B]]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~B]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new parser that</p>
<ol>
<li>applies <code>self</code>;</li>
<li>if this succeeds, applies <code>f</code> to the parsed component of the result.</li>
</ol>
<p><code>bind</code> is one of the functions that makes <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. But most users will
avoid using it directly, preferring higher level combinators like <code>&gt;&gt;</code> (<code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code>),
<code>|</code> (<code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>) and <code>+</code> (<code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code>).</p>
<p>Note that <code>&gt;=</code> as a synonym for <code>bind</code> (as defined in <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26"><code>pytypeclass</code></a>)
and we typically prefer using the infix operator to the spelled out method.</p>
<p>Let's start with our simplest parser, <code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = argument(&quot;some_dest&quot;)
</code></pre>
<p>Now let's use the <code><a title="dollar_lambda.equals" href="#dollar_lambda.equals">equals()</a></code> parser to write a function that takes the output of <code>p1</code> and fails unless
the next argument is the same as the first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Sequence(KeyValue[str]):
...     [kv] = kvs
...     return equals(kv.value)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = p1 &gt;= f
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;a&quot;)
{'a': 'a'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
Expected 'a'. Got 'b'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind(self, f: Callable[[A_co], Parser[B]]) -&gt; Parser[B]:
    &#34;&#34;&#34;
    Returns a new parser that

    1. applies `self`;
    2. if this succeeds, applies `f` to the parsed component of the result.

    `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
    avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
    `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

    Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
    and we typically prefer using the infix operator to the spelled out method.

    Let&#39;s start with our simplest parser, `argument`:
    &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

    Now let&#39;s use the `equals` parser to write a function that takes the output of `p1` and fails unless
    the next argument is the same as the first:
    &gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Sequence(KeyValue[str]):
    ...     [kv] = kvs
    ...     return equals(kv.value)

    &gt;&gt;&gt; p = p1 &gt;= f
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
    {&#39;a&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    Expected &#39;a&#39;. Got &#39;b&#39;
    &#34;&#34;&#34;

    def h(parse: Parse[A_co]) -&gt; Result[Parse[B]]:
        return f(parse.parsed).parse(parse.unparsed)

    def g(cs: Sequence[str]) -&gt; Result[Parse[B]]:
        return self.parse(cs) &gt;= h

    return Parser(g, usage=None, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.handle_error"><code class="name flex">
<span>def <span class="ident">handle_error</span></span>(<span>self, error:Â ArgumentError) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_error(self, error: ArgumentError) -&gt; None:
    if self.usage and not isinstance(error, HelpError):
        print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in self.usage else &#34; &#34;)
        if &#34;\n&#34; in self.usage:
            usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in self.usage.split(&#34;\n&#34;)])
        else:
            usage = self.usage
        print(usage)
    if self.helps:
        for k, v in self.helps.items():
            print(f&#34;{k}: {v}&#34;)
    if error.usage:
        if isinstance(error, HelpError):
            print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in error.usage else &#34; &#34;)
        print(error.usage)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.many"><code class="name flex">
<span>def <span class="ident">many</span></span>(<span>self:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[Monoid1]]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~Monoid1]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> zero or more times (like <code>*</code> in regexes).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(return_dict=False)
[]
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, return_dict=False)
[('as-many-as-you-like', 'a')]
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;, return_dict=False)  # return_dict=False allows duplicate keys
[('as-many-as-you-like', 'a'), ('as-many-as-you-like', 'b')]
</code></pre>
<p>Note that if <code>self</code> contains <code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>, the arguments can be
heterogenous:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p = p.many()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;, return_dict=False) # mix --verbose and --quiet
[('verbose', True), ('quiet', True)]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def many(self: Parser[Sequence[Monoid1]]) -&gt; Parser[Sequence[Monoid1]]:
    &#34;&#34;&#34;
    Applies `self` zero or more times (like `*` in regexes).

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(return_dict=False)
    []
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, return_dict=False)
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;)]
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)  # return_dict=False allows duplicate keys
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

    Note that if `self` contains `Parser.__or__`, the arguments can be
    heterogenous:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
    &gt;&gt;&gt; p = p.many()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, return_dict=False) # mix --verbose and --quiet
    [(&#39;verbose&#39;, True), (&#39;quiet&#39;, True)]
    &#34;&#34;&#34;
    p = self.many1() | self.empty()
    return replace(p, usage=f&#34;[{self.usage} ...]&#34;)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.many1"><code class="name flex">
<span>def <span class="ident">many1</span></span>(<span>self:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[Monoid1]]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~Monoid1]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> one or more times (like <code>+</code> in regexes).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;1-or-more&quot;).many1()
&gt;&gt;&gt; p.parse_args(&quot;1&quot;)
{'1-or-more': '1'}
&gt;&gt;&gt; p.parse_args(&quot;1&quot;, &quot;2&quot;, return_dict=False)  # return_dict=False allows duplicate keys
[('1-or-more', '1'), ('1-or-more', '2')]
&gt;&gt;&gt; p.parse_args()
usage: 1-or-more [1-or-more ...]
The following arguments are required: 1-or-more
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def many1(self: Parser[Sequence[Monoid1]]) -&gt; Parser[Sequence[Monoid1]]:
    &#34;&#34;&#34;
    Applies `self` one or more times (like `+` in regexes).

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
    {&#39;1-or-more&#39;: &#39;1&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, return_dict=False)  # return_dict=False allows duplicate keys
    [(&#39;1-or-more&#39;, &#39;1&#39;), (&#39;1-or-more&#39;, &#39;2&#39;)]
    &gt;&gt;&gt; p.parse_args()
    usage: 1-or-more [1-or-more ...]
    The following arguments are required: 1-or-more
    &#34;&#34;&#34;

    def g() -&gt; Generator[&#34;Parser[Sequence[Monoid1]]&#34;, Sequence[Monoid1], None]:
        # noinspection PyTypeChecker
        r1: Sequence[Monoid1] = yield self
        # noinspection PyTypeChecker
        r2: Sequence[Monoid1] = yield self.many()
        yield Parser[Sequence[Monoid1]].return_(r1 + r2)

    @lru_cache()
    def f(cs: tuple):
        return Parser.do(g).parse(Sequence(list(cs)))

    return Parser(
        lambda cs: f(tuple(cs)),
        usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
        helps=self.helps,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.optional"><code class="name flex">
<span>def <span class="ident">optional</span></span>(<span>self:Â <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]]) â€‘>Â <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optional(self: Parser[Sequence[A]]) -&gt; Parser[Sequence[A]]:
    return self | self.empty()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, cs:Â Sequence[str]) â€‘>Â <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="parser.html#dollar_lambda.parser.Parse">Parse</a>[+A_co]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the parser to the input sequence <code>cs</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
    &#34;&#34;&#34;
    Applies the parser to the input sequence `cs`.
    &#34;&#34;&#34;
    return self.f(cs)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>self:Â "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[KeyValue]]'", *args:Â str, return_dict:Â boolÂ =Â True, check_help:Â boolÂ =Â True) â€‘>Â Union[Sequence[<a title="dollar_lambda.key_value.KeyValueTuple" href="key_value.html#dollar_lambda.key_value.KeyValueTuple">KeyValueTuple</a>],Â Dict[str,Â Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>The main way the user extracts parsed results from the parser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>str</code></dt>
<dd>A sequence of strings to parse (e.g. <code>sys.argv[1:]</code>).</dd>
<dt><strong><code>return_dict</code></strong> :&ensp;<code>bool</code></dt>
<dd>Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
The tuples are <code>KeyValueTuple</code> namedtuples, with fields <code>key</code> and <code>value</code>.</dd>
<dt><strong><code>check_help</code></strong> :&ensp;<code>bool</code></dt>
<dd>Before running the parser, checks if the input string is <code>--help</code> or <code>-h</code>.
If it is, returns the usage message.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;, return_dict=False)
[('as-many-as-you-like', 'a'), ('as-many-as-you-like', 'b')]
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;-h&quot;)
**```usage```** :&amp;ensp;&lt;code&gt;a&lt;/code&gt;
:   &amp;nbsp;


&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;--help&quot;)
**```usage```** :&amp;ensp;&lt;code&gt;a&lt;/code&gt;
:   &amp;nbsp;


</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_args(
    self: &#34;Parser[Sequence[KeyValue]]&#34;,
    *args: str,
    return_dict: bool = True,
    check_help: bool = True,
) -&gt; typing.Sequence[KeyValueTuple] | Dict[str, Any]:
    &#34;&#34;&#34;
    The main way the user extracts parsed results from the parser.

    Parameters
    ----------
    args : str
        A sequence of strings to parse (e.g. `sys.argv[1:]`).
    return_dict : bool
        Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
        The tuples are `KeyValueTuple` namedtuples, with fields `key` and `value`.
    check_help : bool
        Before running the parser, checks if the input string is `--help` or `-h`.
        If it is, returns the usage message.

    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
    usage: a
    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
    usage: a
    &#34;&#34;&#34;
    _args = args if args or TESTING else sys.argv[1:]
    if check_help:
        return wrap_help(self).parse_args(
            *_args, return_dict=return_dict, check_help=False
        )
    result = self.parse(Sequence(list(_args))).get
    if isinstance(result, ArgumentError):
        self.handle_error(result)
        if TESTING:
            return  # type: ignore[return-value]
        else:
            exit()

    kvs = result.head.parsed
    if return_dict:
        return {kv.key: kv.value for kv in kvs}
    return [KeyValueTuple(**asdict(kv)) for kv in kvs]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#tutorial">Tutorial</a><ul>
<li><a href="#high-level-parsers">High-Level Parsers</a><ul>
<li><a href="#flag">flag</a></li>
<li><a href="#option">option</a></li>
<li><a href="#done">done</a></li>
</ul>
</li>
<li><a href="#parser-combinators">Parser Combinators</a><ul>
<li><a href="#parser__or__">Parser.__or__</a></li>
<li><a href="#parser__rshift__">Parser.__rshift__</a></li>
<li><a href="#nonpositional">nonpositional</a></li>
</ul>
</li>
<li><a href="#putting-it-all-together">Putting it all together</a></li>
<li><a href="#alternative-syntax">Alternative syntax</a><ul>
<li><a href="#args">Args</a></li>
<li><a href="#defaults">defaults</a></li>
</ul>
</li>
<li><a href="#variations-on-the-example">Variations on the example</a><ul>
<li><a href="#something-argparse-cant-do">Something argparse can't do</a></li>
<li><a href="#parsermany">Parser.many</a></li>
<li><a href="#parsermany1">Parser.many1</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="dollar_lambda.args" href="args.html">dollar_lambda.args</a></code></li>
<li><code><a title="dollar_lambda.decorators" href="decorators.html">dollar_lambda.decorators</a></code></li>
<li><code><a title="dollar_lambda.error" href="error.html">dollar_lambda.error</a></code></li>
<li><code><a title="dollar_lambda.key_value" href="key_value.html">dollar_lambda.key_value</a></code></li>
<li><code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code></li>
<li><code><a title="dollar_lambda.result" href="result.html">dollar_lambda.result</a></code></li>
<li><code><a title="dollar_lambda.sequence" href="sequence.html">dollar_lambda.sequence</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="dollar_lambda.apply" href="#dollar_lambda.apply">apply</a></code></li>
<li><code><a title="dollar_lambda.apply_item" href="#dollar_lambda.apply_item">apply_item</a></code></li>
<li><code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument</a></code></li>
<li><code><a title="dollar_lambda.command" href="#dollar_lambda.command">command</a></code></li>
<li><code><a title="dollar_lambda.defaults" href="#dollar_lambda.defaults">defaults</a></code></li>
<li><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done</a></code></li>
<li><code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty</a></code></li>
<li><code><a title="dollar_lambda.equals" href="#dollar_lambda.equals">equals</a></code></li>
<li><code><a title="dollar_lambda.field" href="#dollar_lambda.field">field</a></code></li>
<li><code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag</a></code></li>
<li><code><a title="dollar_lambda.item" href="#dollar_lambda.item">item</a></code></li>
<li><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional</a></code></li>
<li><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option</a></code></li>
<li><code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat</a></code></li>
<li><code><a title="dollar_lambda.sat_item" href="#dollar_lambda.sat_item">sat_item</a></code></li>
<li><code><a title="dollar_lambda.type_" href="#dollar_lambda.type_">type_</a></code></li>
<li><code><a title="dollar_lambda.wrap_help" href="#dollar_lambda.wrap_help">wrap_help</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.Args.parse_args" href="#dollar_lambda.Args.parse_args">parse_args</a></code></li>
<li><code><a title="dollar_lambda.Args.parser" href="#dollar_lambda.Args.parser">parser</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code></h4>
<ul class="two-column">
<li><code><a title="dollar_lambda.CommandTree.children" href="#dollar_lambda.CommandTree.children">children</a></code></li>
<li><code><a title="dollar_lambda.CommandTree.command" href="#dollar_lambda.CommandTree.command">command</a></code></li>
<li><code><a title="dollar_lambda.CommandTree.decorator" href="#dollar_lambda.CommandTree.decorator">decorator</a></code></li>
<li><code><a title="dollar_lambda.CommandTree.main" href="#dollar_lambda.CommandTree.main">main</a></code></li>
<li><code><a title="dollar_lambda.CommandTree.parser" href="#dollar_lambda.CommandTree.parser">parser</a></code></li>
<li><code><a title="dollar_lambda.CommandTree.required" href="#dollar_lambda.CommandTree.required">required</a></code></li>
<li><code><a title="dollar_lambda.CommandTree.subcommand" href="#dollar_lambda.CommandTree.subcommand">subcommand</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code></h4>
<ul class="two-column">
<li><code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">__add__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">__or__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">__rshift__</a></code></li>
<li><code><a title="dollar_lambda.Parser.bind" href="#dollar_lambda.Parser.bind">bind</a></code></li>
<li><code><a title="dollar_lambda.Parser.empty" href="#dollar_lambda.Parser.empty">empty</a></code></li>
<li><code><a title="dollar_lambda.Parser.f" href="#dollar_lambda.Parser.f">f</a></code></li>
<li><code><a title="dollar_lambda.Parser.handle_error" href="#dollar_lambda.Parser.handle_error">handle_error</a></code></li>
<li><code><a title="dollar_lambda.Parser.helps" href="#dollar_lambda.Parser.helps">helps</a></code></li>
<li><code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">many</a></code></li>
<li><code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">many1</a></code></li>
<li><code><a title="dollar_lambda.Parser.optional" href="#dollar_lambda.Parser.optional">optional</a></code></li>
<li><code><a title="dollar_lambda.Parser.parse" href="#dollar_lambda.Parser.parse">parse</a></code></li>
<li><code><a title="dollar_lambda.Parser.parse_args" href="#dollar_lambda.Parser.parse_args">parse_args</a></code></li>
<li><code><a title="dollar_lambda.Parser.return_" href="#dollar_lambda.Parser.return_">return_</a></code></li>
<li><code><a title="dollar_lambda.Parser.usage" href="#dollar_lambda.Parser.usage">usage</a></code></li>
<li><code><a title="dollar_lambda.Parser.zero" href="#dollar_lambda.Parser.zero">zero</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
