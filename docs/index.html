<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dollar_lambda API documentation</title>
<meta name="description" content="**$λ** This package provides an alternative to [`argparse`](https://docs.python.org/3/library/argparse.html) based on functional first principles.
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>dollar_lambda</code></h1>
</header>
<section id="section-intro">
<p><strong>$λ</strong> This package provides an alternative to <a href="https://docs.python.org/3/library/argparse.html"><code>argparse</code></a> based on functional first principles.
This means that this package can handle many kinds of argument-parsing patterns that are either very awkward, difficult, or impossible with <code>argparse</code>.</p>
<h1 id="why">Why <code>$λ</code>?</h1>
<p><code>$λ</code> was built with minimal dependencies from functional first principles.
As a result, it is the most</p>
<ul>
<li>versatile</li>
<li>type-safe</li>
<li>and concise</li>
</ul>
<p>argument parser on the market.</p>
<h3 id="versatile">Versatile</h3>
<p><code>$λ</code> provides high-level functionality equivalent to other parsers. But unlike other parsers,
it permits low-level customization to handle arbitrarily complex parsing patterns. As we'll see
in the tutorial, there are many parsing patterns that <code>$λ</code> can handle which are not possible with
other parsing libraries.</p>
<h3 id="type-safe">Type-safe</h3>
<p><code>$λ</code> uses type annotations as much as Python allows. Types are checked
using <a href="https://mypy.readthedocs.io/en/stable/index.html#"><code>MyPy</code></a> and exported with the package
so that users can also benefit from the type system. Furthermore, with rare exceptions, <code>$λ</code>
avoids mutations and side-effects and preserves <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>.
This makes it easier for the type-checker <em>and for the user</em> to reason about the code.</p>
<h3 id="concise">Concise</h3>
<p>As we'll demonstrate in the tutorial, <code>$λ</code> provides three main syntactic shortcuts for cutting
down boilerplate:</p>
<ul>
<li>operators like <code>&gt;&gt;</code>, <code>|</code>, and <code>+</code> (and <code>&gt;=</code> if you want to get fancy)</li>
<li>the <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> decorator and the <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> object for building tree-shaped parsers</li>
<li>the <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> syntax built on top of python <code>dataclasses</code>.</li>
</ul>
<p>As a rule, <code>$λ</code> avoids reproducing python functionality and focuses on the main job of
an argument parser: parsing. Arguably, <code>$λ</code> is way more expressive than any reasonable
person would ever need&hellip; but even if it's not the parser that we need, it's the parser we deserve.</p>
<h1 id="installation">Installation</h1>
<p>You guessed it:</p>
<pre><code>pip install dollar-lambda
</code></pre>
<h1 id="tutorial">Tutorial</h1>
<p>Here is an example developed in the <code>argparse</code> tutorial:</p>
<pre><code>import argparse
parser = argparse.ArgumentParser(description=&quot;calculate X to the power of Y&quot;)
group = parser.add_mutually_exclusive_group(required=True)
group.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;)
group.add_argument(&quot;-q&quot;, &quot;--quiet&quot;, action=&quot;store_true&quot;)
parser.add_argument(&quot;x&quot;, type=int, help=&quot;the base&quot;)
parser.add_argument(&quot;y&quot;, type=int, help=&quot;the exponent&quot;)
args = parser.parse_args()
</code></pre>
<p>Here is the equivalent in this package:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
</code></pre>
<p>It succeeds for either <code>--verbose</code> or <code>--quiet</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(**p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;))
{'x': 1, 'y': 2, 'verbose': True, 'quiet': False}
&gt;&gt;&gt; main(**p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;))
{'x': 1, 'y': 2, 'verbose': False, 'quiet': True}
</code></pre>
<p>But fails for both:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--quiet&quot;)
usage: [--verbose | --quiet] -x X -y Y
x: the base
y: the exponent
Unrecognized argument: --quiet
</code></pre>
<p>And fails for neither:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)
usage: [--verbose | --quiet] -x X -y Y
x: the base
y: the exponent
Expected '--verbose'. Got '-x'
</code></pre>
<p>Let's walk through this step by step. First, let's learn what <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code>, <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> and <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> do.</p>
<h2 id="high-level-parsers">High-Level Parsers</h2>
<p>These three functions create high-level parsers. <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> binds a boolean value to a variable
whereas <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> binds an arbitrary value to a variable. <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> does not bind any values to variables,
but causes the parser to fail in some cases.</p>
<h3 id="flag"><code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code></h3>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<p>By default <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> fails when it does not receive expected input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose
</code></pre>
<p>Alternately, you can set a default value:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;, default=False).parse_args()
{'verbose': False}
</code></pre>
<h3 id="option"><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code></h3>
<p><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> is similar but takes an argument:
By default, <code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> expects a single <code>-</code> for single-character variable names (as in <code>-x</code>),
as opposed to <code>--</code> for longer names (as in <code>--xenophon</code>):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;).parse_args(&quot;-x&quot;, &quot;1&quot;)
{'x': '1'}
&gt;&gt;&gt; option(&quot;xenophon&quot;).parse_args(&quot;--xenophon&quot;, &quot;1&quot;)
{'xenophon': '1'}
</code></pre>
<p>Use the <code>type</code> argument to convert the input to a different type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;, type=int).parse_args(&quot;-x&quot;, &quot;1&quot;)  # converts &quot;1&quot; to an int
{'x': 1}
</code></pre>
<h3 id="done"><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code></h3>
<p>Without <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> the parser will not complain about leftover (unparsed) input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True}
</code></pre>
<p><code>--quiet</code> is not parsed here but this does not cause the parser to fail.
If we want to prevent leftover inputs, we can use <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) &gt;&gt; done()).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
usage: --verbose
Unrecognized argument: --quiet
</code></pre>
<p><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> is usually necessary to get <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> to behave in the way that you expect,
but more on that later.</p>
<h2 id="parser-combinators">Parser Combinators</h2>
<p>Parser combinators are functions that combine multiple parsers into new, more complex parsers.
Our example uses three such functions: <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>, <code>|</code> or <code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>,
and <code>&gt;&gt;</code> or <code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code>.</p>
<h3 id="parser__or__"><code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code></h3>
<p>The <code>|</code> operator is used for alternatives. Specifically, it will try the first parser,
and if that fails, try the second:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;) # flag(&quot;verbose&quot;) fails
{'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;) # flag(&quot;verbose&quot;) succeeds
{'verbose': True}
</code></pre>
<p>By default one of the two flags would be required to prevent failure:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args() # neither flag is provided so this fails
usage: [--verbose | --quiet]
The following arguments are required: --verbose
</code></pre>
<p>To permit the omission of both flags, use <code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty()</a></code> or supply a default value:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;) | empty()).parse_args() # flags fail, but empty() succeeds
{}
&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;, default=False)).parse_args() # flag(&quot;verbose&quot;) fails but flag(&quot;quiet&quot;, default=False) succeeds
{'quiet': False}
</code></pre>
<p>This is just sugar for</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;) | defaults(quiet=False)).parse_args() # flag(&quot;verbose&quot;) fails but flag(&quot;quiet&quot;, default=False) succeeds
{'quiet': False}
</code></pre>
<h3 id="parser__rshift__"><code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code></h3>
<p>The <code>&gt;&gt;</code> operator is used for sequential composition. It applies the first parser and then
hands the output of the first parser to the second parser. If either parser fails, the composition fails:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--something-else&quot;)  # first parser will fail
usage: --verbose
Expected '--verbose'. Got '--something-else'
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--something-else&quot;)  # second parser will fail
usage: --verbose
Unrecognized argument: --something-else
</code></pre>
<h3 id="nonpositional-and-parser__add__"><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> and <code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code></h3>
<p><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<p>For just two parsers you can use <code>+</code>, or <code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code>, instead of <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<p>This will not cover all permutations for more than two parsers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;) + option(&quot;x&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;--quiet&quot;)
usage: --verbose --quiet -x X
Expected '--quiet'. Got '-x'
</code></pre>
<p>To see why note the implicit parentheses:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (flag(&quot;verbose&quot;) + flag(&quot;quiet&quot;)) + option(&quot;x&quot;)
</code></pre>
<p>In order to cover the case where <code>-x</code> comes between <code>--verbose</code> and <code>--quiet</code>,
use <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;), option(&quot;x&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;--quiet&quot;)  # works
{'verbose': True, 'x': '1', 'quiet': True}
</code></pre>
<p>If alternatives or defaults appear among the arguments to <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>, you will probably want
to add <code>&gt;&gt;</code> followed by <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> (or another parser) after <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>. Otherwise,
the parser will not behave as expected:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # you expect this to set verbose to True, but it doesn't
{'verbose': False, 'quiet': True}
</code></pre>
<p>Why is happening? There are two permutations:</p>
<ul>
<li><code>flag("verbose", default=False) &gt;&gt; flag("quiet")</code> and</li>
<li><code>flag("quiet") &gt;&gt; flag("verbose", default=False)</code></li>
</ul>
<p>In our example, both permutations are actually succeeding. This first succeeds by falling
back to the default, and leaving the last word of the input, <code>--verbose</code>, unparsed.
Either interpretation is valid, and <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> returns one arbitrarily &ndash; just not the one we expected.</p>
<p>Now let's add <code>&gt;&gt; done()</code> to the end:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;quiet&quot;)) &gt;&gt; done()
</code></pre>
<p>This ensures that the first permutation will fail because the leftover <code>--verbose</code> input will
cause the <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> parser to fail:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)
{'quiet': True, 'verbose': True}
</code></pre>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>Let's recall the original example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
</code></pre>
<p>As we've seen <code>flag("verbose") | flag("quiet")</code> succeeds on either <code>--verbose</code> or <code>--quiet</code>
(but one or the other is required).</p>
<p><code>option("x", type=int)</code> succeeds on <code>-x X</code>, where <code>X</code> is
some integer, binding that integer to the variable <code>"x"</code>. Similarly for <code>option("y", type=int)</code>.</p>
<p><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> takes the three parsers:</p>
<ul>
<li><code>flag("verbose") | flag("quiet")</code></li>
<li><code>option("x", type=int)</code></li>
<li><code>option("y", type=int)</code></li>
</ul>
<p>and applies them in every order, until some order succeeds.
Finally <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> ensures that only one of these parser permutations will succeed, preventing ambiguity.</p>
<h2 id="alternative-syntax">Alternative syntax</h2>
<p>There are a few alternative ways to express the functionality that we've seen so far.
We will start with the most succinct, but least flexible implementation and then
demonstrate some alternatives that tradeoff succinctness for flexibility.</p>
<h3 id="command"><code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code></h3>
<p><code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> is a decorator that creates a parser automatically based on
the decorated function's signature:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(x=&quot;the base&quot;, y=&quot;the exponent&quot;))
... def main(x: int, y: int, verbose: bool = False, quiet: bool = False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-h&quot;)
usage:
    -x X
    -y Y
    --verbose
    --quiet
x: the base
y: the exponent
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'quiet': False}
</code></pre>
<p>Note that unlike our previous implementation, this will not complain if both or neither
<code>--verbose</code> and <code>--quiet</code> are given:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)
{'x': 1, 'y': 2, 'verbose': False, 'quiet': False}
&gt;&gt;&gt; main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--quiet&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'quiet': True}
</code></pre>
<h3 id="commandtree"><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code></h3>
<p>To make the flags mutually exclusive, we can use <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
</code></pre>
<p>First, we make <code>base_function</code> the root of our tree:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command(help=dict(x=&quot;the base&quot;, y=&quot;the exponent&quot;))
... def base_function(x: int, y: int):
...     print(dict(x=x, y=y))
</code></pre>
<p>Next, we make <code>verbose_function</code> a branch off of <code>base_function</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @base_function.command()
... def verbose_function(x: int, y: int, verbose: bool):
...     print(dict(x=x, y=y, verbose=verbose))
</code></pre>
<p>Note that <code>verbose_function</code> must include all the arguments from <code>base_function</code>.
And we make <code>quiet_function</code> a second branch:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @base_function.command()
... def quiet_function(x: int, y: int, quiet: bool):
...     print(dict(x=x, y=y, quiet=quiet))
</code></pre>
<p>Again we include all arguments from <code>base_function</code>.
Now we can invoke <code>tree.main</code> to dynamically dispatch the parsed arguments to the function
whose corresponding parser succeeds first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree.main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)  # this will dispatch to verbose_function
{'x': 1, 'y': 2, 'verbose': True}
&gt;&gt;&gt; tree.main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;)  # this will dispatch to quiet_function
{'x': 1, 'y': 2, 'quiet': True}
&gt;&gt;&gt; tree.main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)  # this will dispatch to base_function
{'x': 1, 'y': 2}
&gt;&gt;&gt; tree.main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbose&quot;)  # this will fail
usage: -x X -y Y [--verbose | --quiet]
x: the base
y: the exponent
Unrecognized argument: --verbose
</code></pre>
<p>To make one or the other flag required, the <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> method takes a <code>required</code> argument.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(help=dict(x=&quot;the base&quot;, y=&quot;the exponent&quot;))
... def base_function(x: int, y: int):
...     raise RuntimeError(&quot;Does not execute because children are required.&quot;)
...
&gt;&gt;&gt; @base_function.command(required=True)
... def verbose_function(x: int, y: int, verbose: bool):
...     print(dict(x=x, y=y, verbose=verbose))
...
&gt;&gt;&gt; @base_function.command(required=True)
... def quiet_function(x: int, y: int, quiet: bool):
...     print(dict(x=x, y=y, quiet=quiet))
&gt;&gt;&gt; tree.main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)  # succeeds
{'x': 1, 'y': 2, 'verbose': True}
&gt;&gt;&gt; tree.main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)  # fails
usage: -x X -y Y [--verbose | --quiet]
x: the base
y: the exponent
The following arguments are required: --verbose
</code></pre>
<p>Note that all children must be required or else <code>base_function</code> will execute in the
absence of any flags.</p>
<p><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> is especially useful when you want different parse-results to invoke different functions.
One drawback of <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> is that it cannot be freely combined with other parsers.
Parsers produced by <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> are specialized for use with decorated functions
and don't play well with more general-purpose parsers.</p>
<h3 id="args"><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code></h3>
<p><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> is a lighter-weight alternative, providing mostly syntactic sugar and a bit of logic around
the <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dataclasses import dataclass
&gt;&gt;&gt; @dataclass  # make sure not to forget this!
... class MyArgs(Args):
...    x: int = field(help=&quot;the base&quot;)
...    y: int = field(help=&quot;the exponent&quot;)
</code></pre>
<p>Make sure to import <code><a title="dollar_lambda.field" href="#dollar_lambda.field">field()</a></code> from <code><a title="dollar_lambda" href="#dollar_lambda">dollar_lambda</a></code>, not from <code>dataclasses</code>.
Now we can use <code>MyArgs.parser()</code> in combinations with other parsers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p = MyArgs.parser() + p1 &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: -x X -y Y [--verbose | --quiet]
x: the base
y: the exponent
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True}
</code></pre>
<p>You can omit the <code><a title="dollar_lambda.field" href="#dollar_lambda.field">field()</a></code> expressions:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dataclasses import dataclass
&gt;&gt;&gt; @dataclass  # make sure not to forget this!
... class MyArgs(Args):
...    x: int
...    y: int
&gt;&gt;&gt; MyArgs.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)
{'x': 1, 'y': 2}
</code></pre>
<p>But you lose help-strings:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;-h&quot;)
usage: -x X -y Y
</code></pre>
<p>The <code><a title="dollar_lambda.field" href="#dollar_lambda.field">field()</a></code> expressions can also be used to define default values:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass  # make sure not to forget this!
... class MyArgs(Args):
...    x: int = field(help=&quot;the base&quot;, default=1)
...    y: int = field(help=&quot;the exponent&quot;, default=2)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args()
{'x': 1, 'y': 2}
</code></pre>
<h2 id="variations-on-the-example">Variations on the example</h2>
<h3 id="variable-numbers-of-arguments">Variable numbers of arguments</h3>
<p>What if there was a special argument, <code>verbosity</code>,
that only makes sense if the user chooses <code>--verbose</code>?</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&quot;verbose&quot;) + option(&quot;verbosity&quot;, type=int)) | flag(&quot;quiet&quot;)),
...         option(&quot;x&quot;, type=int),
...         option(&quot;y&quot;, type=int),
...     )
...     &gt;&gt; done()
... )
</code></pre>
<p>Remember that <code>+</code> or <code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code> evaluates two parsers in both orders
and stopping at the first order that succeeds. So this allows us to
supply <code>--verbose</code> and <code>--verbosity</code> in any order.</p>
<p>Now:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--quiet&quot;)
{'x': 1, 'y': 2, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbosity&quot;, &quot;3&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3}
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
usage: [--verbose --verbosity VERBOSITY | --quiet] -x X -y Y
Expected '--verbose'. Got '-x'
</code></pre>
<p>This is also a case where you might want to use <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command(help=dict(x=&quot;the base&quot;, y=&quot;the exponent&quot;))
... def base_function(x: int, y: int):
...     print(dict(x=x, y=y))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @base_function.command()
... def verbose_function(x: int, y: int, verbose: bool, verbosity: int):
...     print(dict(x=x, y=y, verbose=verbose, verbosity=verbosity))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @base_function.command()
... def quiet_function(x: int, y: int, quiet: bool):
...     print(dict(x=x, y=y, quiet=quiet))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree.main(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbosity&quot;, &quot;3&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3}
</code></pre>
<h3 id="parsermany"><code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code></h3>
<p>What if we want to specify verbosity by the number of times that <code>--verbose</code> appears?
For this we need <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code>. Before showing how we could use <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> in this setting,
let's look at how it works.</p>
<p><code>parser.many</code> takes <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> and tries to apply it as many times as possible.
<code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> is a bit like the <code>*</code> pattern, if you are familiar with regexes.
<code>parser.many</code> always succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p.parse_args(&quot;blah&quot;)  # still succeeds
{}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;blah&quot;)  # still succeeds
{'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--verbose&quot;, return_dict=False)
[('verbose', True), ('verbose', True)]
</code></pre>
<p>As you can see, <code>return_dict=False</code> returns a list of tuples instead of a dict, so that you
can have duplicate keys.</p>
<p>Now returning to the original example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (
...     nonpositional(
...         flag(&quot;verbose&quot;).many(),
...         option(&quot;x&quot;, type=int),
...         option(&quot;y&quot;, type=int),
...     )
...     &gt;&gt; done()
... )
&gt;&gt;&gt; args = p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;, &quot;--verbose&quot;, return_dict=False)
&gt;&gt;&gt; args
[('x', 1), ('y', 2), ('verbose', True), ('verbose', True)]
&gt;&gt;&gt; verbosity = args.count(('verbose', True))
&gt;&gt;&gt; verbosity
2
</code></pre>
<h3 id="parsermany1"><code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">Parser.many1()</a></code></h3>
<p>In the previous example, the parse will default to <code>verbosity=0</code> if no <code>--verbose</code> flags
are given.
What if we wanted users to be explicit about choosing a "quiet" setting?
In other words, what if the user actually had to provide an explicit <code>--quiet</code> flag when
no <code>--verbose</code> flags were given?</p>
<p>For this, we use <code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">Parser.many1()</a></code>. This method is like <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> except that it fails
when on zero successes (recall that <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code> always succeeds). So if <code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">Parser.many()</a></code>
is like regex <code>*</code>, <code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">Parser.many1()</a></code> is like <code>+</code>. Take a look:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p = flag(&quot;verbose&quot;).many1()
&gt;&gt;&gt; p.parse_args()  # fails
usage: --verbose [--verbose ...]
The following arguments are required: --verbose
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)  # succeeds
{'verbose': True}
</code></pre>
<p>To compell that <code>--quiet</code> flag from our users, we can do the following:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&quot;verbose&quot;).many1()) | flag(&quot;quiet&quot;)),
...         option(&quot;x&quot;, type=int),
...         option(&quot;y&quot;, type=int),
...     )
...     &gt;&gt; done()
... )
</code></pre>
<p>Now omitting both <code>--verbose</code> and <code>--quiet</code> will fail:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)
usage: [--verbose [--verbose ...] | --quiet] -x X -y Y
Expected '--verbose'. Got '-x'
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;) # this succeeds
{'verbose': True, 'x': 1, 'y': 2}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;) # and this succeeds
{'quiet': True, 'x': 1, 'y': 2}
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
**$λ** This package provides an alternative to [`argparse`](https://docs.python.org/3/library/argparse.html) based on functional first principles.
This means that this package can handle many kinds of argument-parsing patterns that are either very awkward, difficult, or impossible with `argparse`.

# Why `$λ`?
`$λ` was built with minimal dependencies from functional first principles.
As a result, it is the most

- versatile
- type-safe
- and concise

argument parser on the market.

### Versatile
`$λ` provides high-level functionality equivalent to other parsers. But unlike other parsers,
it permits low-level customization to handle arbitrarily complex parsing patterns. As we&#39;ll see
in the tutorial, there are many parsing patterns that `$λ` can handle which are not possible with
other parsing libraries.
### Type-safe
`$λ` uses type annotations as much as Python allows. Types are checked
using [`MyPy`](https://mypy.readthedocs.io/en/stable/index.html#) and exported with the package
so that users can also benefit from the type system. Furthermore, with rare exceptions, `$λ`
avoids mutations and side-effects and preserves [referential transparency](https://en.wikipedia.org/wiki/Referential_transparency).
This makes it easier for the type-checker _and for the user_ to reason about the code.
### Concise
As we&#39;ll demonstrate in the tutorial, `$λ` provides three main syntactic shortcuts for cutting
down boilerplate:

- operators like `&gt;&gt;`, `|`, and `+` (and `&gt;=` if you want to get fancy)
- the `command` decorator and the `CommandTree` object for building tree-shaped parsers
- the `Args` syntax built on top of python `dataclasses`.

As a rule, `$λ` avoids reproducing python functionality and focuses on the main job of
an argument parser: parsing. Arguably, `$λ` is way more expressive than any reasonable
person would ever need... but even if it&#39;s not the parser that we need, it&#39;s the parser we deserve.

# Installation
You guessed it:
```
pip install dollar-lambda
```

# Tutorial
Here is an example developed in the `argparse` tutorial:

```
import argparse
parser = argparse.ArgumentParser(description=&#34;calculate X to the power of Y&#34;)
group = parser.add_mutually_exclusive_group(required=True)
group.add_argument(&#34;-v&#34;, &#34;--verbose&#34;, action=&#34;store_true&#34;)
group.add_argument(&#34;-q&#34;, &#34;--quiet&#34;, action=&#34;store_true&#34;)
parser.add_argument(&#34;x&#34;, type=int, help=&#34;the base&#34;)
parser.add_argument(&#34;y&#34;, type=int, help=&#34;the exponent&#34;)
args = parser.parse_args()
```

Here is the equivalent in this package:

&gt;&gt;&gt; p = nonpositional(
...     (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)),
...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)

It succeeds for either `--verbose` or `--quiet`:
&gt;&gt;&gt; main(**p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;))
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}
&gt;&gt;&gt; main(**p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;))
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: False, &#39;quiet&#39;: True}

But fails for both:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--quiet&#34;)
usage: [--verbose | --quiet] -x X -y Y
x: the base
y: the exponent
Unrecognized argument: --quiet

And fails for neither:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)
usage: [--verbose | --quiet] -x X -y Y
x: the base
y: the exponent
Expected &#39;--verbose&#39;. Got &#39;-x&#39;

Let&#39;s walk through this step by step. First, let&#39;s learn what `flag`, `option` and `done` do.

## High-Level Parsers
These three functions create high-level parsers. `flag` binds a boolean value to a variable
whereas `option` binds an arbitrary value to a variable. `done` does not bind any values to variables,
but causes the parser to fail in some cases.

### `flag`
&gt;&gt;&gt; p = flag(&#34;verbose&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
{&#39;verbose&#39;: True}

By default `flag` fails when it does not receive expected input:
&gt;&gt;&gt; p.parse_args()
usage: --verbose
The following arguments are required: --verbose

Alternately, you can set a default value:
&gt;&gt;&gt; flag(&#34;verbose&#34;, default=False).parse_args()
{&#39;verbose&#39;: False}

### `option`
`option` is similar but takes an argument:
By default, `option` expects a single `-` for single-character variable names (as in `-x`),
as opposed to `--` for longer names (as in `--xenophon`):

&gt;&gt;&gt; option(&#34;x&#34;).parse_args(&#34;-x&#34;, &#34;1&#34;)
{&#39;x&#39;: &#39;1&#39;}
&gt;&gt;&gt; option(&#34;xenophon&#34;).parse_args(&#34;--xenophon&#34;, &#34;1&#34;)
{&#39;xenophon&#39;: &#39;1&#39;}

Use the `type` argument to convert the input to a different type:
&gt;&gt;&gt; option(&#34;x&#34;, type=int).parse_args(&#34;-x&#34;, &#34;1&#34;)  # converts &#34;1&#34; to an int
{&#39;x&#39;: 1}

### `done`
Without `done` the parser will not complain about leftover (unparsed) input:

&gt;&gt;&gt; flag(&#34;verbose&#34;).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True}

`--quiet` is not parsed here but this does not cause the parser to fail.
If we want to prevent leftover inputs, we can use `done`:

&gt;&gt;&gt; (flag(&#34;verbose&#34;) &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
usage: --verbose
Unrecognized argument: --quiet

`done` is usually necessary to get `nonpositional` to behave in the way that you expect,
but more on that later.

## Parser Combinators
Parser combinators are functions that combine multiple parsers into new, more complex parsers.
Our example uses three such functions: `nonpositional`, `|` or `Parser.__or__`,
and `&gt;&gt;` or `Parser.__rshift__`.

### `Parser.__or__`

The `|` operator is used for alternatives. Specifically, it will try the first parser,
and if that fails, try the second:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;) # flag(&#34;verbose&#34;) fails
{&#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;) # flag(&#34;verbose&#34;) succeeds
{&#39;verbose&#39;: True}

By default one of the two flags would be required to prevent failure:
&gt;&gt;&gt; p.parse_args() # neither flag is provided so this fails
usage: [--verbose | --quiet]
The following arguments are required: --verbose

To permit the omission of both flags, use `empty` or supply a default value:

&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | empty()).parse_args() # flags fail, but empty() succeeds
{}
&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;, default=False)).parse_args() # flag(&#34;verbose&#34;) fails but flag(&#34;quiet&#34;, default=False) succeeds
{&#39;quiet&#39;: False}

This is just sugar for

&gt;&gt;&gt; (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;) | defaults(quiet=False)).parse_args() # flag(&#34;verbose&#34;) fails but flag(&#34;quiet&#34;, default=False) succeeds
{&#39;quiet&#39;: False}

### `Parser.__rshift__`

The `&gt;&gt;` operator is used for sequential composition. It applies the first parser and then
hands the output of the first parser to the second parser. If either parser fails, the composition fails:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;) &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
{&#39;verbose&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--something-else&#34;)  # first parser will fail
usage: --verbose
Expected &#39;--verbose&#39;. Got &#39;--something-else&#39;
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--something-else&#34;)  # second parser will fail
usage: --verbose
Unrecognized argument: --something-else

### `nonpositional` and `Parser.__add__`
`nonpositional` takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:

&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

For just two parsers you can use `+`, or `Parser.__add__`, instead of `nonpositional`:
&gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;verbose&#39;: True, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

This will not cover all permutations for more than two parsers:
&gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;) + option(&#34;x&#34;)
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;--quiet&#34;)
usage: --verbose --quiet -x X
Expected &#39;--quiet&#39;. Got &#39;-x&#39;

To see why note the implicit parentheses:
&gt;&gt;&gt; p = (flag(&#34;verbose&#34;) + flag(&#34;quiet&#34;)) + option(&#34;x&#34;)

In order to cover the case where `-x` comes between `--verbose` and `--quiet`,
use `nonpositional`:
&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;), option(&#34;x&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;--quiet&#34;)  # works
{&#39;verbose&#39;: True, &#39;x&#39;: &#39;1&#39;, &#39;quiet&#39;: True}

If alternatives or defaults appear among the arguments to `nonpositional`, you will probably want
to add `&gt;&gt;` followed by `done` (or another parser) after `nonpositional`. Otherwise,
the parser will not behave as expected:

&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;quiet&#34;))
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # you expect this to set verbose to True, but it doesn&#39;t
{&#39;verbose&#39;: False, &#39;quiet&#39;: True}

Why is happening? There are two permutations:

- `flag(&#34;verbose&#34;, default=False) &gt;&gt; flag(&#34;quiet&#34;)` and
- `flag(&#34;quiet&#34;) &gt;&gt; flag(&#34;verbose&#34;, default=False)`

In our example, both permutations are actually succeeding. This first succeeds by falling
back to the default, and leaving the last word of the input, `--verbose`, unparsed.
Either interpretation is valid, and `nonpositional` returns one arbitrarily -- just not the one we expected.

Now let&#39;s add `&gt;&gt; done()` to the end:
&gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;quiet&#34;)) &gt;&gt; done()

This ensures that the first permutation will fail because the leftover `--verbose` input will
cause the `done` parser to fail:
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)
{&#39;quiet&#39;: True, &#39;verbose&#39;: True}

## Putting it all together
Let&#39;s recall the original example:

&gt;&gt;&gt; p = nonpositional(
...     (flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)),
...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
... ) &gt;&gt; done()
...
&gt;&gt;&gt; def main(x, y, verbose=False, quiet=False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)

As we&#39;ve seen `flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)` succeeds on either `--verbose` or `--quiet`
(but one or the other is required).

`option(&#34;x&#34;, type=int)` succeeds on `-x X`, where `X` is
some integer, binding that integer to the variable `&#34;x&#34;`. Similarly for `option(&#34;y&#34;, type=int)`.

`nonpositional` takes the three parsers:

- `flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)`
- `option(&#34;x&#34;, type=int)`
- `option(&#34;y&#34;, type=int)`

and applies them in every order, until some order succeeds.
Finally `done()` ensures that only one of these parser permutations will succeed, preventing ambiguity.

## Alternative syntax
There are a few alternative ways to express the functionality that we&#39;ve seen so far.
We will start with the most succinct, but least flexible implementation and then
demonstrate some alternatives that tradeoff succinctness for flexibility.

### `command`
`command` is a decorator that creates a parser automatically based on
the decorated function&#39;s signature:

&gt;&gt;&gt; @command(help=dict(x=&#34;the base&#34;, y=&#34;the exponent&#34;))
... def main(x: int, y: int, verbose: bool = False, quiet: bool = False):
...     return dict(x=x, y=y, verbose=verbose, quiet=quiet)

&gt;&gt;&gt; main(&#34;-h&#34;)
usage:
    -x X
    -y Y
    --verbose
    --quiet
x: the base
y: the exponent

&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}

Note that unlike our previous implementation, this will not complain if both or neither
`--verbose` and `--quiet` are given:
&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: False, &#39;quiet&#39;: False}
&gt;&gt;&gt; main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--quiet&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: True}

### `CommandTree`
To make the flags mutually exclusive, we can use `CommandTree`:
&gt;&gt;&gt; tree = CommandTree()

First, we make `base_function` the root of our tree:
&gt;&gt;&gt; @tree.command(help=dict(x=&#34;the base&#34;, y=&#34;the exponent&#34;))
... def base_function(x: int, y: int):
...     print(dict(x=x, y=y))

Next, we make `verbose_function` a branch off of `base_function`:
&gt;&gt;&gt; @base_function.command()
... def verbose_function(x: int, y: int, verbose: bool):
...     print(dict(x=x, y=y, verbose=verbose))

Note that `verbose_function` must include all the arguments from `base_function`.
And we make `quiet_function` a second branch:
&gt;&gt;&gt; @base_function.command()
... def quiet_function(x: int, y: int, quiet: bool):
...     print(dict(x=x, y=y, quiet=quiet))

Again we include all arguments from `base_function`.
Now we can invoke `tree.main` to dynamically dispatch the parsed arguments to the function
whose corresponding parser succeeds first:

&gt;&gt;&gt; tree.main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)  # this will dispatch to verbose_function
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True}
&gt;&gt;&gt; tree.main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;)  # this will dispatch to quiet_function
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;quiet&#39;: True}
&gt;&gt;&gt; tree.main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)  # this will dispatch to base_function
{&#39;x&#39;: 1, &#39;y&#39;: 2}
&gt;&gt;&gt; tree.main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbose&#34;)  # this will fail
usage: -x X -y Y [--verbose | --quiet]
x: the base
y: the exponent
Unrecognized argument: --verbose

To make one or the other flag required, the `command` method takes a `required` argument.
&gt;&gt;&gt; tree = CommandTree()
...
&gt;&gt;&gt; @tree.command(help=dict(x=&#34;the base&#34;, y=&#34;the exponent&#34;))
... def base_function(x: int, y: int):
...     raise RuntimeError(&#34;Does not execute because children are required.&#34;)
...
&gt;&gt;&gt; @base_function.command(required=True)
... def verbose_function(x: int, y: int, verbose: bool):
...     print(dict(x=x, y=y, verbose=verbose))
...
&gt;&gt;&gt; @base_function.command(required=True)
... def quiet_function(x: int, y: int, quiet: bool):
...     print(dict(x=x, y=y, quiet=quiet))
&gt;&gt;&gt; tree.main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)  # succeeds
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True}
&gt;&gt;&gt; tree.main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)  # fails
usage: -x X -y Y [--verbose | --quiet]
x: the base
y: the exponent
The following arguments are required: --verbose

Note that all children must be required or else `base_function` will execute in the
absence of any flags.

`CommandTree` is especially useful when you want different parse-results to invoke different functions.
One drawback of `CommandTree` is that it cannot be freely combined with other parsers.
Parsers produced by `CommandTree` are specialized for use with decorated functions
and don&#39;t play well with more general-purpose parsers.

### `Args`

`Args` is a lighter-weight alternative, providing mostly syntactic sugar and a bit of logic around
the `nonpositional` function:

&gt;&gt;&gt; from dataclasses import dataclass
&gt;&gt;&gt; @dataclass  # make sure not to forget this!
... class MyArgs(Args):
...    x: int = field(help=&#34;the base&#34;)
...    y: int = field(help=&#34;the exponent&#34;)

Make sure to import `field` from `dollar_lambda`, not from `dataclasses`.
Now we can use `MyArgs.parser()` in combinations with other parsers:

&gt;&gt;&gt; p1 = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
&gt;&gt;&gt; p = MyArgs.parser() + p1 &gt;&gt; done()
&gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
usage: -x X -y Y [--verbose | --quiet]
x: the base
y: the exponent
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True}

You can omit the `field` expressions:
&gt;&gt;&gt; from dataclasses import dataclass
&gt;&gt;&gt; @dataclass  # make sure not to forget this!
... class MyArgs(Args):
...    x: int
...    y: int
&gt;&gt;&gt; MyArgs.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2}

But you lose help-strings:
&gt;&gt;&gt; MyArgs.parse_args(&#34;-h&#34;)
usage: -x X -y Y

The `field` expressions can also be used to define default values:

&gt;&gt;&gt; @dataclass  # make sure not to forget this!
... class MyArgs(Args):
...    x: int = field(help=&#34;the base&#34;, default=1)
...    y: int = field(help=&#34;the exponent&#34;, default=2)

&gt;&gt;&gt; MyArgs.parse_args()
{&#39;x&#39;: 1, &#39;y&#39;: 2}

## Variations on the example
### Variable numbers of arguments

What if there was a special argument, `verbosity`,
that only makes sense if the user chooses `--verbose`?

&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&#34;verbose&#34;) + option(&#34;verbosity&#34;, type=int)) | flag(&#34;quiet&#34;)),
...         option(&#34;x&#34;, type=int),
...         option(&#34;y&#34;, type=int),
...     )
...     &gt;&gt; done()
... )

Remember that `+` or `Parser.__add__` evaluates two parsers in both orders
and stopping at the first order that succeeds. So this allows us to
supply `--verbose` and `--verbosity` in any order.

Now:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--quiet&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;quiet&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbosity&#34;, &#34;3&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;verbosity&#39;: 3}
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
usage: [--verbose --verbosity VERBOSITY | --quiet] -x X -y Y
Expected &#39;--verbose&#39;. Got &#39;-x&#39;

This is also a case where you might want to use `CommandTree`:

&gt;&gt;&gt; tree = CommandTree()

&gt;&gt;&gt; @tree.command(help=dict(x=&#34;the base&#34;, y=&#34;the exponent&#34;))
... def base_function(x: int, y: int):
...     print(dict(x=x, y=y))

&gt;&gt;&gt; @base_function.command()
... def verbose_function(x: int, y: int, verbose: bool, verbosity: int):
...     print(dict(x=x, y=y, verbose=verbose, verbosity=verbosity))

&gt;&gt;&gt; @base_function.command()
... def quiet_function(x: int, y: int, quiet: bool):
...     print(dict(x=x, y=y, quiet=quiet))

&gt;&gt;&gt; tree.main(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbosity&#34;, &#34;3&#34;)
{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;verbosity&#39;: 3}

### `Parser.many`

What if we want to specify verbosity by the number of times that `--verbose` appears?
For this we need `Parser.many`. Before showing how we could use `Parser.many` in this setting,
let&#39;s look at how it works.

`parser.many` takes `parser` and tries to apply it as many times as possible.
`Parser.many` is a bit like the `*` pattern, if you are familiar with regexes.
`parser.many` always succeeds:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p.parse_args(&#34;blah&#34;)  # still succeeds
{}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;blah&#34;)  # still succeeds
{&#39;verbose&#39;: True}
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--verbose&#34;, return_dict=False)
[(&#39;verbose&#39;, True), (&#39;verbose&#39;, True)]

As you can see, `return_dict=False` returns a list of tuples instead of a dict, so that you
can have duplicate keys.

Now returning to the original example:

&gt;&gt;&gt; p = (
...     nonpositional(
...         flag(&#34;verbose&#34;).many(),
...         option(&#34;x&#34;, type=int),
...         option(&#34;y&#34;, type=int),
...     )
...     &gt;&gt; done()
... )
&gt;&gt;&gt; args = p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;, &#34;--verbose&#34;, return_dict=False)
&gt;&gt;&gt; args
[(&#39;x&#39;, 1), (&#39;y&#39;, 2), (&#39;verbose&#39;, True), (&#39;verbose&#39;, True)]
&gt;&gt;&gt; verbosity = args.count((&#39;verbose&#39;, True))
&gt;&gt;&gt; verbosity
2

### `Parser.many1`

In the previous example, the parse will default to `verbosity=0` if no `--verbose` flags
are given.  What if we wanted users to be explicit about choosing a &#34;quiet&#34; setting?
In other words, what if the user actually had to provide an explicit `--quiet` flag when
no `--verbose` flags were given?

For this, we use `Parser.many1`. This method is like `Parser.many` except that it fails
when on zero successes (recall that `Parser.many` always succeeds). So if `Parser.many`
is like regex `*`, `Parser.many1` is like `+`. Take a look:

&gt;&gt;&gt; p = flag(&#34;verbose&#34;).many()
&gt;&gt;&gt; p.parse_args()  # succeeds
{}
&gt;&gt;&gt; p = flag(&#34;verbose&#34;).many1()
&gt;&gt;&gt; p.parse_args()  # fails
usage: --verbose [--verbose ...]
The following arguments are required: --verbose
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)  # succeeds
{&#39;verbose&#39;: True}

To compell that `--quiet` flag from our users, we can do the following:

&gt;&gt;&gt; p = (
...     nonpositional(
...         ((flag(&#34;verbose&#34;).many1()) | flag(&#34;quiet&#34;)),
...         option(&#34;x&#34;, type=int),
...         option(&#34;y&#34;, type=int),
...     )
...     &gt;&gt; done()
... )

Now omitting both `--verbose` and `--quiet` will fail:
&gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)
usage: [--verbose [--verbose ...] | --quiet] -x X -y Y
Expected &#39;--verbose&#39;. Got &#39;-x&#39;
&gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;) # this succeeds
{&#39;verbose&#39;: True, &#39;x&#39;: 1, &#39;y&#39;: 2}
&gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;) # and this succeeds
{&#39;quiet&#39;: True, &#39;x&#39;: 1, &#39;y&#39;: 2}
&#34;&#34;&#34;


__pdoc__ = {}

from dollar_lambda.args import Args, field
from dollar_lambda.decorators import CommandTree, command
from dollar_lambda.parser import (
    Parser,
    apply,
    apply_item,
    argument,
    defaults,
    done,
    empty,
    equals,
    flag,
    item,
    nonpositional,
    option,
    sat,
    sat_item,
    type_,
    wrap_help,
)

__all__ = [
    &#34;Parser&#34;,
    &#34;empty&#34;,
    &#34;apply&#34;,
    &#34;apply_item&#34;,
    &#34;argument&#34;,
    &#34;done&#34;,
    &#34;equals&#34;,
    &#34;flag&#34;,
    &#34;item&#34;,
    &#34;nonpositional&#34;,
    &#34;option&#34;,
    &#34;sat&#34;,
    &#34;sat_item&#34;,
    &#34;type_&#34;,
    &#34;Args&#34;,
    &#34;defaults&#34;,
    &#34;field&#34;,
    &#34;wrap_help&#34;,
    &#34;command&#34;,
    &#34;CommandTree&#34;,
]


__pdoc__[&#34;Parser.__add__&#34;] = True
__pdoc__[&#34;Parser.__or__&#34;] = True
__pdoc__[&#34;Parser.__rshift__&#34;] = True
__pdoc__[&#34;Parser.__ge__&#34;] = True</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="dollar_lambda.args" href="args.html">dollar_lambda.args</a></code></dt>
<dd>
<div class="desc"><p>Defines the <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> dataclass and associated functions.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.decorators" href="decorators.html">dollar_lambda.decorators</a></code></dt>
<dd>
<div class="desc"><p>Defines the <code><a title="dollar_lambda.command" href="#dollar_lambda.command">command()</a></code> decorator and the <code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code> class.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.error" href="error.html">dollar_lambda.error</a></code></dt>
<dd>
<div class="desc"><p>Defines errors which can be raised by parsers.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.key_value" href="key_value.html">dollar_lambda.key_value</a></code></dt>
<dd>
<div class="desc"><p>Defines <code>KeyValue</code> which stores pairs of variable names (keys) and values.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code></dt>
<dd>
<div class="desc"><p>Defines parsing functions and the <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> class that they instantiate.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.result" href="result.html">dollar_lambda.result</a></code></dt>
<dd>
<div class="desc"><p>Defines the <code>Result</code> dataclass, representing success or failure, output by parsers.</p></div>
</dd>
<dt><code class="name"><a title="dollar_lambda.sequence" href="sequence.html">dollar_lambda.sequence</a></code></dt>
<dd>
<div class="desc"><p>Defines <code>Sequence</code>, a strongly-typed immutable list that implements <code>MonadPlus</code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dollar_lambda.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>f: Callable[[Monoid1], Result[Monoid_co]], parser: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Monoid1]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+Monoid_co]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the output of <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> and applies <code>f</code> to it. Convert any errors that arise into <code>ArgumentError</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;hello&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;--hello&quot;, return_dict=False)
[('hello', True)]
</code></pre>
<p>This will double <code>p1</code>'s output:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p2 = apply(lambda kv: Result.return_(kv + kv), p1)
&gt;&gt;&gt; p2.parse_args(&quot;--hello&quot;, return_dict=False)
[('hello', True), ('hello', True)]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(
    f: Callable[[Monoid1], Result[Monoid_co]], parser: Parser[Monoid1]
) -&gt; Parser[Monoid_co]:
    &#34;&#34;&#34;
    Takes the output of `parser` and applies `f` to it. Convert any errors that arise into `ArgumentError`.

    &gt;&gt;&gt; p1 = flag(&#34;hello&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;--hello&#34;, return_dict=False)
    [(&#39;hello&#39;, True)]

    This will double `p1`&#39;s output:
    &gt;&gt;&gt; p2 = apply(lambda kv: Result.return_(kv + kv), p1)
    &gt;&gt;&gt; p2.parse_args(&#34;--hello&#34;, return_dict=False)
    [(&#39;hello&#39;, True), (&#39;hello&#39;, True)]
    &#34;&#34;&#34;

    def g(a: Monoid1) -&gt; Parser[Monoid_co]:
        try:
            y = f(a)
        except Exception as e:
            usage = f&#34;An argument {a}: raised exception {e}&#34;
            y = Result(ArgumentError(usage))
        return Parser(
            lambda unparsed: y
            &gt;= (lambda parsed: Result.return_(Parse(parsed, unparsed))),
            usage=parser.usage,
            helps=parser.helps,
        )

    p = parser &gt;= g
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.apply_item"><code class="name flex">
<span>def <span class="ident">apply_item</span></span>(<span>f: Callable[[str], Monoid_co], description: str) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+Monoid_co]</span>
</code></dt>
<dd>
<div class="desc"><p>A shortcut for <code><a title="dollar_lambda.apply" href="#dollar_lambda.apply">apply()</a>(f, <a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a>(description))</code>
and spares <code>f</code> the trouble of outputting a <code>Result</code> object.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = argument(&quot;foo&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;bar&quot;, return_dict=False)
[('foo', 'bar')]
</code></pre>
<p>Here we use <code>f</code> to directly manipulate the binding generated by <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p2 = apply_item(lambda bar: [KeyValue(bar + &quot;e&quot;, bar + &quot;f&quot;)], description=&quot;baz&quot;)
&gt;&gt;&gt; p2.parse_args(&quot;bar&quot;, return_dict=False)
[('bare', 'barf')]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_item(f: Callable[[str], Monoid_co], description: str) -&gt; Parser[Monoid_co]:
    &#34;&#34;&#34;
    A shortcut for `apply(f, item(description))`
    and spares `f` the trouble of outputting a `Result` object.

    &gt;&gt;&gt; p1 = argument(&#34;foo&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;bar&#34;, return_dict=False)
    [(&#39;foo&#39;, &#39;bar&#39;)]

    Here we use `f` to directly manipulate the binding generated by `item`:
    &gt;&gt;&gt; p2 = apply_item(lambda bar: [KeyValue(bar + &#34;e&#34;, bar + &#34;f&#34;)], description=&#34;baz&#34;)
    &gt;&gt;&gt; p2.parse_args(&#34;bar&#34;, return_dict=False)
    [(&#39;bare&#39;, &#39;barf&#39;)]
    &#34;&#34;&#34;

    def g(parsed: Sequence[KeyValue[str]]) -&gt; Result[Monoid_co]:
        [kv] = parsed
        try:
            y = f(kv.value)
        except Exception as e:
            usage = f&#34;argument {kv.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        return Result.return_(y)

    return apply(g, item(description))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.argument"><code class="name flex">
<span>def <span class="ident">argument</span></span>(<span>dest: str) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a single word and binds it to <code>dest</code>.
Useful for positional arguments.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;name&quot;).parse_args(&quot;Alice&quot;)
{'name': 'Alice'}
&gt;&gt;&gt; argument(&quot;name&quot;).parse_args()
usage: name
The following arguments are required: name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def argument(dest: str) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    Parses a single word and binds it to `dest`.
    Useful for positional arguments.

    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; argument(&#34;name&#34;).parse_args()
    usage: name
    The following arguments are required: name
    &#34;&#34;&#34;
    return item(dest)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>flip_bools: bool = True, help: Optional[Dict[str, str]] = None, strings: Optional[Dict[str, str]] = None, types: Optional[Dict[str, Callable[[str], Any]]] = None) ‑> Callable[[Callable], Callable]</span>
</code></dt>
<dd>
<div class="desc"><p>A succinct way to generate a simple <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> parser. <code>@command</code> derives the
component parsers from the function's signature and automatically executes the function with
the parsed arguments, if parsing succeeds:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(a=&quot;something about a&quot;), types=dict(a=lambda x: int(x) + 1))
... def f(a: int = 1, b: bool = False):
...     return dict(a=a, b=b)
&gt;&gt;&gt; f(&quot;-a&quot;, &quot;2&quot;, &quot;-b&quot;)
{'a': 3, 'b': True}
</code></pre>
<p>If the wrapped function receives no arguments (as in <code>f()</code>), the parser will take
<code>sys.argv[1:]</code> as the input.</p>
<p>Note that <code>@command</code> does not handle mutually exclusive arguments or alternative
arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>flip_bools</code></strong> :&ensp;<code>bool</code></dt>
<dd>For boolean arguments that default to true, this changes the flag from <code>--{dest}</code> to <code>--no-{dest}</code>:</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(flip_bools=True)
... def f(cuda: bool = True):
...     return dict(cuda=cuda)
&gt;&gt;&gt; f()
{'cuda': True}
&gt;&gt;&gt; f(&quot;--no-cuda&quot;)
{'cuda': False}
</code></pre>
<p>As the following example demonstrates, when <code>flip_bools=False</code> output can be somewhat confusing:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(flip_bools=False)
... def f(cuda: bool = True):
...     return dict(cuda=cuda)
&gt;&gt;&gt; f(&quot;--cuda&quot;)
{'cuda': False}
</code></pre>
<dl>
<dt><strong><code>help</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>A dictionary of help strings for the arguments.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(quiet=&quot;Be quiet&quot;))
... def f(quiet: bool):
...     return dict(quiet=quiet)
&gt;&gt;&gt; f(&quot;--help&quot;)
**```usage```** :&amp;ensp;`--quiet`
:   &amp;nbsp;


**```quiet```** :&amp;ensp;&lt;code&gt;Be quiet&lt;/code&gt;
:   &amp;nbsp;


</code></pre>
<dl>
<dt><strong><code>strings</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>This dictionary maps variable names to the strings that the parser will look for in the input. For example:</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(strings=dict(quiet=&quot;--quiet-mode&quot;))
... def f(quiet: bool):
...     return dict(quiet=quiet)
&gt;&gt;&gt; f(&quot;--quiet-mode&quot;)
{'quiet': True}
&gt;&gt;&gt; f(&quot;--quiet&quot;)
**```usage```** :&amp;ensp;`--quiet-mode`
:   &amp;nbsp;


Expected '--quiet-mode'. Got '--quiet'
</code></pre>
<dl>
<dt><strong><code>types</code></strong> :&ensp;<code>dict[str, Callable[[str], Any]]</code></dt>
<dd>This dictionary maps variable names to custom type converters. For example:</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; @command(types=dict(x=lambda x: int(x) + 1))
... def f(x: int):
...     return dict(x=x)
&gt;&gt;&gt; f(&quot;-x&quot;, &quot;0&quot;)
{'x': 1}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    strings: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable[[Callable], Callable]:
    &#34;&#34;&#34;
    A succinct way to generate a simple `nonpositional` parser. `@command` derives the
    component parsers from the function&#39;s signature and automatically executes the function with
    the parsed arguments, if parsing succeeds:

    &gt;&gt;&gt; @command(help=dict(a=&#34;something about a&#34;), types=dict(a=lambda x: int(x) + 1))
    ... def f(a: int = 1, b: bool = False):
    ...     return dict(a=a, b=b)
    &gt;&gt;&gt; f(&#34;-a&#34;, &#34;2&#34;, &#34;-b&#34;)
    {&#39;a&#39;: 3, &#39;b&#39;: True}

    If the wrapped function receives no arguments (as in `f()`), the parser will take
    `sys.argv[1:]` as the input.

    Note that `@command` does not handle mutually exclusive arguments or alternative
    arguments.

    Parameters
    ----------
    flip_bools : bool
        For boolean arguments that default to true, this changes the flag from `--{dest}` to `--no-{dest}`:

    &gt;&gt;&gt; @command(flip_bools=True)
    ... def f(cuda: bool = True):
    ...     return dict(cuda=cuda)
    &gt;&gt;&gt; f()
    {&#39;cuda&#39;: True}
    &gt;&gt;&gt; f(&#34;--no-cuda&#34;)
    {&#39;cuda&#39;: False}

    As the following example demonstrates, when `flip_bools=False` output can be somewhat confusing:

    &gt;&gt;&gt; @command(flip_bools=False)
    ... def f(cuda: bool = True):
    ...     return dict(cuda=cuda)
    &gt;&gt;&gt; f(&#34;--cuda&#34;)
    {&#39;cuda&#39;: False}

    help : dict[str, str]
        A dictionary of help strings for the arguments.

    &gt;&gt;&gt; @command(help=dict(quiet=&#34;Be quiet&#34;))
    ... def f(quiet: bool):
    ...     return dict(quiet=quiet)
    &gt;&gt;&gt; f(&#34;--help&#34;)
    usage: --quiet
    quiet: Be quiet

    strings : dict[str, str]
        This dictionary maps variable names to the strings that the parser will look for in the input. For example:

    &gt;&gt;&gt; @command(strings=dict(quiet=&#34;--quiet-mode&#34;))
    ... def f(quiet: bool):
    ...     return dict(quiet=quiet)
    &gt;&gt;&gt; f(&#34;--quiet-mode&#34;)
    {&#39;quiet&#39;: True}
    &gt;&gt;&gt; f(&#34;--quiet&#34;)
    usage: --quiet-mode
    Expected &#39;--quiet-mode&#39;. Got &#39;--quiet&#39;

    types: dict[str, Callable[[str], Any]]
        This dictionary maps variable names to custom type converters. For example:

    &gt;&gt;&gt; @command(types=dict(x=lambda x: int(x) + 1))
    ... def f(x: int):
    ...     return dict(x=x)
    &gt;&gt;&gt; f(&#34;-x&#34;, &#34;0&#34;)
    {&#39;x&#39;: 1}
    &#34;&#34;&#34;

    def wrapper(func: Callable) -&gt; Callable:
        p = (
            _func_to_parser(
                func, flip_bools=flip_bools, help=help, strings=strings, types=types
            )
            &gt;&gt; done()
        )
        p = wrap_help(p)

        def wrapped(*args) -&gt; Any:
            parsed = p.parse_args(*args)
            if parsed is None:
                return
            assert isinstance(parsed, Dict), parsed
            return func(**parsed)

        return wrapped

    return wrapper</code></pre>
</details>
</dd>
<dt id="dollar_lambda.defaults"><code class="name flex">
<span>def <span class="ident">defaults</span></span>(<span>**kwargs: Any) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Useful for assigning default values to arguments.
It ignore the input and always returns <code>kwargs</code> converted into <code>Sequence[KeyValue]</code>.
<code><a title="dollar_lambda.defaults" href="#dollar_lambda.defaults">defaults()</a></code> never fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; defaults(a=1, b=2).parse_args()
{'a': 1, 'b': 2}
&gt;&gt;&gt; (flag(&quot;fails&quot;) | defaults(fails=&quot;succeeds&quot;)).parse_args()
{'fails': 'succeeds'}
</code></pre>
<p>Here's a more complex example derived from the tutorial:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(
...     (
...         flag(&quot;verbose&quot;) + defaults(quiet=False)  # either --verbose and default &quot;quiet&quot; to False
...         | flag(&quot;quiet&quot;) + defaults(verbose=False)  # or --quiet and default &quot;verbose&quot; to False
...     ),
...     option(&quot;x&quot;, type=int, help=&quot;the base&quot;),
...     option(&quot;y&quot;, type=int, help=&quot;the exponent&quot;),
... ) &gt;&gt; done()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;, &quot;--verbose&quot;)
{'x': 1, 'y': 2, 'verbose': True, 'quiet': False}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defaults(**kwargs: Any) -&gt; Parser[Sequence[KeyValue[Any]]]:
    &#34;&#34;&#34;
    Useful for assigning default values to arguments.
    It ignore the input and always returns `kwargs` converted into `Sequence[KeyValue]`.
    `defaults` never fails.

    &gt;&gt;&gt; defaults(a=1, b=2).parse_args()
    {&#39;a&#39;: 1, &#39;b&#39;: 2}
    &gt;&gt;&gt; (flag(&#34;fails&#34;) | defaults(fails=&#34;succeeds&#34;)).parse_args()
    {&#39;fails&#39;: &#39;succeeds&#39;}

    Here&#39;s a more complex example derived from the tutorial:
    &gt;&gt;&gt; p = nonpositional(
    ...     (
    ...         flag(&#34;verbose&#34;) + defaults(quiet=False)  # either --verbose and default &#34;quiet&#34; to False
    ...         | flag(&#34;quiet&#34;) + defaults(verbose=False)  # or --quiet and default &#34;verbose&#34; to False
    ...     ),
    ...     option(&#34;x&#34;, type=int, help=&#34;the base&#34;),
    ...     option(&#34;y&#34;, type=int, help=&#34;the exponent&#34;),
    ... ) &gt;&gt; done()

    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;, &#34;--verbose&#34;)
    {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;verbose&#39;: True, &#39;quiet&#39;: False}
    &#34;&#34;&#34;
    p = Parser.return_(Sequence([KeyValue(k, v) for k, v in kwargs.items()]))
    return replace(p, usage=None)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.done"><code class="name flex">
<span>def <span class="ident">done</span></span>(<span>) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> succeds on the end of input and fails on everything else.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; done().parse_args()
{}
&gt;&gt;&gt; done().parse_args(&quot;arg&quot;)
Unrecognized argument: arg
</code></pre>
<p>Without <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> the parser will not complain about leftover (unparsed) input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True}
</code></pre>
<p><code>--quiet</code> is not parsed here but this does not cause the parser to fail.
If we want to prevent leftover inputs, we can use <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (flag(&quot;verbose&quot;) &gt;&gt; done()).parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
usage: --verbose
Unrecognized argument: --quiet
</code></pre>
<p><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> is usually necessary to get <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> to behave in the way that you expect.
See <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> API docs for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done() -&gt; Parser[Sequence[A]]:
    &#34;&#34;&#34;
    `done` succeds on the end of input and fails on everything else.
    &gt;&gt;&gt; done().parse_args()
    {}
    &gt;&gt;&gt; done().parse_args(&#34;arg&#34;)
    Unrecognized argument: arg

    Without `done` the parser will not complain about leftover (unparsed) input:

    &gt;&gt;&gt; flag(&#34;verbose&#34;).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
    {&#39;verbose&#39;: True}

    `--quiet` is not parsed here but this does not cause the parser to fail.
    If we want to prevent leftover inputs, we can use `done`:

    &gt;&gt;&gt; (flag(&#34;verbose&#34;) &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
    usage: --verbose
    Unrecognized argument: --quiet

    `done` is usually necessary to get `nonpositional` to behave in the way that you expect.
    See `nonpositional` API docs for details.
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[Sequence[A]]]:
        if cs:
            c, *_ = cs
            return Result(
                UnexpectedError(unexpected=c, usage=f&#34;Unrecognized argument: {c}&#34;)
            )
        return Result(NonemptyList(Parse(parsed=Sequence([]), unparsed=cs)))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Always returns {}, no matter the input. Mostly useful for use in <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; empty().parse_args(&quot;any&quot;, &quot;arguments&quot;)
{}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty() -&gt; Parser[Sequence]:
    &#34;&#34;&#34;
    Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
    &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
    {}
    &#34;&#34;&#34;
    return Parser[Sequence[A]].empty()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.equals"><code class="name flex">
<span>def <span class="ident">equals</span></span>(<span>s: str, peak=False) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the next word is <code>s</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; equals(&quot;hello&quot;).parse_args(&quot;hello&quot;)
{'hello': 'hello'}
&gt;&gt;&gt; equals(&quot;hello&quot;).parse_args(&quot;goodbye&quot;)
usage: hello
Expected 'hello'. Got 'goodbye'
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>peak</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>False</code>, then the parser will consume the word and return the remaining words as <code>unparsed</code>.
If <code>True</code>, then the parser leaves the <code>unparsed</code> component unchanged.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = equals(&quot;hello&quot;) &gt;&gt; equals(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
{'hello': 'hello', 'goodbye': 'goodbye'}
</code></pre>
<p>Look what happens when <code>peak=True</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = equals(&quot;hello&quot;, peak=True) &gt;&gt; equals(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
**```usage```** :&amp;ensp;&lt;code&gt;hello goodbye&lt;/code&gt;
:   &amp;nbsp;


Expected 'goodbye'. Got 'hello'
</code></pre>
<p>The first parser didn't consume the word and so "hello" got passed on to <code>equals("goodbye")</code>.
But this would work:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = equals(&quot;hello&quot;, peak=True) &gt;&gt; equals(&quot;hello&quot;) &gt;&gt;equals(&quot;goodbye&quot;)
&gt;&gt;&gt; p.parse_args(&quot;hello&quot;, &quot;goodbye&quot;)
{'hello': 'hello', 'goodbye': 'goodbye'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equals(s: str, peak=False) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    Checks if the next word is `s`.

    &gt;&gt;&gt; equals(&#34;hello&#34;).parse_args(&#34;hello&#34;)
    {&#39;hello&#39;: &#39;hello&#39;}
    &gt;&gt;&gt; equals(&#34;hello&#34;).parse_args(&#34;goodbye&#34;)
    usage: hello
    Expected &#39;hello&#39;. Got &#39;goodbye&#39;

    Parameters
    ----------
    peak : bool
        If `False`, then the parser will consume the word and return the remaining words as `unparsed`.
        If `True`, then the parser leaves the `unparsed` component unchanged.

    &gt;&gt;&gt; p = equals(&#34;hello&#34;) &gt;&gt; equals(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    {&#39;hello&#39;: &#39;hello&#39;, &#39;goodbye&#39;: &#39;goodbye&#39;}

    Look what happens when `peak=True`:
    &gt;&gt;&gt; p = equals(&#34;hello&#34;, peak=True) &gt;&gt; equals(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    usage: hello goodbye
    Expected &#39;goodbye&#39;. Got &#39;hello&#39;

    The first parser didn&#39;t consume the word and so &#34;hello&#34; got passed on to `equals(&#34;goodbye&#34;)`.
    But this would work:
    &gt;&gt;&gt; p = equals(&#34;hello&#34;, peak=True) &gt;&gt; equals(&#34;hello&#34;) &gt;&gt;equals(&#34;goodbye&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;hello&#34;, &#34;goodbye&#34;)
    {&#39;hello&#39;: &#39;hello&#39;, &#39;goodbye&#39;: &#39;goodbye&#39;}
    &#34;&#34;&#34;
    if peak:
        return sat_peak(
            predicate=lambda _s: _s == s,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )
    else:
        return sat_item(
            predicate=lambda _s: _s == s,
            on_fail=lambda _s: UnequalError(
                left=s, right=_s, usage=f&#34;Expected &#39;{s}&#39;. Got &#39;{_s}&#39;&#34;
            ),
            name=s,
        )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.field"><code class="name flex">
<span>def <span class="ident">field</span></span>(<span>help: Optional[str] = None, metadata: Optional[dict] = None, type: Union[type, Callable[[str], Any], ForwardRef(None)] = None, **kwargs) ‑> dataclasses.Field</span>
</code></dt>
<dd>
<div class="desc"><p>This is a thin wrapper around <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.field</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>help</code></strong> :&ensp;<code>str</code></dt>
<dd>An optional help string for the argument.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>str</code></dt>
<dd>Identical to the <code>metadata</code> argument for <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.field</code></a>.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Optional[Union[type, Callable[[str], Any]]]</code></dt>
<dd>A function that takes a string and returns a value just like the <code>type</code> argument for
<a href="https://docs.python.org/3/library/argparse.html#type"><code>ArgumentParser.add_argument</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>dataclasses.Field</code> object that can be used in place of a default argument as
described in the <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field"><code>dataclasses.Field</code> documentation</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field(
    help: Optional[str] = None,
    metadata: Optional[dict] = None,
    type: Optional[Union[type, Callable[[str], Any]]] = None,
    **kwargs,
) -&gt; Field:
    &#34;&#34;&#34;
    This is a thin wrapper around [`dataclasses.field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).

    Parameters
    ----------
    help : str
        An optional help string for the argument.
    metadata : str
        Identical to the `metadata` argument for [`dataclasses.field`](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).
    type : Optional[Union[type, Callable[[str], Any]]]
        A function that takes a string and returns a value just like the `type` argument for
        [`ArgumentParser.add_argument`](https://docs.python.org/3/library/argparse.html#type).

    Returns
    -------
    A `dataclasses.Field` object that can be used in place of a default argument as
    described in the [`dataclasses.Field` documentation](https://docs.python.org/3/library/dataclasses.html#dataclasses.field).

    &#34;&#34;&#34;
    if metadata is None:
        metadata = {}
    if type is not None:
        metadata.update(type=type)
    if help is not None:
        metadata.update(help=help)
    return dataclasses.field(metadata=metadata, **kwargs)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.flag"><code class="name flex">
<span>def <span class="ident">flag</span></span>(<span>dest: str, default: Optional[bool] = None, help: Optional[str] = None, short: bool = True, string: Optional[str] = None) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[bool]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Binds a boolean value to a variable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>The variable to which the value will be bound.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<dl>
<dt><strong><code>default</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>An optional default value.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;, default=False)
&gt;&gt;&gt; p.parse_args()
{'verbose': False}
</code></pre>
<p>By default <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> fails when it does not receive expected input:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args()
**```usage```** :&amp;ensp;`--verbose`
:   &amp;nbsp;


The following arguments are required: --verbose
</code></pre>
<dl>
<dt><strong><code>help</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>An optional help string.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;, help=&quot;Turn on verbose output.&quot;)
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
**```usage```** :&amp;ensp;`--verbose`
:   &amp;nbsp;


verbose: Turn on verbose output.
</code></pre>
<dl>
<dt><strong><code>short</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to check for the short form of the flag, which
uses a single dash and the first character of <code>dest</code>, e.g. <code>-f</code> for <code>foo</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;verbose&quot;, short=True).parse_args(&quot;-v&quot;)  # this is the default
{'verbose': True}
&gt;&gt;&gt; flag(&quot;verbose&quot;, short=False).parse_args(&quot;-v&quot;)  # fails
**```usage```** :&amp;ensp;`--verbose`
:   &amp;nbsp;


Expected '--verbose'. Got '-v'
</code></pre>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>A custom string to use for the flag. Defaults to <code>--{dest}</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; flag(&quot;value&quot;, string=&quot;v&quot;).parse_args(&quot;v&quot;)  # note that string does not have to start with -
{'value': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flag(
    dest: str,
    default: Optional[bool] = None,
    help: Optional[str] = None,
    short: bool = True,
    string: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[bool]]]:
    &#34;&#34;&#34;
    Binds a boolean value to a variable.

    Parameters
    ----------
    dest : str
        The variable to which the value will be bound.

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}

    default : Optional[bool]
        An optional default value.

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, default=False)
    &gt;&gt;&gt; p.parse_args()
    {&#39;verbose&#39;: False}

    By default `flag` fails when it does not receive expected input:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args()
    usage: --verbose
    The following arguments are required: --verbose

    help : Optional[str]
        An optional help string.

    &gt;&gt;&gt; p = flag(&#34;verbose&#34;, help=&#34;Turn on verbose output.&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --verbose
    verbose: Turn on verbose output.

    short : bool
        Whether to check for the short form of the flag, which
        uses a single dash and the first character of `dest`, e.g. `-f` for `foo`.

    &gt;&gt;&gt; flag(&#34;verbose&#34;, short=True).parse_args(&#34;-v&#34;)  # this is the default
    {&#39;verbose&#39;: True}
    &gt;&gt;&gt; flag(&#34;verbose&#34;, short=False).parse_args(&#34;-v&#34;)  # fails
    usage: --verbose
    Expected &#39;--verbose&#39;. Got &#39;-v&#39;

    string : Optional[str]
        A custom string to use for the flag. Defaults to `--{dest}`.

    &gt;&gt;&gt; flag(&#34;value&#34;, string=&#34;v&#34;).parse_args(&#34;v&#34;)  # note that string does not have to start with -
    {&#39;value&#39;: True}
    &#34;&#34;&#34;
    if string is None:
        _string = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _string = string

    def f(
        cs: Sequence[str],
        s: str,
    ) -&gt; Result[Parse[Sequence[KeyValue[bool]]]]:
        parser = equals(s) &gt;= (lambda _: defaults(**{dest: not default}))
        return parser.parse(cs)

    parser = Parser(partial(f, s=_string), usage=None, helps={})
    if short:
        short_string = f&#34;-{dest[0]}&#34;
        parser2 = flag(dest, short=False, string=short_string, default=default)
        parser = parser | parser2
    if default:
        help = f&#34;{help + &#39; &#39; if help else &#39;&#39;}(default: {default})&#34;
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=_string, helps=helps)
    return parser if default is None else parser | defaults(**{dest: default})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.item"><code class="name flex">
<span>def <span class="ident">item</span></span>(<span>name: str, help_name: Optional[str] = None) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a single word and binds it to <code>dest</code>.
One of the lowest level building blocks for parsers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>help_name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Used for generating help text</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = item(&quot;name&quot;, help_name=&quot;Your first name&quot;)
&gt;&gt;&gt; p.parse_args(&quot;Alice&quot;)
{'name': 'Alice'}
&gt;&gt;&gt; p.parse_args()
**```usage```** :&amp;ensp;&lt;code&gt;name&lt;/code&gt;
:   &amp;nbsp;


The following arguments are required: Your first name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item(
    name: str,
    help_name: Optional[str] = None,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    Parses a single word and binds it to `dest`.
    One of the lowest level building blocks for parsers.

    Parameters
    ----------
    help_name : Optional[str]
        Used for generating help text

    &gt;&gt;&gt; p = item(&#34;name&#34;, help_name=&#34;Your first name&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;Alice&#34;)
    {&#39;name&#39;: &#39;Alice&#39;}
    &gt;&gt;&gt; p.parse_args()
    usage: name
    The following arguments are required: Your first name
    &#34;&#34;&#34;

    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        if cs:
            head, *tail = cs
            return Result(
                NonemptyList(
                    Parse(
                        parsed=Sequence([KeyValue(name, head)]),
                        unparsed=Sequence(tail),
                    )
                )
            )
        return Result(
            MissingError(
                missing=name,
                usage=f&#34;The following arguments are required: {help_name or name}&#34;,
            )
        )

    return Parser(f, usage=name, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.nonpositional"><code class="name flex">
<span>def <span class="ident">nonpositional</span></span>(<span>*parsers: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]]'") ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> takes a sequence of parsers as arguments and attempts all permutations of them,
returning the first permutations that is successful:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;)
{'verbose': True, 'quiet': True}
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # reverse order also works
{'quiet': True, 'verbose': True}
</code></pre>
<p>If alternatives or defaults appear among the arguments to <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>, you will probably want
to add <code>&gt;&gt;</code> followed by <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> (or another parser) after <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>. Otherwise,
the parser will not behave as expected:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;quiet&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)  # you expect this to set verbose to True, but it doesn't
{'verbose': False, 'quiet': True}
</code></pre>
<p>Why is happening? There are two permutations:</p>
<ul>
<li><code>flag("verbose", default=False) &gt;&gt; flag("quiet")</code> and</li>
<li><code>flag("quiet") &gt;&gt; flag("verbose", default=False)</code></li>
</ul>
<p>In our example, both permutations are actually succeeding. This first succeeds by falling
back to the default, and leaving the last word of the input, <code>--verbose</code>, unparsed.
Either interpretation is valid, and <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> returns one arbitrarily &ndash; just not the one we expected.</p>
<p>Now let's add <code>&gt;&gt; done()</code> to the end:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;verbose&quot;, default=False), flag(&quot;quiet&quot;)) &gt;&gt; done()
</code></pre>
<p>This ensures that the first permutation will fail because the leftover <code>--verbose</code> input will
cause the <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> parser to fail:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--quiet&quot;, &quot;--verbose&quot;)
{'quiet': True, 'verbose': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nonpositional(*parsers: &#34;Parser[Sequence[A]]&#34;) -&gt; &#34;Parser[Sequence[A]]&#34;:
    &#34;&#34;&#34;
    `nonpositional` takes a sequence of parsers as arguments and attempts all permutations of them,
    returning the first permutations that is successful:

    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;), flag(&#34;quiet&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;)
    {&#39;verbose&#39;: True, &#39;quiet&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # reverse order also works
    {&#39;quiet&#39;: True, &#39;verbose&#39;: True}

    If alternatives or defaults appear among the arguments to `nonpositional`, you will probably want
    to add `&gt;&gt;` followed by `done` (or another parser) after `nonpositional`. Otherwise,
    the parser will not behave as expected:

    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;quiet&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)  # you expect this to set verbose to True, but it doesn&#39;t
    {&#39;verbose&#39;: False, &#39;quiet&#39;: True}

    Why is happening? There are two permutations:

    - `flag(&#34;verbose&#34;, default=False) &gt;&gt; flag(&#34;quiet&#34;)` and
    - `flag(&#34;quiet&#34;) &gt;&gt; flag(&#34;verbose&#34;, default=False)`

    In our example, both permutations are actually succeeding. This first succeeds by falling
    back to the default, and leaving the last word of the input, `--verbose`, unparsed.
    Either interpretation is valid, and `nonpositional` returns one arbitrarily -- just not the one we expected.

    Now let&#39;s add `&gt;&gt; done()` to the end:
    &gt;&gt;&gt; p = nonpositional(flag(&#34;verbose&#34;, default=False), flag(&#34;quiet&#34;)) &gt;&gt; done()

    This ensures that the first permutation will fail because the leftover `--verbose` input will
    cause the `done` parser to fail:
    &gt;&gt;&gt; p.parse_args(&#34;--quiet&#34;, &#34;--verbose&#34;)
    {&#39;quiet&#39;: True, &#39;verbose&#39;: True}
    &#34;&#34;&#34;
    if not parsers:
        return empty()

    def get_alternatives():
        for i, head in enumerate(parsers):
            tail = [p for j, p in enumerate(parsers) if j != i]
            yield head &gt;&gt; nonpositional(*tail)

    parser = reduce(operator.or_, get_alternatives())
    sep = &#34; &#34; if len(parsers) &lt;= 3 else &#34;\n&#34;
    return replace(parser, usage=sep.join([p.usage or &#34;&#34; for p in parsers]))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.option"><code class="name flex">
<span>def <span class="ident">option</span></span>(<span>dest: str, flag: Optional[str] = None, default: Any = None, help: Optional[str] = None, short: bool = True, type: Callable[[str], Any] = builtins.str) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses two words, binding the second to the first.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of variable to bind to:</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;).parse_args(&quot;--count&quot;, &quot;1&quot;)
{'count': '1'}
</code></pre>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The flag to use for the option. If not provided, defaults to <code>--{dest}</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, flag=&quot;ct&quot;).parse_args(&quot;ct&quot;, &quot;1&quot;)  # note that flag need not begin with -
{'count': '1'}
</code></pre>
<dl>
<dt><strong><code>default</code></strong> :&ensp;<code>Optional[Any]</code></dt>
<dd>The default value to bind on failure:</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, default=2).parse_args()  # note that default can be any type
{'count': 2}
</code></pre>
<dl>
<dt><strong><code>help</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The help message to display for the option:</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, help=&quot;The number we should count to&quot;).parse_args(&quot;-h&quot;)
**```usage```** :&amp;ensp;`--count COUNT`
:   &amp;nbsp;


**```count```** :&amp;ensp;&lt;code&gt;The number we should count to&lt;/code&gt;
:   &amp;nbsp;


</code></pre>
<dl>
<dt><strong><code>short</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to check for the short form of the flag, which
uses a single dash and the first character of <code>dest</code>, e.g. <code>-c</code> for <code>count</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;count&quot;, short=True).parse_args(&quot;-c&quot;, &quot;1&quot;)
{'count': '1'}
&gt;&gt;&gt; option(&quot;count&quot;, short=False).parse_args(&quot;-c&quot;, &quot;1&quot;)
**```usage```** :&amp;ensp;`--count COUNT`
:   &amp;nbsp;


Expected '--count'. Got '-c'
</code></pre>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>Callable[[str], Any]</code></dt>
<dd>Use the <code>type</code> argument to convert the input to a different type:</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; option(&quot;x&quot;, type=int).parse_args(&quot;-x&quot;, &quot;1&quot;)  # converts &quot;1&quot; to an int
{'x': 1}
&gt;&gt;&gt; option(&quot;x&quot;, type=lambda x: int(x) + 1).parse_args(&quot;-x&quot;, &quot;1&quot;)
{'x': 2}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def option(
    dest: str,
    flag: Optional[str] = None,
    default: Any = None,
    help: Optional[str] = None,
    short: bool = True,
    type: Callable[[str], Any] = str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    Parses two words, binding the second to the first.

    Parameters
    ----------
    dest : str
        The name of variable to bind to:

    &gt;&gt;&gt; option(&#34;count&#34;).parse_args(&#34;--count&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}

    flag : Optional[str]
        The flag to use for the option. If not provided, defaults to `--{dest}`.

    &gt;&gt;&gt; option(&#34;count&#34;, flag=&#34;ct&#34;).parse_args(&#34;ct&#34;, &#34;1&#34;)  # note that flag need not begin with -
    {&#39;count&#39;: &#39;1&#39;}

    default : Optional[Any]
        The default value to bind on failure:
    &gt;&gt;&gt; option(&#34;count&#34;, default=2).parse_args()  # note that default can be any type
    {&#39;count&#39;: 2}

    help : Optional[str]
        The help message to display for the option:
    &gt;&gt;&gt; option(&#34;count&#34;, help=&#34;The number we should count to&#34;).parse_args(&#34;-h&#34;)
    usage: --count COUNT
    count: The number we should count to

    short : bool
        Whether to check for the short form of the flag, which
        uses a single dash and the first character of `dest`, e.g. `-c` for `count`.

    &gt;&gt;&gt; option(&#34;count&#34;, short=True).parse_args(&#34;-c&#34;, &#34;1&#34;)
    {&#39;count&#39;: &#39;1&#39;}
    &gt;&gt;&gt; option(&#34;count&#34;, short=False).parse_args(&#34;-c&#34;, &#34;1&#34;)
    usage: --count COUNT
    Expected &#39;--count&#39;. Got &#39;-c&#39;

    type : Callable[[str], Any]
        Use the `type` argument to convert the input to a different type:

    &gt;&gt;&gt; option(&#34;x&#34;, type=int).parse_args(&#34;-x&#34;, &#34;1&#34;)  # converts &#34;1&#34; to an int
    {&#39;x&#39;: 1}
    &gt;&gt;&gt; option(&#34;x&#34;, type=lambda x: int(x) + 1).parse_args(&#34;-x&#34;, &#34;1&#34;)
    {&#39;x&#39;: 2}
    &#34;&#34;&#34;

    if flag is None:
        _flag = f&#34;--{dest}&#34; if len(dest) &gt; 1 else f&#34;-{dest}&#34;
    else:
        _flag = flag

    def f(
        cs: Sequence[str],
    ) -&gt; Result[Parse[Sequence[KeyValue[str]]]]:
        parser = equals(_flag) &gt;= (lambda _: item(dest, help_name=dest.upper()))
        return parser.parse(cs)

    parser = Parser(f, usage=None, helps={})
    if type is not str:
        parser = type_(type, parser)
    if short and len(dest) &gt; 1:
        parser2 = option(dest=dest, short=False, flag=f&#34;-{dest[0]}&#34;, default=None)
        parser = parser | parser2
    helps = {dest: help} if help else {}
    parser = replace(parser, usage=f&#34;{_flag} {dest.upper()}&#34;, helps=helps)
    return parser if default is None else parser | defaults(**{dest: default})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.sat"><code class="name flex">
<span>def <span class="ident">sat</span></span>(<span>parser: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Monoid1], predicate: Callable[[Monoid1], bool], on_fail: Callable[[Monoid1], ArgumentError]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~Monoid1]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>, applies a predicate to the result and fails if this returns false.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = sat(
...     option(&quot;x&quot;, type=int).many(),
...     lambda kvs: sum([kv.value for kv in kvs]) &gt; 0,
...     lambda x: ArgumentError(f&quot;The values in {list(x)} must sum to more than 0.&quot;),
... )
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-1&quot;, &quot;-x&quot;, &quot;1&quot;)  # fails
usage: [-x X ...]
The values in [KeyValue(key='x', value=-1), KeyValue(key='x', value=1)] must sum to more than 0.
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;-1&quot;, &quot;-x&quot;, &quot;2&quot;)  # succeeds
{'x': 2}
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parser</code></strong> :&ensp;<code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Monoid1]</code></dt>
<dd>The parser to apply.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Callable[[Monoid1], bool]</code></dt>
<dd>The predicate to apply to the result of <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>. <code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat()</a></code> fails if this predicate returns false.</dd>
<dt><strong><code>on_fail</code></strong> :&ensp;<code>Callable[[Monoid1], ArgumentError]</code></dt>
<dd>A function producing an ArgumentError to return if the predicate fails.
Takes the output of <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code> as an argument.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sat(
    parser: Parser[Monoid1],
    predicate: Callable[[Monoid1], bool],
    on_fail: Callable[[Monoid1], ArgumentError],
) -&gt; Parser[Monoid1]:
    &#34;&#34;&#34;
    Applies `parser`, applies a predicate to the result and fails if this returns false.

    &gt;&gt;&gt; p = sat(
    ...     option(&#34;x&#34;, type=int).many(),
    ...     lambda kvs: sum([kv.value for kv in kvs]) &gt; 0,
    ...     lambda x: ArgumentError(f&#34;The values in {list(x)} must sum to more than 0.&#34;),
    ... )
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;1&#34;)  # fails
    usage: [-x X ...]
    The values in [KeyValue(key=&#39;x&#39;, value=-1), KeyValue(key=&#39;x&#39;, value=1)] must sum to more than 0.

    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;-1&#34;, &#34;-x&#34;, &#34;2&#34;)  # succeeds
    {&#39;x&#39;: 2}

    Parameters
    ----------
    parser : Parser[Monoid1]
        The parser to apply.
    predicate : Callable[[Monoid1], bool]
        The predicate to apply to the result of `parser`. `sat` fails if this predicate returns false.
    on_fail : Callable[[Monoid1], ArgumentError]
        A function producing an ArgumentError to return if the predicate fails.
        Takes the output of `parser` as an argument.
    &#34;&#34;&#34;

    def f(x: Monoid1) -&gt; Result[Monoid1]:
        return Result(NonemptyList(x) if predicate(x) else on_fail(x))

    return apply(f, parser)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.sat_item"><code class="name flex">
<span>def <span class="ident">sat_item</span></span>(<span>predicate: Callable[[str], bool], on_fail: Callable[[str], ArgumentError], name: str) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat()</a></code> that uses <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code> to parse the argument and just applies <code>predicate</code> to the value output by <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = sat_item(lambda x: len(x) == 1, lambda x: ArgumentError(f&quot;'{x}' must have exactly one character.&quot;), &quot;x&quot;)
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)  # succeeds
{'x': 'a'}
&gt;&gt;&gt; p.parse_args(&quot;aa&quot;)  # fails
usage: x
'aa' must have exactly one character.
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Callable[[Monoid1], bool]</code></dt>
<dd>The predicate to apply to the result of <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code>. <code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat()</a></code> fails if this predicate returns false.</dd>
<dt><strong><code>on_fail</code></strong> :&ensp;<code>Callable[[Monoid1], ArgumentError]</code></dt>
<dd>A function producing an ArgumentError to return if the predicate fails.
Takes the output of <code><a title="dollar_lambda.item" href="#dollar_lambda.item">item()</a></code> as an argument.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The value to bind the result to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sat_item(
    predicate: Callable[[str], bool],
    on_fail: Callable[[str], ArgumentError],
    name: str,
) -&gt; Parser[Sequence[KeyValue[str]]]:
    &#34;&#34;&#34;
    A wrapper around `sat` that uses `item` to parse the argument and just applies `predicate` to the value output by `item`.

    &gt;&gt;&gt; p = sat_item(lambda x: len(x) == 1, lambda x: ArgumentError(f&#34;&#39;{x}&#39; must have exactly one character.&#34;), &#34;x&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)  # succeeds
    {&#39;x&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;aa&#34;)  # fails
    usage: x
    &#39;aa&#39; must have exactly one character.

    Parameters
    ----------
    predicate : Callable[[Monoid1], bool]
        The predicate to apply to the result of `item`. `sat` fails if this predicate returns false.
    on_fail : Callable[[Monoid1], ArgumentError]
        A function producing an ArgumentError to return if the predicate fails.
        Takes the output of `item` as an argument.
    name: str
        The value to bind the result to.
    &#34;&#34;&#34;

    def _predicate(parsed: Sequence[KeyValue[str]]) -&gt; bool:
        [kv] = parsed
        return predicate(kv.value)

    def _on_fail(parsed: Sequence[KeyValue[str]]) -&gt; ArgumentError:
        [kv] = parsed
        return on_fail(kv.value)

    return sat(item(name), _predicate, _on_fail)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.type_"><code class="name flex">
<span>def <span class="ident">type_</span></span>(<span>f: Callable[[str], Any], parser: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[KeyValue[str]]]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper around <code><a title="dollar_lambda.apply" href="#dollar_lambda.apply">apply()</a></code> that simply applies <code>f</code> to the value of the most recently parsed input.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = option(&quot;x&quot;) &gt;&gt; option(&quot;y&quot;)
&gt;&gt;&gt; p = type_(int, p1)
&gt;&gt;&gt; p.parse_args(&quot;-x&quot;, &quot;1&quot;, &quot;-y&quot;, &quot;2&quot;)  # converts &quot;1&quot; but not &quot;2&quot;
{'y': '2', 'x': 1}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def type_(
    f: Callable[[str], Any], parser: Parser[Sequence[KeyValue[str]]]
) -&gt; Parser[Sequence[KeyValue[Any]]]:
    &#34;&#34;&#34;
    A wrapper around `apply` that simply applies `f` to the value of the most recently parsed input.
    &gt;&gt;&gt; p1 = option(&#34;x&#34;) &gt;&gt; option(&#34;y&#34;)
    &gt;&gt;&gt; p = type_(int, p1)
    &gt;&gt;&gt; p.parse_args(&#34;-x&#34;, &#34;1&#34;, &#34;-y&#34;, &#34;2&#34;)  # converts &#34;1&#34; but not &#34;2&#34;
    {&#39;y&#39;: &#39;2&#39;, &#39;x&#39;: 1}
    &#34;&#34;&#34;

    def g(
        kvs: Sequence[KeyValue[str]],
    ) -&gt; Result[Sequence[KeyValue[Any]]]:
        head, *tail = kvs.get
        try:
            y = f(head.value)
        except Exception as e:
            usage = f&#34;argument {head.value}: raised exception {e}&#34;
            return Result(ArgumentError(usage))
        head = replace(head, value=y)
        return Result.return_(Sequence([*tail, head]))

    p = apply(g, parser)
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.wrap_help"><code class="name flex">
<span>def <span class="ident">wrap_help</span></span>(<span>parser: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~A]</span>
</code></dt>
<dd>
<div class="desc"><p>This checks for the <code>--help</code> or <code>-h</code> flag before applying <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>.
If either of the flags is present, returns the usage message for <code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = wrap_help(flag(&quot;help&quot;, help=&quot;Print this help message.&quot;))
&gt;&gt;&gt; p.parse_args(&quot;--help&quot;)
usage: --help
help: Print this help message.
&gt;&gt;&gt; p.parse_args(&quot;-h&quot;)
usage: --help
help: Print this help message.
</code></pre>
<p>We can use <code><a title="dollar_lambda.wrap_help" href="#dollar_lambda.wrap_help">wrap_help()</a></code> to print partial usage messages, e.g. for subcommands:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; subcommand1 = equals(&quot;subcommand1&quot;) &gt;&gt; wrap_help(option(&quot;option1&quot;))
&gt;&gt;&gt; subcommand2 = equals(&quot;subcommand2&quot;) &gt;&gt; wrap_help(option(&quot;option2&quot;))
&gt;&gt;&gt; p = subcommand1 | subcommand2
&gt;&gt;&gt; p.parse_args(&quot;subcommand1&quot;, &quot;-h&quot;)
usage: --option1 OPTION1
&gt;&gt;&gt; p.parse_args(&quot;subcommand2&quot;, &quot;-h&quot;)
usage: --option2 OPTION2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_help(parser: Parser[A]) -&gt; Parser[A]:
    &#34;&#34;&#34;
    This checks for the `--help` or `-h` flag before applying `parser`.
    If either of the flags is present, returns the usage message for `parser`.

    &gt;&gt;&gt; p = wrap_help(flag(&#34;help&#34;, help=&#34;Print this help message.&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;--help&#34;)
    usage: --help
    help: Print this help message.
    &gt;&gt;&gt; p.parse_args(&#34;-h&#34;)
    usage: --help
    help: Print this help message.

    We can use `wrap_help` to print partial usage messages, e.g. for subcommands:
    &gt;&gt;&gt; subcommand1 = equals(&#34;subcommand1&#34;) &gt;&gt; wrap_help(option(&#34;option1&#34;))
    &gt;&gt;&gt; subcommand2 = equals(&#34;subcommand2&#34;) &gt;&gt; wrap_help(option(&#34;option2&#34;))
    &gt;&gt;&gt; p = subcommand1 | subcommand2
    &gt;&gt;&gt; p.parse_args(&#34;subcommand1&#34;, &#34;-h&#34;)
    usage: --option1 OPTION1
    &gt;&gt;&gt; p.parse_args(&#34;subcommand2&#34;, &#34;-h&#34;)
    usage: --option2 OPTION2
    &#34;&#34;&#34;
    _help_parser: Parser[Sequence[A]] = help_parser(parser.usage, Sequence([]))

    p = _help_parser &gt;= (lambda _: parser)
    return replace(p, usage=parser.usage, helps=parser.helps)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dollar_lambda.Args"><code class="flex name class">
<span>class <span class="ident">Args</span></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> is sugar for the <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code> function and removes much of the boilerplate
from defining parsers with many arguments.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     verbose: bool
...     count: int
&gt;&gt;&gt; MyArgs.parse_args(&quot;--verbose&quot;, &quot;--count&quot;, &quot;1&quot;)
{'verbose': True, 'count': 1}
</code></pre>
<p><code>MyArgs</code> will accept these arguments in any order:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--count&quot;, &quot;1&quot;, &quot;--verbose&quot;)
{'count': 1, 'verbose': True}
</code></pre>
<p>Note that when the default value of an argument is <code>True</code>, <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> will, by default
add <code>--no-</code> to the front of the flag (while still assigning the value to the original key):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     tests: bool = True
&gt;&gt;&gt; MyArgs.parse_args(&quot;--no-tests&quot;)
{'tests': False}
&gt;&gt;&gt; MyArgs.parse_args()
{'tests': True}
</code></pre>
<p>To suppress this behavior, set <code>flip_bools=False</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; MyArgs.parse_args(&quot;--tests&quot;, flip_bools=False)
{'tests': False}
</code></pre>
<p>By using the <code><a title="dollar_lambda.Args.parser" href="#dollar_lambda.Args.parser">Args.parser()</a></code> method, <code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code> can take advantage of all the same
combinators as other parsers:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument
&gt;&gt;&gt; p = MyArgs.parser()
&gt;&gt;&gt; p1 = p &gt;&gt; argument(&quot;a&quot;)
&gt;&gt;&gt; p1.parse_args(&quot;--no-tests&quot;, &quot;hello&quot;)
{'tests': False, 'a': 'hello'}
</code></pre>
<p>To supply other metadata, like <code>help</code> text and more complex <code>type</code> converters, use <code><a title="dollar_lambda.field" href="#dollar_lambda.field">field()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @dataclass
... class MyArgs(Args):
...     n: int = field(default=0, help=&quot;a number to increment&quot;, type=lambda x: 1 + int(x))
&gt;&gt;&gt; MyArgs.parse_args(&quot;-n&quot;, &quot;1&quot;)
{'n': 2}
&gt;&gt;&gt; MyArgs.parse_args()
{'n': 1}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Args:
    &#34;&#34;&#34;
    `Args` is sugar for the `nonpositional` function and removes much of the boilerplate
    from defining parsers with many arguments.

    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     verbose: bool
    ...     count: int
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--verbose&#34;, &#34;--count&#34;, &#34;1&#34;)
    {&#39;verbose&#39;: True, &#39;count&#39;: 1}

    `MyArgs` will accept these arguments in any order:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--count&#34;, &#34;1&#34;, &#34;--verbose&#34;)
    {&#39;count&#39;: 1, &#39;verbose&#39;: True}

    Note that when the default value of an argument is `True`, `Args` will, by default
    add `--no-` to the front of the flag (while still assigning the value to the original key):
    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     tests: bool = True
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--no-tests&#34;)
    {&#39;tests&#39;: False}
    &gt;&gt;&gt; MyArgs.parse_args()
    {&#39;tests&#39;: True}

    To suppress this behavior, set `flip_bools=False`:
    &gt;&gt;&gt; MyArgs.parse_args(&#34;--tests&#34;, flip_bools=False)
    {&#39;tests&#39;: False}

    By using the `Args.parser()` method, `Args` can take advantage of all the same
    combinators as other parsers:

    &gt;&gt;&gt; from dollar_lambda import argument
    &gt;&gt;&gt; p = MyArgs.parser()
    &gt;&gt;&gt; p1 = p &gt;&gt; argument(&#34;a&#34;)
    &gt;&gt;&gt; p1.parse_args(&#34;--no-tests&#34;, &#34;hello&#34;)
    {&#39;tests&#39;: False, &#39;a&#39;: &#39;hello&#39;}

    To supply other metadata, like `help` text and more complex `type` converters, use `field`:
    &gt;&gt;&gt; @dataclass
    ... class MyArgs(Args):
    ...     n: int = field(default=0, help=&#34;a number to increment&#34;, type=lambda x: 1 + int(x))
    &gt;&gt;&gt; MyArgs.parse_args(&#34;-n&#34;, &#34;1&#34;)
    {&#39;n&#39;: 2}
    &gt;&gt;&gt; MyArgs.parse_args()
    {&#39;n&#39;: 1}
    &#34;&#34;&#34;

    @classmethod
    def parser(cls, flip_bools: bool = True) -&gt; Parser[Sequence[KeyValue[Any]]]:
        &#34;&#34;&#34;
        Returns a parser for the dataclass.
        Converts each field to a parser (`option` or `flag` depending on its type).
        Combines these parsers using `nonpositional`.
        &#34;&#34;&#34;
        return _ArgsField.nonpositional(
            *[_ArgsField.parse(field) for field in fields(cls)], flip_bools=flip_bools
        )

    @classmethod
    def parse_args(
        cls, *args, flip_bools: bool = True
    ) -&gt; typing.Sequence[KeyValueTuple] | typing.Dict[str, Any]:
        &#34;&#34;&#34;
        Parses the arguments and returns a dictionary of the parsed values.
        &#34;&#34;&#34;
        return (cls.parser(flip_bools=flip_bools) &gt;&gt; done()).parse_args(*args)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="dollar_lambda.Args.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>*args, flip_bools: bool = True) ‑> Union[Sequence[<a title="dollar_lambda.key_value.KeyValueTuple" href="key_value.html#dollar_lambda.key_value.KeyValueTuple">KeyValueTuple</a>], Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the arguments and returns a dictionary of the parsed values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_args(
    cls, *args, flip_bools: bool = True
) -&gt; typing.Sequence[KeyValueTuple] | typing.Dict[str, Any]:
    &#34;&#34;&#34;
    Parses the arguments and returns a dictionary of the parsed values.
    &#34;&#34;&#34;
    return (cls.parser(flip_bools=flip_bools) &gt;&gt; done()).parse_args(*args)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Args.parser"><code class="name flex">
<span>def <span class="ident">parser</span></span>(<span>flip_bools: bool = True) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a parser for the dataclass.
Converts each field to a parser (<code><a title="dollar_lambda.option" href="#dollar_lambda.option">option()</a></code> or <code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag()</a></code> depending on its type).
Combines these parsers using <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parser(cls, flip_bools: bool = True) -&gt; Parser[Sequence[KeyValue[Any]]]:
    &#34;&#34;&#34;
    Returns a parser for the dataclass.
    Converts each field to a parser (`option` or `flag` depending on its type).
    Combines these parsers using `nonpositional`.
    &#34;&#34;&#34;
    return _ArgsField.nonpositional(
        *[_ArgsField.parse(field) for field in fields(cls)], flip_bools=flip_bools
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.CommandTree"><code class="flex name class">
<span>class <span class="ident">CommandTree</span></span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.subcommand()
... def f2(b: bool):
...     return dict(f2=dict(b=b))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree.main(&quot;-h&quot;)
usage: [-a A | f2 -b]
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
&gt;&gt;&gt; tree.main(&quot;f2&quot;, &quot;-b&quot;)
{'f2': {'b': True}}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @f1.subcommand()
... def f2(a: int, b: bool):
...     return dict(f2=dict(a=a, b=b))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @f1.subcommand()
... def f3(a: int, c: str):
...     return dict(f3=dict(a=a, c=c))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree.main(&quot;-h&quot;)
usage: -a A [f2 -b | f3 -c C]
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;, &quot;f2&quot;, &quot;-b&quot;)
{'f2': {'a': 1, 'b': True}}
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;, &quot;f3&quot;, &quot;-c&quot;, &quot;x&quot;)
{'f3': {'a': 1, 'c': 'x'}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class CommandTree:
    &#34;&#34;&#34;
    &gt;&gt;&gt; tree = CommandTree()

    &gt;&gt;&gt; @tree.command()
    ... def f1(a: int):
    ...     return dict(f1=dict(a=a))

    &gt;&gt;&gt; @tree.subcommand()
    ... def f2(b: bool):
    ...     return dict(f2=dict(b=b))

    &gt;&gt;&gt; tree.main(&#34;-h&#34;)
    usage: [-a A | f2 -b]
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;)
    {&#39;f1&#39;: {&#39;a&#39;: 1}}
    &gt;&gt;&gt; tree.main(&#34;f2&#34;, &#34;-b&#34;)
    {&#39;f2&#39;: {&#39;b&#39;: True}}

    &gt;&gt;&gt; tree = CommandTree()

    &gt;&gt;&gt; @tree.command()
    ... def f1(a: int):
    ...     return dict(f1=dict(a=a))

    &gt;&gt;&gt; @f1.subcommand()
    ... def f2(a: int, b: bool):
    ...     return dict(f2=dict(a=a, b=b))

    &gt;&gt;&gt; @f1.subcommand()
    ... def f3(a: int, c: str):
    ...     return dict(f3=dict(a=a, c=c))

    &gt;&gt;&gt; tree.main(&#34;-h&#34;)
    usage: -a A [f2 -b | f3 -c C]
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;)
    {&#39;f1&#39;: {&#39;a&#39;: 1}}
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;, &#34;f2&#34;, &#34;-b&#34;)
    {&#39;f2&#39;: {&#39;a&#39;: 1, &#39;b&#39;: True}}
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;, &#34;f3&#34;, &#34;-c&#34;, &#34;x&#34;)
    {&#39;f3&#39;: {&#39;a&#39;: 1, &#39;c&#39;: &#39;x&#39;}}
    &#34;&#34;&#34;

    _children: List[_Node] = field(default_factory=list)
    _required: bool = False

    def command(
        self,
        flip_bools: bool = True,
        help: Optional[Dict[str, str]] = None,
        required: bool = False,
        strings: Optional[Dict[str, str]] = None,
        types: Optional[Dict[str, Callable[[str], Any]]] = None,
    ) -&gt; Callable:
        return self._decorator(
            flip_bools=flip_bools,
            help=help,
            required=required,
            strings=strings,
            subcommand=False,
            types=types,
        )

    def _decorator(self, **kwargs) -&gt; Callable:
        def wrapper(function: Callable):
            tree = CommandTree()
            self._children.append(_Node(function=function, tree=tree, **kwargs))
            return tree

        return wrapper

    def _parser(self, *variables: str) -&gt; Parser[_FunctionPair[KeyValue[Any]]]:
        if not self._children:
            raise RuntimeError(
                &#34;You must assign children to a CommandTree object in order to use it as a parser.&#34;
            )

        def get_alternatives() -&gt; Iterator[Parser[_FunctionPair[KeyValue[Any]]]]:
            for child in self._children:
                parser: Parser[_FunctionPair[KeyValue[Any]]] = child.parser(*variables)
                if child.tree is not None and child.tree._children:
                    parser = cast(
                        Parser[_FunctionPair[KeyValue[Any]]],
                        parser
                        &gt;&gt; child.tree._parser(*variables, *child.variable_names()),
                    )
                yield parser

        return wrap_help(reduce(operator.or_, get_alternatives()))

    def main(self, *args: str) -&gt; Any:
        _args = args if args or parser_mod.TESTING else sys.argv[1:]
        p = self._parser() &gt;&gt; done()
        result = p.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            p.handle_error(result)
            if parser_mod.TESTING:
                return  # type: ignore[return-value]
            else:
                exit()
        assert isinstance(result, NonemptyList)
        pair = cast(_FunctionPair, result.head.parsed)
        return pair.function(**{kv.key: kv.value for kv in pair.get})

    def subcommand(
        self,
        flip_bools: bool = True,
        help: Optional[Dict[str, str]] = None,
        required: bool = False,
        strings: Optional[Dict[str, str]] = None,
        types: Optional[Dict[str, Callable[[str], Any]]] = None,
    ) -&gt; Callable:
        return self._decorator(
            flip_bools=flip_bools,
            help=help,
            required=required,
            types=types,
            strings=strings,
            subcommand=True,
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.CommandTree.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self, flip_bools: bool = True, help: Optional[Dict[str, str]] = None, required: bool = False, strings: Optional[Dict[str, str]] = None, types: Optional[Dict[str, Callable[[str], Any]]] = None) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(
    self,
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    required: bool = False,
    strings: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable:
    return self._decorator(
        flip_bools=flip_bools,
        help=help,
        required=required,
        strings=strings,
        subcommand=False,
        types=types,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.CommandTree.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, *args: str) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self, *args: str) -&gt; Any:
    _args = args if args or parser_mod.TESTING else sys.argv[1:]
    p = self._parser() &gt;&gt; done()
    result = p.parse(Sequence(list(_args))).get
    if isinstance(result, ArgumentError):
        p.handle_error(result)
        if parser_mod.TESTING:
            return  # type: ignore[return-value]
        else:
            exit()
    assert isinstance(result, NonemptyList)
    pair = cast(_FunctionPair, result.head.parsed)
    return pair.function(**{kv.key: kv.value for kv in pair.get})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.CommandTree.subcommand"><code class="name flex">
<span>def <span class="ident">subcommand</span></span>(<span>self, flip_bools: bool = True, help: Optional[Dict[str, str]] = None, required: bool = False, strings: Optional[Dict[str, str]] = None, types: Optional[Dict[str, Callable[[str], Any]]] = None) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subcommand(
    self,
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    required: bool = False,
    strings: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable:
    return self._decorator(
        flip_bools=flip_bools,
        help=help,
        required=required,
        types=types,
        strings=strings,
        subcommand=True,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.Parser"><code class="flex name class">
<span>class <span class="ident">Parser</span></span>
<span>(</span><span>f: Callable[[Sequence[str]], Result[Parse[A_co]]], usage: Optional[str], helps: Dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Main class powering the argument parser.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Parser(MonadPlus[A_co]):
    &#34;&#34;&#34;
    Main class powering the argument parser.
    &#34;&#34;&#34;

    __pdoc__[&#34;Parser.__add__&#34;] = True
    __pdoc__[&#34;Parser.__or__&#34;] = True
    __pdoc__[&#34;Parser.__rshift__&#34;] = True
    __pdoc__[&#34;Parser.__ge__&#34;] = True

    f: Callable[[Sequence[str]], Result[Parse[A_co]]]
    usage: Optional[str]
    helps: Dict[str, str]

    def __add__(
        self: Parser[Sequence[A]], other: Parser[Sequence[B]]
    ) -&gt; Parser[Sequence[A | B]]:
        &#34;&#34;&#34;
        Parse two arguments in either order.
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
        {&#39;verbose&#39;: True, &#39;debug&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
        {&#39;debug&#39;: True, &#39;verbose&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
        usage: --verbose --debug
        Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

        Note that if more than two arguments are chained together with `+`, some combinations will not parse:
        &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
        {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
        usage: -a -b -c
        Expected &#39;-b&#39;. Got &#39;-c&#39;

        This makes more sense when one supplies the implicit parentheses:
        &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

        In order to chain together more than two arguments, use `nonpositional`:
        &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
        &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
        {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
        &#34;&#34;&#34;
        p = (self &gt;&gt; other) | (other &gt;&gt; self)
        usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
        return replace(p, usage=usage)

    def __or__(
        self: Parser[A_co],
        other: Parser[B],
    ) -&gt; Parser[A_co | B]:
        &#34;&#34;&#34;
        Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

        &gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
        &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
        {&#39;verbose&#39;: True}

        Note that when both arguments are supplied, this will only parse the first:
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        {&#39;verbose&#39;: True}

        If you want this to fail, use `&gt;&gt;` (`Parser.__rshift__`) with `done()` or another parser:
        &gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
        usage: [--option OPTION | --verbose]
        Unrecognized argument: --option
        &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
        {&#39;option&#39;: &#39;x&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A_co | B]]:
            return self.parse(cs) | other.parse(cs)

        return Parser(
            f,
            usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
            helps={**self.helps, **other.helps},
        )

    def __rshift__(
        self: Parser[Sequence[A]], p: Parser[Sequence[B]]
    ) -&gt; Parser[Sequence[A | B]]:
        &#34;&#34;&#34;
        This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
        gets handed off to the second parser. If either parser fails, the whole thing fails.

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
        usage: first second
        The following arguments are required: second
        &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
        usage: first second
        The following arguments are required: second
        &#34;&#34;&#34;
        # def f(p1: Sequence[D]) -&gt; Parser[Parse[Sequence[D | B]]]:
        #     def g(p2: Sequence[B]) -&gt; Parser[Sequence[D | B]]:
        #         return Parser.return_(p1 + p2)

        #     return p &gt;= g

        # return self &gt;= f
        parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
        return replace(
            parser,
            usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False),
            helps={**self.helps, **p.helps},
        )

    def bind(self, f: Callable[[A_co], Parser[B]]) -&gt; Parser[B]:
        &#34;&#34;&#34;
        Returns a new parser that

        1. applies `self`;
        2. if this succeeds, applies `f` to the parsed component of the result.

        `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
        avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
        `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

        Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
        and we typically prefer using the infix operator to the spelled out method.

        Let&#39;s start with our simplest parser, `argument`:
        &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

        Now let&#39;s use the `equals` parser to write a function that takes the output of `p1` and fails unless
        the next argument is the same as the first:
        &gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Sequence(KeyValue[str]):
        ...     [kv] = kvs
        ...     return equals(kv.value)

        &gt;&gt;&gt; p = p1 &gt;= f
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
        {&#39;a&#39;: &#39;a&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
        Expected &#39;a&#39;. Got &#39;b&#39;
        &#34;&#34;&#34;

        def h(parse: Parse[A_co]) -&gt; Result[Parse[B]]:
            return f(parse.parsed).parse(parse.unparsed)

        def g(cs: Sequence[str]) -&gt; Result[Parse[B]]:
            return self.parse(cs) &gt;= h

        return Parser(g, usage=None, helps=self.helps)

    @classmethod
    def empty(cls: Type[Parser[Sequence[A]]]) -&gt; Parser[Sequence[A]]:
        &#34;&#34;&#34;
        Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
        &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
        {}
        &#34;&#34;&#34;
        return cls.return_(Sequence([]))

    def handle_error(self, error: ArgumentError) -&gt; None:
        def print_usage(usage: str):
            print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in usage else &#34; &#34;)
            if &#34;\n&#34; in usage:
                usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in usage.split(&#34;\n&#34;)])
            print(usage)
            if self.helps:
                for k, v in self.helps.items():
                    print(f&#34;{k}: {v}&#34;)

        if isinstance(error, HelpError):
            print_usage(error.usage)
        else:
            if self.usage:
                print_usage(self.usage)
            if error.usage:
                print(error.usage)

    def many(self: Parser[Sequence[Monoid1]]) -&gt; Parser[Sequence[Monoid1]]:
        &#34;&#34;&#34;
        Applies `self` zero or more times (like `*` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(return_dict=False)
        []
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, return_dict=False)
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;)]
        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)  # return_dict=False allows duplicate keys
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

        Note that if `self` contains `Parser.__or__`, the arguments can be
        heterogenous:
        &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
        &gt;&gt;&gt; p = p.many()
        &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, return_dict=False) # mix --verbose and --quiet
        [(&#39;verbose&#39;, True), (&#39;quiet&#39;, True)]
        &#34;&#34;&#34;
        p = self.many1() | self.empty()
        return replace(p, usage=f&#34;[{self.usage} ...]&#34;)

    def many1(self: Parser[Sequence[Monoid1]]) -&gt; Parser[Sequence[Monoid1]]:
        &#34;&#34;&#34;
        Applies `self` one or more times (like `+` in regexes).

        &gt;&gt;&gt; from dollar_lambda import argument, flag
        &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
        {&#39;1-or-more&#39;: &#39;1&#39;}
        &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, return_dict=False)  # return_dict=False allows duplicate keys
        [(&#39;1-or-more&#39;, &#39;1&#39;), (&#39;1-or-more&#39;, &#39;2&#39;)]
        &gt;&gt;&gt; p.parse_args()
        usage: 1-or-more [1-or-more ...]
        The following arguments are required: 1-or-more
        &#34;&#34;&#34;

        def g() -&gt; Generator[&#34;Parser[Sequence[Monoid1]]&#34;, Sequence[Monoid1], None]:
            # noinspection PyTypeChecker
            r1: Sequence[Monoid1] = yield self
            # noinspection PyTypeChecker
            r2: Sequence[Monoid1] = yield self.many()
            yield Parser[Sequence[Monoid1]].return_(r1 + r2)

        @lru_cache()
        def f(cs: tuple):
            return Parser.do(g).parse(Sequence(list(cs)))

        return Parser(
            lambda cs: f(tuple(cs)),
            usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
            helps=self.helps,
        )

    def optional(self: Parser[Sequence[A]]) -&gt; Parser[Sequence[A]]:
        &#34;&#34;&#34;
        Allows arguments to be optional:
        &gt;&gt;&gt; p1 = flag(&#34;optional&#34;) &gt;&gt; done()
        &gt;&gt;&gt; p = p1.optional()
        &gt;&gt;&gt; p.parse_args(&#34;--optional&#34;)
        {&#39;optional&#39;: True}
        &gt;&gt;&gt; p.parse_args(&#34;--misspelled&#34;)  # succeeds with no output
        {}
        &gt;&gt;&gt; p1.parse_args(&#34;--misspelled&#34;)
        usage: --optional
        Expected &#39;--optional&#39;. Got &#39;--misspelled&#39;
        &#34;&#34;&#34;
        return self | self.empty()

    def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        &#34;&#34;&#34;
        Applies the parser to the input sequence `cs`.
        &#34;&#34;&#34;
        return self.f(cs)

    def parse_args(
        self: &#34;Parser[Sequence[KeyValue]]&#34;,
        *args: str,
        return_dict: bool = True,
        check_help: bool = True,
    ) -&gt; typing.Sequence[KeyValueTuple] | Dict[str, Any]:
        &#34;&#34;&#34;
        The main way the user extracts parsed results from the parser.

        Parameters
        ----------
        args : str
            A sequence of strings to parse. If empty, defaults to `sys.argv[1:]`.
        return_dict : bool
            Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
            The tuples are `KeyValueTuple` namedtuples, with fields `key` and `value`.
        check_help : bool
            Before running the parser, checks if the input string is `--help` or `-h`.
            If it is, returns the usage message.

        &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
        &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)
        [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
        usage: a
        &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
        usage: a
        &#34;&#34;&#34;
        _args = args if args or TESTING else sys.argv[1:]
        if check_help:
            return wrap_help(self).parse_args(
                *_args, return_dict=return_dict, check_help=False
            )
        result = self.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            self.handle_error(result)
            if TESTING:
                return  # type: ignore[return-value]
            else:
                exit()

        kvs = result.head.parsed
        if return_dict:
            return {kv.key: kv.value for kv in kvs}
        return [KeyValueTuple(**asdict(kv)) for kv in kvs]

    @classmethod
    def return_(cls, a: A_co) -&gt; Parser[A_co]:  # type: ignore[misc]
        # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
        &#34;&#34;&#34;
        This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
        and always returns `a` as the result. For the most part, the user will not use
        this method unless building custom parsers.

        &gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
        &gt;&gt;&gt; Parser.return_(([KeyValue(&#34;some-key&#34;, &#34;some-value&#34;)])).parse_args()
        {&#39;some-key&#39;: &#39;some-value&#39;}
        &#34;&#34;&#34;

        def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
            return Result.return_(Parse(a, cs))

        return Parser(f, usage=None, helps={})

    @classmethod
    def zero(cls, error: Optional[ArgumentError] = None) -&gt; Parser[A_co]:
        &#34;&#34;&#34;
        This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

        Parameters
        ----------
        error : Optional[ArgumentError]
            Customize the error returned by `zero`.

        &gt;&gt;&gt; Parser.zero().parse_args()
        zero
        &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
        zero
        &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
        This is a test.
        &#34;&#34;&#34;
        return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pytypeclass.monoid.MonadPlus</li>
<li>pytypeclass.monad.Monad</li>
<li>pytypeclass.monoid.Monoid</li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.Parser.f"><code class="name">var <span class="ident">f</span> : Callable[[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[str]], <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="parser.html#dollar_lambda.parser.Parse">Parse</a>[+A_co]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.Parser.helps"><code class="name">var <span class="ident">helps</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.Parser.usage"><code class="name">var <span class="ident">usage</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dollar_lambda.Parser.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Always returns {}, no matter the input. Mostly useful for use in <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; empty().parse_args(&quot;any&quot;, &quot;arguments&quot;)
{}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty(cls: Type[Parser[Sequence[A]]]) -&gt; Parser[Sequence[A]]:
    &#34;&#34;&#34;
    Always returns {}, no matter the input. Mostly useful for use in `nonpositional`.
    &gt;&gt;&gt; empty().parse_args(&#34;any&#34;, &#34;arguments&#34;)
    {}
    &#34;&#34;&#34;
    return cls.return_(Sequence([]))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.return_"><code class="name flex">
<span>def <span class="ident">return_</span></span>(<span>a: A_co) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"><p>This method is required to make <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. It consumes none of the input
and always returns <code>a</code> as the result. For the most part, the user will not use
this method unless building custom parsers.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
&gt;&gt;&gt; Parser.return_(([KeyValue(&quot;some-key&quot;, &quot;some-value&quot;)])).parse_args()
{'some-key': 'some-value'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def return_(cls, a: A_co) -&gt; Parser[A_co]:  # type: ignore[misc]
    # see https://github.com/python/mypy/issues/6178#issuecomment-1057111790
    &#34;&#34;&#34;
    This method is required to make `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). It consumes none of the input
    and always returns `a` as the result. For the most part, the user will not use
    this method unless building custom parsers.

    &gt;&gt;&gt; from dollar_lambda.key_value import KeyValue
    &gt;&gt;&gt; Parser.return_(([KeyValue(&#34;some-key&#34;, &#34;some-value&#34;)])).parse_args()
    {&#39;some-key&#39;: &#39;some-value&#39;}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
        return Result.return_(Parse(a, cs))

    return Parser(f, usage=None, helps={})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.zero"><code class="name flex">
<span>def <span class="ident">zero</span></span>(<span>error: Optional[ArgumentError] = None) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[+A_co]</span>
</code></dt>
<dd>
<div class="desc"><p>This parser always fails. This method is necessary to make <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13"><code>Monoid</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>error</code></strong> :&ensp;<code>Optional[ArgumentError]</code></dt>
<dd>Customize the error returned by <code>zero</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; Parser.zero().parse_args()
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero().parse_args(&quot;a&quot;)
**```zero```**
:   &amp;nbsp;


&gt;&gt;&gt; Parser.zero(error=ArgumentError(&quot;This is a test.&quot;)).parse_args(&quot;a&quot;)
This is a test.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def zero(cls, error: Optional[ArgumentError] = None) -&gt; Parser[A_co]:
    &#34;&#34;&#34;
    This parser always fails. This method is necessary to make `Parser` a [`Monoid`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py#L13).

    Parameters
    ----------
    error : Optional[ArgumentError]
        Customize the error returned by `zero`.

    &gt;&gt;&gt; Parser.zero().parse_args()
    zero
    &gt;&gt;&gt; Parser.zero().parse_args(&#34;a&#34;)
    zero
    &gt;&gt;&gt; Parser.zero(error=ArgumentError(&#34;This is a test.&#34;)).parse_args(&#34;a&#34;)
    This is a test.
    &#34;&#34;&#34;
    return Parser(lambda _: Result.zero(error=error), usage=None, helps={})</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.Parser.__add__"><code class="name flex">
<span>def <span class="ident">__add__</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]], other: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[B]]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[typing.Union[~A, ~B]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Parse two arguments in either order.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) + flag(&quot;debug&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--debug&quot;)
{'verbose': True, 'debug': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;, &quot;--verbose&quot;)
{'debug': True, 'verbose': True}
&gt;&gt;&gt; p.parse_args(&quot;--debug&quot;)
usage: --verbose --debug
Expected '--verbose'. Got '--debug'
</code></pre>
<p>Note that if more than two arguments are chained together with <code>+</code>, some combinations will not parse:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;a&quot;) + flag(&quot;b&quot;) + flag(&quot;c&quot;)
&gt;&gt;&gt; p.parse_args(&quot;-c&quot;, &quot;-a&quot;, &quot;-b&quot;)   # this works
{'c': True, 'a': True, 'b': True}
&gt;&gt;&gt; p.parse_args(&quot;-a&quot;, &quot;-c&quot;, &quot;-b&quot;)   # this doesn't
usage: -a -b -c
Expected '-b'. Got '-c'
</code></pre>
<p>This makes more sense when one supplies the implicit parentheses:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = (flag(&quot;a&quot;) + flag(&quot;b&quot;)) + flag(&quot;c&quot;)
</code></pre>
<p>In order to chain together more than two arguments, use <code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = nonpositional(flag(&quot;a&quot;), flag(&quot;b&quot;), flag(&quot;c&quot;))
&gt;&gt;&gt; p.parse_args(&quot;-a&quot;, &quot;-c&quot;, &quot;-b&quot;)
{'a': True, 'c': True, 'b': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __add__(
    self: Parser[Sequence[A]], other: Parser[Sequence[B]]
) -&gt; Parser[Sequence[A | B]]:
    &#34;&#34;&#34;
    Parse two arguments in either order.
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) + flag(&#34;debug&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--debug&#34;)
    {&#39;verbose&#39;: True, &#39;debug&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;, &#34;--verbose&#34;)
    {&#39;debug&#39;: True, &#39;verbose&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--debug&#34;)
    usage: --verbose --debug
    Expected &#39;--verbose&#39;. Got &#39;--debug&#39;

    Note that if more than two arguments are chained together with `+`, some combinations will not parse:
    &gt;&gt;&gt; p = flag(&#34;a&#34;) + flag(&#34;b&#34;) + flag(&#34;c&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;-c&#34;, &#34;-a&#34;, &#34;-b&#34;)   # this works
    {&#39;c&#39;: True, &#39;a&#39;: True, &#39;b&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)   # this doesn&#39;t
    usage: -a -b -c
    Expected &#39;-b&#39;. Got &#39;-c&#39;

    This makes more sense when one supplies the implicit parentheses:
    &gt;&gt;&gt; p = (flag(&#34;a&#34;) + flag(&#34;b&#34;)) + flag(&#34;c&#34;)

    In order to chain together more than two arguments, use `nonpositional`:
    &gt;&gt;&gt; p = nonpositional(flag(&#34;a&#34;), flag(&#34;b&#34;), flag(&#34;c&#34;))
    &gt;&gt;&gt; p.parse_args(&#34;-a&#34;, &#34;-c&#34;, &#34;-b&#34;)
    {&#39;a&#39;: True, &#39;c&#39;: True, &#39;b&#39;: True}
    &#34;&#34;&#34;
    p = (self &gt;&gt; other) | (other &gt;&gt; self)
    usage = binary_usage(self.usage, &#34; &#34;, other.usage, add_brackets=False)
    return replace(p, usage=usage)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__or__"><code class="name flex">
<span>def <span class="ident">__or__</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[A_co], other: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[B]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[typing.Union[+A_co, ~B]]</span>
</code></dt>
<dd>
<div class="desc"><p>Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
&gt;&gt;&gt; p = option(&quot;option&quot;) | flag(&quot;verbose&quot;)
&gt;&gt;&gt; p.parse_args(&quot;--option&quot;, &quot;x&quot;)
{'option': 'x'}
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;)
{'verbose': True}
</code></pre>
<p>Note that when both arguments are supplied, this will only parse the first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--option&quot;, &quot;x&quot;)
{'verbose': True}
</code></pre>
<p>If you want this to fail, use <code>&gt;&gt;</code> (<code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code>) with <code><a title="dollar_lambda.done" href="#dollar_lambda.done">done()</a></code> or another parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&quot;--verbose&quot;, &quot;--option&quot;, &quot;x&quot;)
usage: [--option OPTION | --verbose]
Unrecognized argument: --option
&gt;&gt;&gt; p.parse_args(&quot;--option&quot;, &quot;x&quot;)
{'option': 'x'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __or__(
    self: Parser[A_co],
    other: Parser[B],
) -&gt; Parser[A_co | B]:
    &#34;&#34;&#34;
    Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails.

    &gt;&gt;&gt; from dollar_lambda import argument, option, done, flag
    &gt;&gt;&gt; p = option(&#34;option&#34;) | flag(&#34;verbose&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
    {&#39;option&#39;: &#39;x&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;)
    {&#39;verbose&#39;: True}

    Note that when both arguments are supplied, this will only parse the first:
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
    {&#39;verbose&#39;: True}

    If you want this to fail, use `&gt;&gt;` (`Parser.__rshift__`) with `done()` or another parser:
    &gt;&gt;&gt; (p &gt;&gt; done()).parse_args(&#34;--verbose&#34;, &#34;--option&#34;, &#34;x&#34;)
    usage: [--option OPTION | --verbose]
    Unrecognized argument: --option
    &gt;&gt;&gt; p.parse_args(&#34;--option&#34;, &#34;x&#34;)
    {&#39;option&#39;: &#39;x&#39;}
    &#34;&#34;&#34;

    def f(cs: Sequence[str]) -&gt; Result[Parse[A_co | B]]:
        return self.parse(cs) | other.parse(cs)

    return Parser(
        f,
        usage=binary_usage(self.usage, &#34; | &#34;, other.usage),
        helps={**self.helps, **other.helps},
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.__rshift__"><code class="name flex">
<span>def <span class="ident">__rshift__</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]], p: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[B]]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[typing.Union[~A, ~B]]]</span>
</code></dt>
<dd>
<div class="desc"><p>This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
gets handed off to the second parser. If either parser fails, the whole thing fails.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;first&quot;) &gt;&gt; argument(&quot;second&quot;)
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
{'first': 'a', 'second': 'b'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;)
usage: first second
The following arguments are required: second
&gt;&gt;&gt; p.parse_args(&quot;b&quot;)
usage: first second
The following arguments are required: second
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __rshift__(
    self: Parser[Sequence[A]], p: Parser[Sequence[B]]
) -&gt; Parser[Sequence[A | B]]:
    &#34;&#34;&#34;
    This applies parsers in sequence. If the first parser succeeds, the unparsed remainder
    gets handed off to the second parser. If either parser fails, the whole thing fails.

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;first&#34;) &gt;&gt; argument(&#34;second&#34;)
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    {&#39;first&#39;: &#39;a&#39;, &#39;second&#39;: &#39;b&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;)
    usage: first second
    The following arguments are required: second
    &gt;&gt;&gt; p.parse_args(&#34;b&#34;)
    usage: first second
    The following arguments are required: second
    &#34;&#34;&#34;
    # def f(p1: Sequence[D]) -&gt; Parser[Parse[Sequence[D | B]]]:
    #     def g(p2: Sequence[B]) -&gt; Parser[Sequence[D | B]]:
    #         return Parser.return_(p1 + p2)

    #     return p &gt;= g

    # return self &gt;= f
    parser = self &gt;= (lambda p1: (p &gt;= (lambda p2: Parser.return_(p1 + p2))))
    return replace(
        parser,
        usage=binary_usage(self.usage, &#34; &#34;, p.usage, add_brackets=False),
        helps={**self.helps, **p.helps},
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.bind"><code class="name flex">
<span>def <span class="ident">bind</span></span>(<span>self, f: Callable[[A_co], <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[B]]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[~B]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new parser that</p>
<ol>
<li>applies <code>self</code>;</li>
<li>if this succeeds, applies <code>f</code> to the parsed component of the result.</li>
</ol>
<p><code>bind</code> is one of the functions that makes <code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code> a <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16"><code>Monad</code></a>. But most users will
avoid using it directly, preferring higher level combinators like <code>&gt;&gt;</code> (<code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">Parser.__rshift__()</a></code>),
<code>|</code> (<code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>) and <code>+</code> (<code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">Parser.__add__()</a></code>).</p>
<p>Note that <code>&gt;=</code> as a synonym for <code>bind</code> (as defined in <a href="https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26"><code>pytypeclass</code></a>)
and we typically prefer using the infix operator to the spelled out method.</p>
<p>Let's start with our simplest parser, <code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = argument(&quot;some_dest&quot;)
</code></pre>
<p>Now let's use the <code><a title="dollar_lambda.equals" href="#dollar_lambda.equals">equals()</a></code> parser to write a function that takes the output of <code>p1</code> and fails unless
the next argument is the same as the first:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Sequence(KeyValue[str]):
...     [kv] = kvs
...     return equals(kv.value)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = p1 &gt;= f
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;a&quot;)
{'a': 'a'}
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;)
Expected 'a'. Got 'b'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind(self, f: Callable[[A_co], Parser[B]]) -&gt; Parser[B]:
    &#34;&#34;&#34;
    Returns a new parser that

    1. applies `self`;
    2. if this succeeds, applies `f` to the parsed component of the result.

    `bind` is one of the functions that makes `Parser` a [`Monad`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L16). But most users will
    avoid using it directly, preferring higher level combinators like `&gt;&gt;` (`Parser.__rshift__`),
    `|` (`Parser.__or__`) and `+` (`Parser.__add__`).

    Note that `&gt;=` as a synonym for `bind` (as defined in [`pytypeclass`](https://github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py#L26))
    and we typically prefer using the infix operator to the spelled out method.

    Let&#39;s start with our simplest parser, `argument`:
    &gt;&gt;&gt; p1 = argument(&#34;some_dest&#34;)

    Now let&#39;s use the `equals` parser to write a function that takes the output of `p1` and fails unless
    the next argument is the same as the first:
    &gt;&gt;&gt; def f(kvs: Sequence(KeyValue[str])) -&gt; Sequence(KeyValue[str]):
    ...     [kv] = kvs
    ...     return equals(kv.value)

    &gt;&gt;&gt; p = p1 &gt;= f
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;a&#34;)
    {&#39;a&#39;: &#39;a&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;)
    Expected &#39;a&#39;. Got &#39;b&#39;
    &#34;&#34;&#34;

    def h(parse: Parse[A_co]) -&gt; Result[Parse[B]]:
        return f(parse.parsed).parse(parse.unparsed)

    def g(cs: Sequence[str]) -&gt; Result[Parse[B]]:
        return self.parse(cs) &gt;= h

    return Parser(g, usage=None, helps=self.helps)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.handle_error"><code class="name flex">
<span>def <span class="ident">handle_error</span></span>(<span>self, error: ArgumentError) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_error(self, error: ArgumentError) -&gt; None:
    def print_usage(usage: str):
        print(&#34;usage:&#34;, end=&#34;\n&#34; if &#34;\n&#34; in usage else &#34; &#34;)
        if &#34;\n&#34; in usage:
            usage = &#34;\n&#34;.join([&#34;    &#34; + u for u in usage.split(&#34;\n&#34;)])
        print(usage)
        if self.helps:
            for k, v in self.helps.items():
                print(f&#34;{k}: {v}&#34;)

    if isinstance(error, HelpError):
        print_usage(error.usage)
    else:
        if self.usage:
            print_usage(self.usage)
        if error.usage:
            print(error.usage)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.many"><code class="name flex">
<span>def <span class="ident">many</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[Monoid1]]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~Monoid1]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> zero or more times (like <code>*</code> in regexes).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(return_dict=False)
[]
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, return_dict=False)
[('as-many-as-you-like', 'a')]
&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;, return_dict=False)  # return_dict=False allows duplicate keys
[('as-many-as-you-like', 'a'), ('as-many-as-you-like', 'b')]
</code></pre>
<p>Note that if <code>self</code> contains <code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">Parser.__or__()</a></code>, the arguments can be
heterogenous:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = flag(&quot;verbose&quot;) | flag(&quot;quiet&quot;)
&gt;&gt;&gt; p = p.many()
&gt;&gt;&gt; p.parse_args(&quot;--verbose&quot;, &quot;--quiet&quot;, return_dict=False) # mix --verbose and --quiet
[('verbose', True), ('quiet', True)]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def many(self: Parser[Sequence[Monoid1]]) -&gt; Parser[Sequence[Monoid1]]:
    &#34;&#34;&#34;
    Applies `self` zero or more times (like `*` in regexes).

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(return_dict=False)
    []
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, return_dict=False)
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;)]
    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)  # return_dict=False allows duplicate keys
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

    Note that if `self` contains `Parser.__or__`, the arguments can be
    heterogenous:
    &gt;&gt;&gt; p = flag(&#34;verbose&#34;) | flag(&#34;quiet&#34;)
    &gt;&gt;&gt; p = p.many()
    &gt;&gt;&gt; p.parse_args(&#34;--verbose&#34;, &#34;--quiet&#34;, return_dict=False) # mix --verbose and --quiet
    [(&#39;verbose&#39;, True), (&#39;quiet&#39;, True)]
    &#34;&#34;&#34;
    p = self.many1() | self.empty()
    return replace(p, usage=f&#34;[{self.usage} ...]&#34;)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.many1"><code class="name flex">
<span>def <span class="ident">many1</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[Monoid1]]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~Monoid1]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies <code>self</code> one or more times (like <code>+</code> in regexes).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dollar_lambda import argument, flag
&gt;&gt;&gt; p = argument(&quot;1-or-more&quot;).many1()
&gt;&gt;&gt; p.parse_args(&quot;1&quot;)
{'1-or-more': '1'}
&gt;&gt;&gt; p.parse_args(&quot;1&quot;, &quot;2&quot;, return_dict=False)  # return_dict=False allows duplicate keys
[('1-or-more', '1'), ('1-or-more', '2')]
&gt;&gt;&gt; p.parse_args()
usage: 1-or-more [1-or-more ...]
The following arguments are required: 1-or-more
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def many1(self: Parser[Sequence[Monoid1]]) -&gt; Parser[Sequence[Monoid1]]:
    &#34;&#34;&#34;
    Applies `self` one or more times (like `+` in regexes).

    &gt;&gt;&gt; from dollar_lambda import argument, flag
    &gt;&gt;&gt; p = argument(&#34;1-or-more&#34;).many1()
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;)
    {&#39;1-or-more&#39;: &#39;1&#39;}
    &gt;&gt;&gt; p.parse_args(&#34;1&#34;, &#34;2&#34;, return_dict=False)  # return_dict=False allows duplicate keys
    [(&#39;1-or-more&#39;, &#39;1&#39;), (&#39;1-or-more&#39;, &#39;2&#39;)]
    &gt;&gt;&gt; p.parse_args()
    usage: 1-or-more [1-or-more ...]
    The following arguments are required: 1-or-more
    &#34;&#34;&#34;

    def g() -&gt; Generator[&#34;Parser[Sequence[Monoid1]]&#34;, Sequence[Monoid1], None]:
        # noinspection PyTypeChecker
        r1: Sequence[Monoid1] = yield self
        # noinspection PyTypeChecker
        r2: Sequence[Monoid1] = yield self.many()
        yield Parser[Sequence[Monoid1]].return_(r1 + r2)

    @lru_cache()
    def f(cs: tuple):
        return Parser.do(g).parse(Sequence(list(cs)))

    return Parser(
        lambda cs: f(tuple(cs)),
        usage=f&#34;{self.usage} [{self.usage} ...]&#34;,
        helps=self.helps,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.optional"><code class="name flex">
<span>def <span class="ident">optional</span></span>(<span>self: <a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[A]]) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"><p>Allows arguments to be optional:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; p1 = flag(&quot;optional&quot;) &gt;&gt; done()
&gt;&gt;&gt; p = p1.optional()
&gt;&gt;&gt; p.parse_args(&quot;--optional&quot;)
{'optional': True}
&gt;&gt;&gt; p.parse_args(&quot;--misspelled&quot;)  # succeeds with no output
{}
&gt;&gt;&gt; p1.parse_args(&quot;--misspelled&quot;)
usage: --optional
Expected '--optional'. Got '--misspelled'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optional(self: Parser[Sequence[A]]) -&gt; Parser[Sequence[A]]:
    &#34;&#34;&#34;
    Allows arguments to be optional:
    &gt;&gt;&gt; p1 = flag(&#34;optional&#34;) &gt;&gt; done()
    &gt;&gt;&gt; p = p1.optional()
    &gt;&gt;&gt; p.parse_args(&#34;--optional&#34;)
    {&#39;optional&#39;: True}
    &gt;&gt;&gt; p.parse_args(&#34;--misspelled&#34;)  # succeeds with no output
    {}
    &gt;&gt;&gt; p1.parse_args(&#34;--misspelled&#34;)
    usage: --optional
    Expected &#39;--optional&#39;. Got &#39;--misspelled&#39;
    &#34;&#34;&#34;
    return self | self.empty()</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, cs: Sequence[str]) ‑> <a title="dollar_lambda.result.Result" href="result.html#dollar_lambda.result.Result">Result</a>[<a title="dollar_lambda.parser.Parse" href="parser.html#dollar_lambda.parser.Parse">Parse</a>[+A_co]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the parser to the input sequence <code>cs</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, cs: Sequence[str]) -&gt; Result[Parse[A_co]]:
    &#34;&#34;&#34;
    Applies the parser to the input sequence `cs`.
    &#34;&#34;&#34;
    return self.f(cs)</code></pre>
</details>
</dd>
<dt id="dollar_lambda.Parser.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>self: "'<a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a>[Sequence[KeyValue]]'", *args: str, return_dict: bool = True, check_help: bool = True) ‑> Union[Sequence[<a title="dollar_lambda.key_value.KeyValueTuple" href="key_value.html#dollar_lambda.key_value.KeyValueTuple">KeyValueTuple</a>], Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>The main way the user extracts parsed results from the parser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>str</code></dt>
<dd>A sequence of strings to parse. If empty, defaults to <code>sys.argv[1:]</code>.</dd>
<dt><strong><code>return_dict</code></strong> :&ensp;<code>bool</code></dt>
<dd>Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
The tuples are <code>KeyValueTuple</code> namedtuples, with fields <code>key</code> and <code>value</code>.</dd>
<dt><strong><code>check_help</code></strong> :&ensp;<code>bool</code></dt>
<dd>Before running the parser, checks if the input string is <code>--help</code> or <code>-h</code>.
If it is, returns the usage message.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = argument(&quot;as-many-as-you-like&quot;).many()
&gt;&gt;&gt; p.parse_args(&quot;a&quot;, &quot;b&quot;, return_dict=False)
[('as-many-as-you-like', 'a'), ('as-many-as-you-like', 'b')]
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;-h&quot;)
**```usage```** :&amp;ensp;&lt;code&gt;a&lt;/code&gt;
:   &amp;nbsp;


&gt;&gt;&gt; argument(&quot;a&quot;).parse_args(&quot;--help&quot;)
**```usage```** :&amp;ensp;&lt;code&gt;a&lt;/code&gt;
:   &amp;nbsp;


</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_args(
    self: &#34;Parser[Sequence[KeyValue]]&#34;,
    *args: str,
    return_dict: bool = True,
    check_help: bool = True,
) -&gt; typing.Sequence[KeyValueTuple] | Dict[str, Any]:
    &#34;&#34;&#34;
    The main way the user extracts parsed results from the parser.

    Parameters
    ----------
    args : str
        A sequence of strings to parse. If empty, defaults to `sys.argv[1:]`.
    return_dict : bool
        Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys.
        The tuples are `KeyValueTuple` namedtuples, with fields `key` and `value`.
    check_help : bool
        Before running the parser, checks if the input string is `--help` or `-h`.
        If it is, returns the usage message.

    &gt;&gt;&gt; p = argument(&#34;as-many-as-you-like&#34;).many()
    &gt;&gt;&gt; p.parse_args(&#34;a&#34;, &#34;b&#34;, return_dict=False)
    [(&#39;as-many-as-you-like&#39;, &#39;a&#39;), (&#39;as-many-as-you-like&#39;, &#39;b&#39;)]

    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;-h&#34;)
    usage: a
    &gt;&gt;&gt; argument(&#34;a&#34;).parse_args(&#34;--help&#34;)
    usage: a
    &#34;&#34;&#34;
    _args = args if args or TESTING else sys.argv[1:]
    if check_help:
        return wrap_help(self).parse_args(
            *_args, return_dict=return_dict, check_help=False
        )
    result = self.parse(Sequence(list(_args))).get
    if isinstance(result, ArgumentError):
        self.handle_error(result)
        if TESTING:
            return  # type: ignore[return-value]
        else:
            exit()

    kvs = result.head.parsed
    if return_dict:
        return {kv.key: kv.value for kv in kvs}
    return [KeyValueTuple(**asdict(kv)) for kv in kvs]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#why">Why $λ?</a><ul>
<li><a href="#versatile">Versatile</a></li>
<li><a href="#type-safe">Type-safe</a></li>
<li><a href="#concise">Concise</a></li>
</ul>
</li>
<li><a href="#installation">Installation</a></li>
<li><a href="#tutorial">Tutorial</a><ul>
<li><a href="#high-level-parsers">High-Level Parsers</a><ul>
<li><a href="#flag">flag</a></li>
<li><a href="#option">option</a></li>
<li><a href="#done">done</a></li>
</ul>
</li>
<li><a href="#parser-combinators">Parser Combinators</a><ul>
<li><a href="#parser__or__">Parser.__or__</a></li>
<li><a href="#parser__rshift__">Parser.__rshift__</a></li>
<li><a href="#nonpositional-and-parser__add__">nonpositional and Parser.__add__</a></li>
</ul>
</li>
<li><a href="#putting-it-all-together">Putting it all together</a></li>
<li><a href="#alternative-syntax">Alternative syntax</a><ul>
<li><a href="#command">command</a></li>
<li><a href="#commandtree">CommandTree</a></li>
<li><a href="#args">Args</a></li>
</ul>
</li>
<li><a href="#variations-on-the-example">Variations on the example</a><ul>
<li><a href="#variable-numbers-of-arguments">Variable numbers of arguments</a></li>
<li><a href="#parsermany">Parser.many</a></li>
<li><a href="#parsermany1">Parser.many1</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="dollar_lambda.args" href="args.html">dollar_lambda.args</a></code></li>
<li><code><a title="dollar_lambda.decorators" href="decorators.html">dollar_lambda.decorators</a></code></li>
<li><code><a title="dollar_lambda.error" href="error.html">dollar_lambda.error</a></code></li>
<li><code><a title="dollar_lambda.key_value" href="key_value.html">dollar_lambda.key_value</a></code></li>
<li><code><a title="dollar_lambda.parser" href="parser.html">dollar_lambda.parser</a></code></li>
<li><code><a title="dollar_lambda.result" href="result.html">dollar_lambda.result</a></code></li>
<li><code><a title="dollar_lambda.sequence" href="sequence.html">dollar_lambda.sequence</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="dollar_lambda.apply" href="#dollar_lambda.apply">apply</a></code></li>
<li><code><a title="dollar_lambda.apply_item" href="#dollar_lambda.apply_item">apply_item</a></code></li>
<li><code><a title="dollar_lambda.argument" href="#dollar_lambda.argument">argument</a></code></li>
<li><code><a title="dollar_lambda.command" href="#dollar_lambda.command">command</a></code></li>
<li><code><a title="dollar_lambda.defaults" href="#dollar_lambda.defaults">defaults</a></code></li>
<li><code><a title="dollar_lambda.done" href="#dollar_lambda.done">done</a></code></li>
<li><code><a title="dollar_lambda.empty" href="#dollar_lambda.empty">empty</a></code></li>
<li><code><a title="dollar_lambda.equals" href="#dollar_lambda.equals">equals</a></code></li>
<li><code><a title="dollar_lambda.field" href="#dollar_lambda.field">field</a></code></li>
<li><code><a title="dollar_lambda.flag" href="#dollar_lambda.flag">flag</a></code></li>
<li><code><a title="dollar_lambda.item" href="#dollar_lambda.item">item</a></code></li>
<li><code><a title="dollar_lambda.nonpositional" href="#dollar_lambda.nonpositional">nonpositional</a></code></li>
<li><code><a title="dollar_lambda.option" href="#dollar_lambda.option">option</a></code></li>
<li><code><a title="dollar_lambda.sat" href="#dollar_lambda.sat">sat</a></code></li>
<li><code><a title="dollar_lambda.sat_item" href="#dollar_lambda.sat_item">sat_item</a></code></li>
<li><code><a title="dollar_lambda.type_" href="#dollar_lambda.type_">type_</a></code></li>
<li><code><a title="dollar_lambda.wrap_help" href="#dollar_lambda.wrap_help">wrap_help</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dollar_lambda.Args" href="#dollar_lambda.Args">Args</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.Args.parse_args" href="#dollar_lambda.Args.parse_args">parse_args</a></code></li>
<li><code><a title="dollar_lambda.Args.parser" href="#dollar_lambda.Args.parser">parser</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.CommandTree" href="#dollar_lambda.CommandTree">CommandTree</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.CommandTree.command" href="#dollar_lambda.CommandTree.command">command</a></code></li>
<li><code><a title="dollar_lambda.CommandTree.main" href="#dollar_lambda.CommandTree.main">main</a></code></li>
<li><code><a title="dollar_lambda.CommandTree.subcommand" href="#dollar_lambda.CommandTree.subcommand">subcommand</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.Parser" href="#dollar_lambda.Parser">Parser</a></code></h4>
<ul class="two-column">
<li><code><a title="dollar_lambda.Parser.__add__" href="#dollar_lambda.Parser.__add__">__add__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__or__" href="#dollar_lambda.Parser.__or__">__or__</a></code></li>
<li><code><a title="dollar_lambda.Parser.__rshift__" href="#dollar_lambda.Parser.__rshift__">__rshift__</a></code></li>
<li><code><a title="dollar_lambda.Parser.bind" href="#dollar_lambda.Parser.bind">bind</a></code></li>
<li><code><a title="dollar_lambda.Parser.empty" href="#dollar_lambda.Parser.empty">empty</a></code></li>
<li><code><a title="dollar_lambda.Parser.f" href="#dollar_lambda.Parser.f">f</a></code></li>
<li><code><a title="dollar_lambda.Parser.handle_error" href="#dollar_lambda.Parser.handle_error">handle_error</a></code></li>
<li><code><a title="dollar_lambda.Parser.helps" href="#dollar_lambda.Parser.helps">helps</a></code></li>
<li><code><a title="dollar_lambda.Parser.many" href="#dollar_lambda.Parser.many">many</a></code></li>
<li><code><a title="dollar_lambda.Parser.many1" href="#dollar_lambda.Parser.many1">many1</a></code></li>
<li><code><a title="dollar_lambda.Parser.optional" href="#dollar_lambda.Parser.optional">optional</a></code></li>
<li><code><a title="dollar_lambda.Parser.parse" href="#dollar_lambda.Parser.parse">parse</a></code></li>
<li><code><a title="dollar_lambda.Parser.parse_args" href="#dollar_lambda.Parser.parse_args">parse_args</a></code></li>
<li><code><a title="dollar_lambda.Parser.return_" href="#dollar_lambda.Parser.return_">return_</a></code></li>
<li><code><a title="dollar_lambda.Parser.usage" href="#dollar_lambda.Parser.usage">usage</a></code></li>
<li><code><a title="dollar_lambda.Parser.zero" href="#dollar_lambda.Parser.zero">zero</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>