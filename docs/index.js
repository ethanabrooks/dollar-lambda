URLS=[
"dollar_lambda/index.html",
"dollar_lambda/key_value.html",
"dollar_lambda/error.html",
"dollar_lambda/sequence.html",
"dollar_lambda/parser.html",
"dollar_lambda/result.html",
"dollar_lambda/args.html",
"dollar_lambda/decorators.html"
];
INDEX=[
{
"ref":"dollar_lambda",
"url":0,
"doc":"This package provides an alternative to [ argparse ](https: docs.python.org/3/library/argparse.html) based on parser combinators and functional first principles. Arguably,  $\u03bb is way more expressive than any reasonable person would ever need . but even if it's not the parser that we need, it's the parser we deserve.  Installation   pip install dollar-lambda    Highlights  $\u03bb comes with syntactic sugar that came make building parsers completely boilerplate-free. However, with more concise syntax comes less flexibility. For more complex parsing situations, there are modular building blocks that lie behind the syntactic sugar which enable parsers to handle any reasonable amount of logical complexity.  The [ @command ]( dollar_lambda.command) decorator This syntax is best for simple parsers that take a set of unordered arguments: >>> @command()  . def main(x: int, dev: bool = False, prod: bool = False):  . return dict(x=x, dev=dev, prod=prod) Here is the help text generated by this parser: >>> main(\"-h\") usage: -x X  dev  prod And here it is in action: >>> main(\"-x\", \"1\", \" dev\") {'x': 1, 'dev': True, 'prod': False}  Note Ordinarily you would provide  main no arguments and it would get them from the command line, as in: main() which would be equivalent to: main( sys.argv[1:]) In this document, the string arguments are for demonstration purposes only.  command takes arguments that allow you to supply help strings and custom types: >>> @command(types=dict(x=lambda x: int(x) + 1, help=dict(x=\"A number that gets incremented.\" )  . def main(x: int, dev: bool = False, prod: bool = False):  . return dict(x=x, dev=dev, prod=prod)  . >>> main(\"-h\") usage: -x X  dev  prod >>> main(\"-x\", \"1\", \" dev\") {'x': 2, 'dev': True, 'prod': False}   CommandTree for dynamic dispatch For many programs, a user will want to use one entrypoint for one set of arguments, and another for another set of arguments. Returning to our example, let's say we wanted to execute  prod_function when the user provides the   prod flag, and  dev_function when the user provides the   dev flag: >>> tree = CommandTree()  . >>> @tree.command()  . def base_function(x: int):  . print(\"Ran base_function with arguments:\", dict(x=x  . >>> @base_function.command()  . def prod_function(x: int, prod: bool):  . print(\"Ran prod_function with arguments:\", dict(x=x, prod=prod  . >>> @base_function.command()  . def dev_function(x: int, dev: bool):  . print(\"Ran dev_function with arguments:\", dict(x=x, dev=dev Let's see how this parser handles different inputs. If we provide the   prod flag,  $\u03bb automatically invokes  prod_function with the parsed arguments: >>> tree(\"-x\", \"1\", \" prod\") Ran prod_function with arguments: {'x': 1, 'prod': True} If we provide the   dev flag,  $\u03bb invokes  dev_function : >>> tree(\"-x\", \"1\", \" dev\") Ran dev_function with arguments: {'x': 1, 'dev': True} With this configuration, the parser will run  base_function if neither   prod nor   dev are given: >>> tree(\"-x\", \"1\") Ran base_function with arguments: {'x': 1} There are many other ways to use  CommandTree , including some that make use of the  base_function . To learn more, we recommend the [ CommandTree tutorial]( commandtree-tutorial).  Lower-level syntax [ @command ]( dollar_lambda.command) and  CommandTree cover many use cases, but they are both syntactic sugar for a lower-level interface that is far more expressive. Suppose you want to implement a parser that first tries to parse an option (a flag that takes an argument),  -x X and if that fails, tries to parse the input as a variadic sequence of floats: >>> p = (option(\"x\", type=int) | argument(\"y\", type=float).many( >> done() We go over this syntax in greater detail in the [tutorial]( tutorial). For now, suffice to say that  argument defines a positional argument, [ many ]( dollar_lambda.Parser.many) allows parsers to be applied zero or more times, and [ | ]( dollar_lambda.Parser.__or__) expresses alternatives. Here is the help text: >>> p.parse_args(\"-h\") usage: [-x X | [Y  . As promised, this succeeds: >>> p.parse_args(\"-x\", \"1\") {'x': 1} And this succeeds: >>> p.parse_args(\"1\", \"2\", \"3\", return_dict=False) [('y', 1.0), ('y', 2.0), ('y', 3.0)]  Tutorial We've already seen many of the concepts that power  $\u03bb in the [Highlights]( highlights) section. This tutorial will address these concepts one at a time and expose the reader to some nuances of usage.  An example from  argparse Many of you are already familiar with  argparse . You may even recognize this example from the  argparse docs:   import argparse parser = argparse.ArgumentParser(description=\"calculate X to the power of Y\") group = parser.add_mutually_exclusive_group() group.add_argument(\"-v\", \" verbose\", action=\"store_true\") group.add_argument(\"-q\", \" quiet\", action=\"store_true\") parser.add_argument(\"x\", type=int, help=\"the base\") parser.add_argument(\"y\", type=int, help=\"the exponent\") args = parser.parse_args()   Here is the exact equivalent in this package: >>> p = nonpositional(  . (flag(\"verbose\") | flag(\"quiet\" .optional(),  . option(\"x\", type=int, help=\"the base\"),  . option(\"y\", type=int, help=\"the exponent\"),  . ) >> done()  . >>> def main(x, y, verbose=False, quiet=False):  . return dict(x=x, y=y, verbose=verbose, quiet=quiet) Here is the help text: >>> p.parse_args(\"-h\") usage: [ verbose |  quiet] -x X -y Y x: the base y: the exponent As indicated, this succeeds given   verbose >>> main( p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\" {'x': 1, 'y': 2, 'verbose': True, 'quiet': False} or   quiet >>> main( p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" quiet\" {'x': 1, 'y': 2, 'verbose': False, 'quiet': True} or neither >>> main( p.parse_args(\"-x\", \"1\", \"-y\", \"2\" {'x': 1, 'y': 2, 'verbose': False, 'quiet': False} Let's walk through this step by step.  High-Level Parsers So far we've seen a few different parser constructors.  flag binds a boolean value to a variable whereas  option binds an arbitrary value to a variable.  done does not bind any values to variables, but only succeeds on the end of input.   flag >>> p = flag(\"verbose\") >>> p.parse_args(\" verbose\") {'verbose': True} By default  flag fails when it does not receive expected input: >>> p.parse_args() usage:  verbose The following arguments are required:  verbose Alternately, you can set a default value: >>> flag(\"verbose\", default=False).parse_args() {'verbose': False}   option  option is similar but takes an argument: By default,  option expects a single  - for single-character variable names (as in  -x ), as opposed to    for longer names (as in   xenophon ): >>> option(\"x\").parse_args(\"-x\", \"1\") {'x': '1'} >>> option(\"xenophon\").parse_args(\" xenophon\", \"1\") {'xenophon': '1'} Use the  type argument to convert the input to a different type: >>> option(\"x\", type=int).parse_args(\"-x\", \"1\")  converts \"1\" to an int {'x': 1}   done Without  done the parser will not complain about leftover (unparsed) input: >>> flag(\"verbose\").parse_args(\" verbose\", \" quiet\") {'verbose': True}   quiet is not parsed here but this does not cause the parser to fail. If we want to prevent leftover inputs, we can use  done : >>> (flag(\"verbose\") >> done( .parse_args(\" verbose\", \" quiet\") usage:  verbose Unrecognized argument:  quiet  done is usually necessary to get  nonpositional to behave in the way that you expect, but more on that later.  Parser Combinators Parser combinators are functions that combine multiple parsers into new, more complex parsers. Our example uses three such functions:  nonpositional , [ | ]( dollar_lambda.Parser.__or__) and [ >> ]( dollar_lambda.Parser.__rshift__).  [ | ]( dollar_lambda.Parser.__or__) The [ | ]( dollar_lambda.Parser.__or__) operator is used for alternatives. Specifically, it will try the first parser, and if that fails, try the second: >>> p = flag(\"verbose\") | flag(\"quiet\") >>> p.parse_args(\" quiet\")  flag(\"verbose\") fails {'quiet': True} >>> p.parse_args(\" verbose\")  flag(\"verbose\") succeeds {'verbose': True} By default one of the two flags would be required to prevent failure: >>> p.parse_args()  neither flag is provided so this fails usage: [ verbose |  quiet] The following arguments are required:  verbose We can permit the omission of both flags by using  optional , as we saw earlier, or we can supply a default value: >>> (flag(\"verbose\") | flag(\"quiet\" .optional().parse_args()  flags fail, but that's ok {} >>> (flag(\"verbose\") | flag(\"quiet\", default=False .parse_args()  flag(\"verbose\") fails but flag(\"quiet\", default=False) succeeds {'quiet': False} This is just sugar for >>> (flag(\"verbose\") | flag(\"quiet\") | defaults(quiet=False .parse_args()  flag(\"verbose\") fails but flag(\"quiet\", default=False) succeeds {'quiet': False}  [ >> ]( dollar_lambda.Parser.__rshift__) The [ >> ]( dollar_lambda.Parser.__rshift__) operator is used for sequential composition. It applies the first parser and then hands the output of the first parser to the second parser. If either parser fails, the composition fails: >>> p = flag(\"verbose\") >> done() >>> p.parse_args(\" verbose\") {'verbose': True} >>> p.parse_args(\" something-else\")  first parser will fail usage:  verbose Expected ' verbose'. Got ' something-else' >>> p.parse_args(\" verbose\", \" something-else\")  second parser will fail usage:  verbose Unrecognized argument:  something-else   nonpositional and [ + ]( dollar_lambda.Parser.__add__)  nonpositional takes a sequence of parsers as arguments and attempts all permutations of them, returning the first permutations that is successful: >>> p = nonpositional(flag(\"verbose\"), flag(\"quiet\" >>> p.parse_args(\" verbose\", \" quiet\") {'verbose': True, 'quiet': True} >>> p.parse_args(\" quiet\", \" verbose\")  reverse order also works {'quiet': True, 'verbose': True} For just two parsers you can use [ + ]( dollar_lambda.Parser.__add__) instead of  nonpositional : >>> p = flag(\"verbose\") + flag(\"quiet\") >>> p.parse_args(\" verbose\", \" quiet\") {'verbose': True, 'quiet': True} >>> p.parse_args(\" quiet\", \" verbose\")  reverse order also works {'quiet': True, 'verbose': True} This will not cover all permutations for more than two parsers: >>> p = flag(\"verbose\") + flag(\"quiet\") + option(\"x\") >>> p.parse_args(\" verbose\", \"-x\", \"1\", \" quiet\") usage:  verbose  quiet -x X Expected ' quiet'. Got '-x' To see why note the implicit parentheses: >>> p = (flag(\"verbose\") + flag(\"quiet\" + option(\"x\") In order to cover the case where  -x comes between   verbose and   quiet , use  nonpositional : >>> p = nonpositional(flag(\"verbose\"), flag(\"quiet\"), option(\"x\" >>> p.parse_args(\" verbose\", \"-x\", \"1\", \" quiet\")  works {'verbose': True, 'x': '1', 'quiet': True} If alternatives or defaults appear among the arguments to  nonpositional , you will probably want to add [ >> ]( dollar_lambda.Parser.__rshift__) followed by  done (or another parser) after  nonpositional . Otherwise, the parser will not behave as expected: >>> p = nonpositional(flag(\"verbose\", default=False), flag(\"quiet\" >>> p.parse_args(\" quiet\", \" verbose\")  you expect this to set verbose to True, but it doesn't {'verbose': False, 'quiet': True} Why is happening? There are two permutions: -  flag(\"verbose\", default=False) >> flag(\"quiet\") and -  flag(\"quiet\") >> flag(\"verbose\", default=False) In our example, both permutations are actually succeeding. This first succeeds by falling back to the default, and leaving the last word of the input,   verbose , unparsed. Either interpretation is valid, and  nonpositional returns one arbitrarily  just not the one we expected. Now let's add  >> done() to the end: >>> p = nonpositional(flag(\"verbose\", default=False), flag(\"quiet\" >> done() This ensures that the first permutation will fail because the leftover   verbose input will cause the  done parser to fail: >>> p.parse_args(\" quiet\", \" verbose\") {'quiet': True, 'verbose': True}  Putting it all together Let's recall the original example: >>> p = nonpositional(  . (flag(\"verbose\") | flag(\"quiet\" .optional(),  . option(\"x\", type=int, help=\"the base\"),  . option(\"y\", type=int, help=\"the exponent\"),  . ) >> done()  . >>> def main(x, y, verbose=False, quiet=False):  . return dict(x=x, y=y, verbose=verbose, quiet=quiet) As we've seen,  (flag(\"verbose\") | flag(\"quiet\" .optional() succeeds on either   verbose or   quiet or neither.  option(\"x\", type=int) succeeds on  -x X , where  X is some integer, binding that integer to the variable  \"x\" . Similarly for  option(\"y\", type=int) .  nonpositional takes the three parsers: -  (flag(\"verbose\") | flag(\"quiet\" .optional() -  option(\"x\", type=int) -  option(\"y\", type=int) and applies them in every order, until some order succeeds. Finally  done() ensures that only one of these parser permutations will succeed, preventing ambiguity.  Variations on the example  Variable numbers of arguments What if there was a special argument,  verbosity , that only makes sense if the user chooses   verbose ? >>> p = (  . nonpositional(  .  flag(\"verbose\") + option(\"verbosity\", type=int | flag(\"quiet\" ,  . option(\"x\", type=int),  . option(\"y\", type=int),  . )  . >> done()  . ) Remember that [ + ]( dollar_lambda.Parser.__add__) evaluates two parsers in both orders and stopping at the first order that succeeds. So this allows us to supply   verbose and   verbosity in any order. >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" quiet\") {'x': 1, 'y': 2, 'quiet': True} >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\", \" verbosity\", \"3\") {'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3} >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\") usage: [ verbose  verbosity VERBOSITY |  quiet] -x X -y Y Expected ' verbose'. Got '-x' This is also a case where you might want to use  CommandTree : >>> tree = CommandTree()  . >>> @tree.command(help=dict(x=\"the base\", y=\"the exponent\"  . def base_function(x: int, y: int):  . raise RuntimeError(\"This function will not execute.\")  . >>> @base_function.command()  . def verbose_function(x: int, y: int, verbose: bool, verbosity: int):  . print(dict(x=x, y=y, verbose=verbose, verbosity=verbosity  . >>> @base_function.command()  . def quiet_function(x: int, y: int, quiet: bool):  . print(dict(x=x, y=y, quiet=quiet  . >>> tree(\"-x\", \"1\", \"-y\", \"2\", \" verbose\", \" verbosity\", \"3\") {'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3}   Parser.many What if we want to specify verbosity by the number of times that   verbose appears? For this we need  Parser.many . Before showing how we could use  Parser.many in this setting, let's look at how it works.  parser.many takes  parser and tries to apply it as many times as possible.  Parser.many is a bit like the  pattern, if you are familiar with regexes.  parser.many always succeeds: >>> p = flag(\"verbose\").many() >>> p.parse_args()  succeeds {} >>> p.parse_args(\"blah\")  still succeeds {} >>> p.parse_args(\" verbose\", \"blah\")  still succeeds {'verbose': True} >>> p.parse_args(\" verbose\", \" verbose\", return_dict=False) [('verbose', True), ('verbose', True)] As you can see,  return_dict=False returns a list of tuples instead of a dict, so that you can have duplicate keys. Now returning to the original example: >>> p = (  . nonpositional(  . flag(\"verbose\").many(),  . option(\"x\", type=int),  . option(\"y\", type=int),  . )  . >> done()  . ) >>> args = p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\", \" verbose\", return_dict=False) >>> args [('x', 1), ('y', 2), ('verbose', True), ('verbose', True)] >>> verbosity = args.count 'verbose', True >>> verbosity 2   Parser.many1 In the previous example, the parse will default to  verbosity=0 if no   verbose flags are given. What if we wanted users to be explicit about choosing a \"quiet\" setting? In other words, what if the user actually had to provide an explicit   quiet flag when no   verbose flags were given? For this, we use  Parser.many1 . This method is like  Parser.many except that it fails when on zero successes (recall that  Parser.many always succeeds). So if  Parser.many is like regex  ,  Parser.many1 is like [ + ]( dollar_lambda.Parser.__add__). Take a look: >>> p = flag(\"verbose\").many() >>> p.parse_args()  succeeds {} >>> p = flag(\"verbose\").many1() >>> p.parse_args()  fails usage:  verbose [ verbose  .] The following arguments are required:  verbose >>> p.parse_args(\" verbose\")  succeeds {'verbose': True} To compell that   quiet flag from our users, we can do the following: >>> p = (  . nonpositional(  .  flag(\"verbose\").many1( | flag(\"quiet\" ,  . option(\"x\", type=int),  . option(\"y\", type=int),  . )  . >> done()  . ) Now omitting both   verbose and   quiet will fail: >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\") usage: [ verbose [ verbose  .] |  quiet] -x X -y Y Expected ' verbose'. Got '-x' >>> p.parse_args(\" verbose\", \"-x\", \"1\", \"-y\", \"2\")  this succeeds {'verbose': True, 'x': 1, 'y': 2} >>> p.parse_args(\" quiet\", \"-x\", \"1\", \"-y\", \"2\")  and this succeeds {'quiet': True, 'x': 1, 'y': 2}   CommandTree Tutorial  CommandTree has already shown up in the [Highlights section]( commandtree-for-dynamic-dispatch) and in the earlier [tutorial]( variations-on-the-example). In this section we will give a more thorough treatment, exposing some of the underlying logic and covering all the variations in functionality that  CommandTree offers.   CommandTree.command First let's walk through the use of the  CommandTree.command decorator, one step at a time. First we define the object: >>> tree = CommandTree() Now we define at least one child function: >>> @tree.command()  . def f1(a: int):  . return dict(f1=dict(a=a At this point  tree is just a parser that takes a single option  -a : >>> tree(\"-h\") usage: -a A Now let's add a second child function: >>> @tree.command()  . def f2(b: bool):  . return dict(f2=dict(b=b  . >>> tree(\"-h\") usage: [-a A | -b]  tree will execute either  f1 or  f2 based on which of the parsers succeeds. This will execute  f1 : >>> tree(\"-a\", \"1\") {'f1': {'a': 1 This will execute  f2 : >>> tree(\"-b\") {'f2': {'b': True This fails: >>> tree() usage: [-a A | -b] The following arguments are required: -a Often in cases where there are alternative sets of argument like this, there is also a set of shared arguments. It would be cumbersome to have to repeat these for both child functions. Instead we can define a parent function as follows: >>> tree = CommandTree()  . >>> @tree.command()  . def f1(a: int):  . raise RuntimeError(\"This function will not execute.\") And a child function,  g1 : >>> @f1.command()  note f1, not tree  . def g1(a:int, b: bool):  . return dict(g1=dict(b=b Make sure to include all the arguments of  f1 in  g1 or else  g1 will fail when it is invoked. In its current state,  tree sequences the arguments of  f1 and  g1 : >>> tree(\"-h\") usage: -a A -b As before we can define an additional child function to induce alternative argument sets: >>> @f1.command()  note f1, not tree  . def g2(a: int, c: str):  . return dict(g2=dict(c=c Note that our usage message shows  -a A preceding the brackets: >>> tree(\"-h\") usage: -a A [-b | -c C] To execute  g1 , we give the  -b flag: >>> tree(\"-a\", \"1\", \"-b\") {'g1': {'b': True To execute  g2 , we give the  -c flag: >>> tree(\"-a\", \"1\", \"-c\", \"foo\") {'g2': {'c': 'foo' Also, note that  tree can have arbitrary depth: >>> @g1.command()  h1 is a child of g1  . def h1(a: int, b: bool, d: float):  . return dict(h1=dict(d=d >>> tree(\"-h\") usage: -a A [-b -d D | -c C]   CommandTree.subcommand Often we want to explicitly specify which function to execute by naming it on the command line. This would implement functionality similar to [ ArgumentParser.add_subparsers ](https: docs.python.org/3/library/argparse.html argparse.ArgumentParser.add_subparsers) For this we would use the  CommandTree.subcommand decorator: >>> tree = CommandTree()  . >>> @tree.command()  . def f1(a: int):  . raise RuntimeError(\"This function should not be called\")  . >>> @f1.subcommand()  note subcommand, not command  . def g1(a:int, b: bool):  . return dict(g1=dict(b=b  . >>> @f1.subcommand()  again, subcommand, not command  . def g2(a: int, c: str):  . return dict(g2=dict(c=c Now the usage message indicates that  g1 and  g2 are required arguments: >>> tree(\"-h\") usage: -a A [g1 -b | g2 -c C] Now we would select g1 as follows: >>> tree(\"-a\", \"1\", \"g1\", \"-b\") {'g1': {'b': True And g2 as follows: >>> tree(\"-a\", \"1\", \"g2\", \"-c\", \"foo\") {'g2': {'c': 'foo'  Why  $\u03bb ?  $\u03bb can handle many kinds of argument-parsing patterns that are either very awkward, difficult, or impossible with other parsing libraries. In particular, we emphasize the following qualities:  Versatile  $\u03bb provides high-level functionality equivalent to other parsers. But unlike other parsers, it permits low-level customization to handle arbitrarily complex parsing patterns. There are many parsing patterns that  $\u03bb can handle which are not possible with other parsing libraries.  Type-safe  $\u03bb uses type annotations as much as Python allows. Types are checked using [ MyPy ]( https: mypy.readthedocs.io/en/stable/index.html ) and exported with the package so that users can also benefit from the type system. Furthermore, with rare exceptions,  $\u03bb avoids mutations and side-effects and preserves [referential transparency](https: en.wikipedia.org/wiki/Referential_transparency). This makes it easier for the type-checker _and for the user_ to reason about the code.  Concise  $\u03bb provides many syntactic shortcuts for cutting down boilerplate: - operators like [ >> ]( dollar_lambda.Parser.__rshift__), [ | ]( dollar_lambda.Parser.__or__), and [ + ]( dollar_lambda.Parser.__add__) (and [ >= ]( dollar_lambda.Parser.__ge__) if you want to get fancy) - the  command decorator and the  CommandTree object for building tree-shaped parsers - the  Args syntax built on top of python  dataclasses . As a rule,  $\u03bb avoids reproducing python functionality and focuses on the main job of an argument parser: parsing."
},
{
"ref":"dollar_lambda.Parser",
"url":0,
"doc":"Main class powering the argument parser."
},
{
"ref":"dollar_lambda.Parser.f",
"url":0,
"doc":""
},
{
"ref":"dollar_lambda.Parser.usage",
"url":0,
"doc":""
},
{
"ref":"dollar_lambda.Parser.helps",
"url":0,
"doc":""
},
{
"ref":"dollar_lambda.Parser.__add__",
"url":0,
"doc":"Parse two arguments in either order. >>> p = flag(\"verbose\") + flag(\"debug\") >>> p.parse_args(\" verbose\", \" debug\") {'verbose': True, 'debug': True} >>> p.parse_args(\" debug\", \" verbose\") {'debug': True, 'verbose': True} >>> p.parse_args(\" debug\") usage:  verbose  debug Expected ' verbose'. Got ' debug' Note that if more than two arguments are chained together with  + , some combinations will not parse: >>> p = flag(\"a\") + flag(\"b\") + flag(\"c\") >>> p.parse_args(\"-c\", \"-a\", \"-b\")  this works {'c': True, 'a': True, 'b': True} >>> p.parse_args(\"-a\", \"-c\", \"-b\")  this doesn't usage: -a -b -c Expected '-b'. Got '-c' This makes more sense when one supplies the implicit parentheses: >>> p = (flag(\"a\") + flag(\"b\" + flag(\"c\") In order to chain together more than two arguments, use  nonpositional : >>> p = nonpositional(flag(\"a\"), flag(\"b\"), flag(\"c\" >>> p.parse_args(\"-a\", \"-c\", \"-b\") {'a': True, 'c': True, 'b': True}",
"func":1
},
{
"ref":"dollar_lambda.Parser.__or__",
"url":0,
"doc":"Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails. >>> from dollar_lambda import argument, option, done, flag >>> p = option(\"option\") | flag(\"verbose\") >>> p.parse_args(\" option\", \"x\") {'option': 'x'} >>> p.parse_args(\" verbose\") {'verbose': True} Note that when both arguments are supplied, this will only parse the first: >>> p.parse_args(\" verbose\", \" option\", \"x\") {'verbose': True} If you want this to fail, use  >> ( Parser.__rshift__ ) with  done() or another parser: >>> (p >> done( .parse_args(\" verbose\", \" option\", \"x\") usage: [ option OPTION |  verbose] Unrecognized argument:  option >>> p.parse_args(\" option\", \"x\") {'option': 'x'}",
"func":1
},
{
"ref":"dollar_lambda.Parser.__rshift__",
"url":0,
"doc":"This applies parsers in sequence. If the first parser succeeds, the unparsed remainder gets handed off to the second parser. If either parser fails, the whole thing fails. >>> from dollar_lambda import argument, flag >>> p = argument(\"first\") >> argument(\"second\") >>> p.parse_args(\"a\", \"b\") {'first': 'a', 'second': 'b'} >>> p.parse_args(\"a\") usage: FIRST SECOND The following arguments are required: second >>> p.parse_args(\"b\") usage: FIRST SECOND The following arguments are required: second",
"func":1
},
{
"ref":"dollar_lambda.Parser.__ge__",
"url":0,
"doc":"Return self>=value.",
"func":1
},
{
"ref":"dollar_lambda.Parser.bind",
"url":0,
"doc":"Returns a new parser that 1. applies  self ; 2. if this succeeds, applies  f to the parsed component of the result.  bind is one of the functions that makes  Parser a [ Monad ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L16). But most users will avoid using it directly, preferring higher level combinators like  >> ( Parser.__rshift__ ),  | ( Parser.__or__ ) and  + ( Parser.__add__ ). Note that  >= as a synonym for  bind (as defined in [ pytypeclass ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L26 and we typically prefer using the infix operator to the spelled out method. Let's start with our simplest parser,  argument : >>> p1 = argument(\"some_dest\") Now let's use the  equals parser to write a function that takes the output of  p1 and fails unless the next argument is the same as the first: >>> def f(kvs: Sequence(KeyValue[str] -> Parser[Sequence[KeyValue[str ]:  . [kv] = kvs  . return equals(kv.value) >>> p = p1 >= f >>> p.parse_args(\"a\", \"a\") {'a': 'a'} >>> p.parse_args(\"a\", \"b\") Expected 'a'. Got 'b'",
"func":1
},
{
"ref":"dollar_lambda.Parser.empty",
"url":0,
"doc":"Always returns {}, no matter the input. Mostly useful for use in  nonpositional . >>> empty().parse_args(\"any\", \"arguments\") {}",
"func":1
},
{
"ref":"dollar_lambda.Parser.handle_error",
"url":0,
"doc":"",
"func":1
},
{
"ref":"dollar_lambda.Parser.many",
"url":0,
"doc":"Applies  self zero or more times (like  in regexes). >>> from dollar_lambda import argument, flag >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args(return_dict=False) [] >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args(\"a\", return_dict=False) [('as-many-as-you-like', 'a')] >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args(\"a\", \"b\", return_dict=False)  return_dict=False allows duplicate keys [('as-many-as-you-like', 'a'), ('as-many-as-you-like', 'b')] Note that if  self contains  Parser.__or__ , the arguments can be heterogenous: >>> p = flag(\"verbose\") | flag(\"quiet\") >>> p = p.many() >>> p.parse_args(\" verbose\", \" quiet\", return_dict=False)  mix  verbose and  quiet [('verbose', True), ('quiet', True)]",
"func":1
},
{
"ref":"dollar_lambda.Parser.many1",
"url":0,
"doc":"Applies  self one or more times (like  + in regexes). >>> from dollar_lambda import argument, flag >>> p = argument(\"1-or-more\").many1() >>> p.parse_args(\"1\") {'1-or-more': '1'} >>> p.parse_args(\"1\", \"2\", return_dict=False)  return_dict=False allows duplicate keys [('1-or-more', '1'), ('1-or-more', '2')] >>> p.parse_args() usage: 1-OR-MORE [1-OR-MORE  .] The following arguments are required: 1-or-more",
"func":1
},
{
"ref":"dollar_lambda.Parser.optional",
"url":0,
"doc":"Allows arguments to be optional: >>> p1 = flag(\"optional\") >> done() >>> p = p1.optional() >>> p.parse_args(\" optional\") {'optional': True} >>> p.parse_args(\" misspelled\")  succeeds with no output {} >>> p1.parse_args(\" misspelled\") usage:  optional Expected ' optional'. Got ' misspelled'",
"func":1
},
{
"ref":"dollar_lambda.Parser.parse",
"url":0,
"doc":"Applies the parser to the input sequence  cs .",
"func":1
},
{
"ref":"dollar_lambda.Parser.parse_args",
"url":0,
"doc":"The main way the user extracts parsed results from the parser. Parameters      args : str A sequence of strings to parse. If empty, defaults to  sys.argv[1:] . return_dict : bool Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys. The tuples are  KeyValueTuple namedtuples, with fields  key and  value . check_help : bool Before running the parser, checks if the input string is   help or  -h . If it is, returns the usage message. Examples     >>> argument(\"a\").parse_args(\"-h\") usage: A >>> argument(\"a\").parse_args(\" help\") usage: A",
"func":1
},
{
"ref":"dollar_lambda.Parser.return_",
"url":0,
"doc":"This method is required to make  Parser a [ Monad ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L16). It consumes none of the input and always returns  a as the result. For the most part, the user will not use this method unless building custom parsers. >>> from dollar_lambda.key_value import KeyValue >>> Parser.return_ [KeyValue(\"some-key\", \"some-value\")] .parse_args() {'some-key': 'some-value'}",
"func":1
},
{
"ref":"dollar_lambda.Parser.zero",
"url":0,
"doc":"This parser always fails. This method is necessary to make  Parser a [ Monoid ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py L13). Parameters      error : Optional[ArgumentError] Customize the error returned by  zero . >>> Parser.zero().parse_args() zero >>> Parser.zero().parse_args(\"a\") zero >>> Parser.zero(error=ArgumentError(\"This is a test.\" .parse_args(\"a\") This is a test.",
"func":1
},
{
"ref":"dollar_lambda.empty",
"url":0,
"doc":"Always returns {}, no matter the input. Mostly useful for use in  nonpositional . >>> empty().parse_args(\"any\", \"arguments\") {}",
"func":1
},
{
"ref":"dollar_lambda.apply",
"url":0,
"doc":"Takes the output of  parser and applies  f to it. Convert any errors that arise into  ArgumentError . >>> p1 = flag(\"hello\") >>> p1.parse_args(\" hello\", return_dict=False) [('hello', True)] This will double  p1 's output: >>> p2 = apply(lambda kv: Result.return_(kv + kv), p1) >>> p2.parse_args(\" hello\", return_dict=False) [('hello', True), ('hello', True)]",
"func":1
},
{
"ref":"dollar_lambda.apply_item",
"url":0,
"doc":"A shortcut for  apply(f, item(description  and spares  f the trouble of outputting a  Result object. >>> p1 = argument(\"foo\") >>> p1.parse_args(\"bar\", return_dict=False) [('foo', 'bar')] Here we use  f to directly manipulate the binding generated by  item : >>> p2 = apply_item(lambda bar: [KeyValue(bar + \"e\", bar + \"f\")], description=\"baz\") >>> p2.parse_args(\"bar\", return_dict=False) [('bare', 'barf')]",
"func":1
},
{
"ref":"dollar_lambda.argument",
"url":0,
"doc":"Parses a single word and binds it to  dest . Useful for positional arguments. Parameters      dest : str The name of variable to bind to: help : Optional[str] The help message to display for the option: type : Optional[Callable str], Any Use the  type argument to convert the input to a different type: >>> argument(\"name\").parse_args(\"Alice\") {'name': 'Alice'} >>> argument(\"name\").parse_args() usage: NAME The following arguments are required: name",
"func":1
},
{
"ref":"dollar_lambda.done",
"url":0,
"doc":" done succeds on the end of input and fails on everything else. >>> done().parse_args() {} >>> done().parse_args(\"arg\") Unrecognized argument: arg Without  done the parser will not complain about leftover (unparsed) input: >>> flag(\"verbose\").parse_args(\" verbose\", \" quiet\") {'verbose': True}   quiet is not parsed here but this does not cause the parser to fail. If we want to prevent leftover inputs, we can use  done : >>> (flag(\"verbose\") >> done( .parse_args(\" verbose\", \" quiet\") usage:  verbose Unrecognized argument:  quiet  done is usually necessary to get  nonpositional to behave in the way that you expect. See  nonpositional API docs for details.",
"func":1
},
{
"ref":"dollar_lambda.equals",
"url":0,
"doc":"Checks if the next word is  s . >>> equals(\"hello\").parse_args(\"hello\") {'hello': 'hello'} >>> equals(\"hello\").parse_args(\"goodbye\") usage: hello Expected 'hello'. Got 'goodbye' Parameters      s: str The word to that input will be checked against for equality. peak : bool If  False , then the parser will consume the word and return the remaining words as  unparsed . If  True , then the parser leaves the  unparsed component unchanged. Examples     >>> p = equals(\"hello\") >> equals(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") {'hello': 'hello', 'goodbye': 'goodbye'} Look what happens when  peak=True : >>> p = equals(\"hello\", peak=True) >> equals(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") usage: hello goodbye Expected 'goodbye'. Got 'hello' The first parser didn't consume the word and so \"hello\" got passed on to  equals(\"goodbye\") . But this would work: >>> p = equals(\"hello\", peak=True) >> equals(\"hello\") >>equals(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") {'hello': 'hello', 'goodbye': 'goodbye'}",
"func":1
},
{
"ref":"dollar_lambda.flag",
"url":0,
"doc":"Binds a boolean value to a variable. >>> p = flag(\"verbose\") >>> p.parse_args(\" verbose\") {'verbose': True} Parameters      dest : str The variable to which the value will be bound. default : Optional[bool] An optional default value. help : Optional[str] An optional help string. short : bool Whether to check for the short form of the flag, which uses a single dash and the first character of  dest , e.g.  -f for  foo . string : Optional[str] A custom string to use for the flag. Defaults to   {dest} . Examples     Here is an example using the  default parameter: >>> p = flag(\"verbose\", default=False) >>> p.parse_args() {'verbose': False} By default  flag fails when it does not receive expected input: >>> p = flag(\"verbose\") >>> p.parse_args() usage:  verbose The following arguments are required:  verbose Here is an example using the  help parameter: >>> p = flag(\"verbose\", help=\"Turn on verbose output.\") >>> p.parse_args(\"-h\") usage:  verbose verbose: Turn on verbose output. Here is an example using the  short parameter: >>> flag(\"verbose\", short=True).parse_args(\"-v\")  this is the default {'verbose': True} >>> flag(\"verbose\", short=False).parse_args(\"-v\")  fails usage:  verbose Expected ' verbose'. Got '-v' Here is an example using the  string parameter: >>> flag(\"value\", string=\"v\").parse_args(\"v\")  note that string does not have to start with - {'value': True}",
"func":1
},
{
"ref":"dollar_lambda.item",
"url":0,
"doc":"Parses a single word and binds it to  dest . One of the lowest level building blocks for parsers. Parameters      help_name : Optional[str] Used for generating help text Examples     >>> p = item(\"name\", help_name=\"Your first name\") >>> p.parse_args(\"Alice\") {'name': 'Alice'} >>> p.parse_args() usage: name The following arguments are required: Your first name",
"func":1
},
{
"ref":"dollar_lambda.nonpositional",
"url":0,
"doc":" nonpositional takes a sequence of parsers as arguments and attempts all permutations of them, returning the first permutations that is successful: >>> p = nonpositional(flag(\"verbose\"), flag(\"quiet\" >>> p.parse_args(\" verbose\", \" quiet\") {'verbose': True, 'quiet': True} >>> p.parse_args(\" quiet\", \" verbose\")  reverse order also works {'quiet': True, 'verbose': True} If alternatives or defaults appear among the arguments to  nonpositional , you will probably want to add  >> followed by  done (or another parser) after  nonpositional . Otherwise, the parser will not behave as expected: >>> p = nonpositional(flag(\"verbose\", default=False), flag(\"quiet\" >>> p.parse_args(\" quiet\", \" verbose\")  you expect this to set verbose to True, but it doesn't {'verbose': False, 'quiet': True} Why is happening? There are two permutions: -  flag(\"verbose\", default=False) >> flag(\"quiet\") and -  flag(\"quiet\") >> flag(\"verbose\", default=False) In our example, both permutations are actually succeeding. This first succeeds by falling back to the default, and leaving the last word of the input,   verbose , unparsed. Either interpretation is valid, and  nonpositional returns one arbitrarily  just not the one we expected. Now let's add  >> done() to the end: >>> p = nonpositional(flag(\"verbose\", default=False), flag(\"quiet\" >> done() This ensures that the first permutation will fail because the leftover   verbose input will cause the  done parser to fail: >>> p.parse_args(\" quiet\", \" verbose\") {'quiet': True, 'verbose': True}",
"func":1
},
{
"ref":"dollar_lambda.option",
"url":0,
"doc":"Parses two words, binding the second to the first. Parameters      dest : str The name of variable to bind to: flag : Optional[str] The flag to use for the option. If not provided, defaults to   {dest} . default : Optional[Any] The default value to bind on failure: help : Optional[str] The help message to display for the option: short : bool Whether to check for the short form of the flag, which uses a single dash and the first character of  dest , e.g.  -c for  count . type : Callable str], Any] Use the  type argument to convert the input to a different type: Examples     >>> option(\"count\").parse_args(\" count\", \"1\") {'count': '1'} In this example, you can see that the  flag parameter allows the user to specify an arbitrary lead string, including one that doesn't start with a dash. >>> option(\"count\", flag=\"ct\").parse_args(\"ct\", \"1\") {'count': '1'} This example demonstrates the use of the  default parameter: >>> option(\"count\", default=2).parse_args() {'count': 2} Here we specify a help-string using the  help parameter: >>> option(\"count\", help=\"The number we should count to\").parse_args(\"-h\") usage:  count COUNT count: The number we should count to This example demonstrates the difference between  short=True and  short=False : >>> option(\"count\", short=True).parse_args(\"-c\", \"1\") {'count': '1'} >>> option(\"count\", short=False).parse_args(\"-c\", \"1\") usage:  count COUNT Expected ' count'. Got '-c' As with [argparse](https: docs.python.org/3/library/argparse.html argument-parsing), the  type argument allows you to convert the input to a different type using a function that takes a single string argument: >>> option(\"x\", type=int).parse_args(\"-x\", \"1\")  converts \"1\" to an int {'x': 1} >>> option(\"x\", type=lambda x: int(x) + 1).parse_args(\"-x\", \"1\") {'x': 2}",
"func":1
},
{
"ref":"dollar_lambda.sat",
"url":0,
"doc":"Applies  parser , applies a predicate to the result and fails if this returns false. >>> p = sat(  . option(\"x\", type=int).many(),  . lambda kvs: sum([kv.value for kv in kvs]) > 0,  . lambda x: ArgumentError(f\"The values in {list(x)} must sum to more than 0.\"),  . ) >>> p.parse_args(\"-x\", \"-1\", \"-x\", \"1\")  fails usage: [-x X  .] The values in [KeyValue(key='x', value=-1), KeyValue(key='x', value=1)] must sum to more than 0. >>> p.parse_args(\"-x\", \"-1\", \"-x\", \"2\")  succeeds {'x': 2} Parameters      parser : Parser[A] The parser to apply. predicate : Callable A], bool] The predicate to apply to the result of  parser .  sat fails if this predicate returns false. on_fail : Callable A], ArgumentError] A function producing an ArgumentError to return if the predicate fails. Takes the output of  parser as an argument.",
"func":1
},
{
"ref":"dollar_lambda.sat_item",
"url":0,
"doc":"A wrapper around  sat that uses  item to parse the argument and just applies  predicate to the value output by  item . >>> p = sat_item(lambda x: len(x)  1, lambda x: ArgumentError(f\"'{x}' must have exactly one character.\"), \"x\") >>> p.parse_args(\"a\")  succeeds {'x': 'a'} >>> p.parse_args(\"aa\")  fails usage: x 'aa' must have exactly one character. Parameters      predicate : Callable A], bool] The predicate to apply to the result of  item .  sat fails if this predicate returns false. on_fail : Callable A], ArgumentError] A function producing an ArgumentError to return if the predicate fails. Takes the output of  item as an argument. name: str The value to bind the result to.",
"func":1
},
{
"ref":"dollar_lambda.type_",
"url":0,
"doc":"A wrapper around  apply that simply applies  f to the value of the most recently parsed input. >>> p1 = option(\"x\") >> option(\"y\") >>> p = type_(int, p1) >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\")  converts \"1\" but not \"2\" {'y': '2', 'x': 1}",
"func":1
},
{
"ref":"dollar_lambda.Args",
"url":0,
"doc":" Args is sugar for the  nonpositional function and removes much of the boilerplate from defining parsers with many arguments. >>> @dataclass  . class MyArgs(Args):  . verbose: bool  . count: int >>> MyArgs.parse_args(\" verbose\", \" count\", \"1\") {'verbose': True, 'count': 1}  MyArgs will accept these arguments in any order: >>> MyArgs.parse_args(\" count\", \"1\", \" verbose\") {'count': 1, 'verbose': True} Note that when the default value of an argument is  True ,  Args will, by default add   no- to the front of the flag (while still assigning the value to the original key): >>> @dataclass  . class MyArgs(Args):  . tests: bool = True >>> MyArgs.parse_args(\" no-tests\") {'tests': False} >>> MyArgs.parse_args() {'tests': True} To suppress this behavior, set  flip_bools=False : >>> MyArgs.parse_args(\" tests\", flip_bools=False) {'tests': False} By using the  Args.parser() method,  Args can take advantage of all the same combinators as other parsers: >>> from dollar_lambda import argument >>> p = MyArgs.parser() >>> p1 = p >> argument(\"a\") >>> p1.parse_args(\" no-tests\", \"hello\") {'tests': False, 'a': 'hello'} To supply other metadata, like  help text and more complex  type converters, use  field : >>> @dataclass  . class MyArgs(Args):  . n: int = field(default=0, help=\"a number to increment\", type=lambda x: 1 + int(x >>> MyArgs.parse_args(\"-n\", \"1\") {'n': 2} >>> MyArgs.parse_args() {'n': 1}"
},
{
"ref":"dollar_lambda.Args.parser",
"url":0,
"doc":"Returns a parser for the dataclass. Converts each field to a parser ( option or  flag depending on its type). Combines these parsers using  nonpositional . Parameters      flip_bools: bool Whether to add   no-  before arguments that default to  True . Examples     >>> @dataclass  . class MyArgs(Args):  . tests: bool = True Note the leading   no- : >>> MyArgs.parse_args(\" no-tests\") {'tests': False} >>> MyArgs.parse_args() {'tests': True} To suppress this behavior, set  flip_bools=False : >>> MyArgs.parse_args(\" tests\", flip_bools=False) {'tests': False}",
"func":1
},
{
"ref":"dollar_lambda.Args.parse_args",
"url":0,
"doc":"Parses the arguments and returns a dictionary of the parsed values.",
"func":1
},
{
"ref":"dollar_lambda.defaults",
"url":0,
"doc":"Useful for assigning default values to arguments. It ignore the input and always returns  kwargs converted into  Sequence[KeyValue] .  defaults never fails. >>> defaults(a=1, b=2).parse_args() {'a': 1, 'b': 2} >>> (flag(\"fails\") | defaults(fails=\"succeeds\" .parse_args() {'fails': 'succeeds'} Here's a more complex example derived from the tutorial: >>> p = nonpositional(  . (  . flag(\"verbose\") + defaults(quiet=False)  either  verbose and default \"quiet\" to False  . | flag(\"quiet\") + defaults(verbose=False)  or  quiet and default \"verbose\" to False  . ),  . option(\"x\", type=int, help=\"the base\"),  . option(\"y\", type=int, help=\"the exponent\"),  . ) >> done() >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\") {'x': 1, 'y': 2, 'verbose': True, 'quiet': False}",
"func":1
},
{
"ref":"dollar_lambda.field",
"url":0,
"doc":"This is a thin wrapper around [ dataclasses.field ](https: docs.python.org/3/library/dataclasses.html dataclasses.field). Parameters      help : str An optional help string for the argument. metadata : str Identical to the  metadata argument for [ dataclasses.field ](https: docs.python.org/3/library/dataclasses.html dataclasses.field). type : Optional[type | Callable str], Any A function that takes a string and returns a value just like the  type argument for [ ArgumentParser.add_argument ](https: docs.python.org/3/library/argparse.html type). Returns    - A  dataclasses.Field object that can be used in place of a default argument as described in the [ dataclasses.Field documentation](https: docs.python.org/3/library/dataclasses.html dataclasses.field).",
"func":1
},
{
"ref":"dollar_lambda.wrap_help",
"url":0,
"doc":"This checks for the   help or  -h flag before applying  parser . If either of the flags is present, returns the usage message for  parser . >>> p = wrap_help(flag(\"help\", help=\"Print this help message.\" >>> p.parse_args(\" help\") usage:  help help: Print this help message. >>> p.parse_args(\"-h\") usage:  help help: Print this help message. We can use  wrap_help to print partial usage messages, e.g. for subcommands: >>> subcommand1 = equals(\"subcommand1\") >> wrap_help(option(\"option1\" >>> subcommand2 = equals(\"subcommand2\") >> wrap_help(option(\"option2\" >>> p = subcommand1 | subcommand2 >>> p.parse_args(\"subcommand1\", \"-h\") usage:  option1 OPTION1 >>> p.parse_args(\"subcommand2\", \"-h\") usage:  option2 OPTION2",
"func":1
},
{
"ref":"dollar_lambda.command",
"url":0,
"doc":"A succinct way to generate a simple  nonpositional parser.  @command derives the component parsers from the function's signature and automatically executes the function with the parsed arguments, if parsing succeeds: >>> @command(help=dict(a=\"something about a\"), types=dict(a=lambda x: int(x) + 1  . def f(a: int = 1, b: bool = False):  . return dict(a=a, b=b) >>> f(\"-a\", \"2\", \"-b\") {'a': 3, 'b': True} If the wrapped function receives no arguments (as in  f() ), the parser will take  sys.argv[1:] as the input. Note that  @command does not handle mutually exclusive arguments or alternative arguments. Parameters      flip_bools : bool For boolean arguments that default to true, this changes the flag from   {dest} to   no-{dest} : help : dict[str, str] A dictionary of help strings for the arguments. strings : dict[str, str] This dictionary maps variable names to the strings that the parser will look for in the input. types: dict[str, Callable str], Any This dictionary maps variable names to custom type converters. Examples     >>> @command()  . def f(cuda: bool = True):  . return dict(cuda=cuda) >>> f() {'cuda': True} >>> f(\" no-cuda\")  flip_bools adds  no- to the flag {'cuda': False} As the following example demonstrates, when  flip_bools=False output can be somewhat confusing: >>> @command(flip_bools=False)  . def f(cuda: bool = True):  . return dict(cuda=cuda) >>> f(\" cuda\") {'cuda': False} Here is an example using the  help parameter: >>> @command(help=dict(quiet=\"Be quiet\"  . def f(quiet: bool):  . return dict(quiet=quiet) >>> f(\" help\") usage:  quiet quiet: Be quiet Here is an example using the  strings parameter: >>> @command(strings=dict(quiet=\" quiet-mode\"  . def f(quiet: bool):  . return dict(quiet=quiet) >>> f(\" quiet-mode\") {'quiet': True} >>> f(\" quiet\") usage:  quiet-mode Expected ' quiet-mode'. Got ' quiet' Here is an example using the  type parameter: >>> @command(types=dict(x=lambda x: int(x) + 1  . def f(x: int):  . return dict(x=x) >>> f(\"-x\", \"0\") {'x': 1}",
"func":1
},
{
"ref":"dollar_lambda.CommandTree",
"url":0,
"doc":"Allows parsers to dynamically dispatch their results based on the input. For usage details, see the [ CommandTree tutorial]( commandtree-tutorial)."
},
{
"ref":"dollar_lambda.CommandTree.command",
"url":0,
"doc":"A decorator for adding a function as a child of this tree. Parameters      can_run: bool Whether the parser will permit the parser to run if no further arguments are supplied. flip_bools: bool Whether to add   no-  before arguments that default to  True . help: dict A dictionary of help strings for the arguments. strings: dict A dictionary of strings to use for the arguments. types: dict A dictionary of types to use for the arguments. Examples     With  flip_bools set to  True : >>> tree = CommandTree()  . >>> @tree.command(flip_bools=True)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage:  no-b b: (default: True) With  flip_bools set to  False : >>> tree = CommandTree()  . >>> @tree.command(flip_bools=False)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: -b b: (default: True)",
"func":1
},
{
"ref":"dollar_lambda.CommandTree.subcommand",
"url":0,
"doc":"A decorator for adding a function as a child of this tree. As a subcommand, the function's name must be invoked on the command line for the function to be called. Parameters      can_run: bool Whether the parser will permit the parser to run if no further arguments are supplied. flip_bools: bool Whether to add   no-  before arguments that default to  True . help: dict A dictionary of help strings for the arguments. strings: dict A dictionary of strings to use for the arguments. types: dict A dictionary of types to use for the arguments. Examples     With  flip_bools set to  True : >>> tree = CommandTree()  . >>> @tree.subcommand(flip_bools=True)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: f1  no-b b: (default: True) With  flip_bools set to  False : >>> tree = CommandTree()  . >>> @tree.subcommand(flip_bools=False)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: f1 -b b: (default: True)",
"func":1
},
{
"ref":"dollar_lambda.key_value",
"url":1,
"doc":"Defines  KeyValue which stores pairs of variable names (keys) and values."
},
{
"ref":"dollar_lambda.key_value.KeyValue",
"url":1,
"doc":"KeyValue(key: str, value: +A)"
},
{
"ref":"dollar_lambda.key_value.KeyValue.key",
"url":1,
"doc":""
},
{
"ref":"dollar_lambda.key_value.KeyValue.value",
"url":1,
"doc":""
},
{
"ref":"dollar_lambda.key_value.KeyValueTuple",
"url":1,
"doc":"KeyValueTuple(key, value)"
},
{
"ref":"dollar_lambda.key_value.KeyValueTuple.key",
"url":1,
"doc":"Alias for field number 0"
},
{
"ref":"dollar_lambda.key_value.KeyValueTuple.value",
"url":1,
"doc":"Alias for field number 1"
},
{
"ref":"dollar_lambda.error",
"url":2,
"doc":"Defines errors which can be raised by parsers."
},
{
"ref":"dollar_lambda.error.ArgumentError",
"url":2,
"doc":"ArgumentError(usage: str)"
},
{
"ref":"dollar_lambda.error.ArgumentError.usage",
"url":2,
"doc":""
},
{
"ref":"dollar_lambda.error.ExceptionError",
"url":2,
"doc":"ExceptionError(usage: str, exception: Exception)"
},
{
"ref":"dollar_lambda.error.ExceptionError.exception",
"url":2,
"doc":""
},
{
"ref":"dollar_lambda.error.UnequalError",
"url":2,
"doc":"UnequalError(usage: str, left: ~A, right: ~A)"
},
{
"ref":"dollar_lambda.error.UnequalError.left",
"url":2,
"doc":""
},
{
"ref":"dollar_lambda.error.UnequalError.right",
"url":2,
"doc":""
},
{
"ref":"dollar_lambda.error.MissingError",
"url":2,
"doc":"MissingError(usage: str, missing: str)"
},
{
"ref":"dollar_lambda.error.MissingError.missing",
"url":2,
"doc":""
},
{
"ref":"dollar_lambda.error.ZeroError",
"url":2,
"doc":"ZeroError(usage: str)"
},
{
"ref":"dollar_lambda.error.UnexpectedError",
"url":2,
"doc":"UnexpectedError(usage: str, unexpected: str)"
},
{
"ref":"dollar_lambda.error.UnexpectedError.unexpected",
"url":2,
"doc":""
},
{
"ref":"dollar_lambda.error.HelpError",
"url":2,
"doc":"HelpError(usage: str)"
},
{
"ref":"dollar_lambda.error.HelpError.usage",
"url":2,
"doc":""
},
{
"ref":"dollar_lambda.sequence",
"url":3,
"doc":"Defines  Sequence , a strongly-typed immutable list that implements  MonadPlus ."
},
{
"ref":"dollar_lambda.sequence.Sequence",
"url":3,
"doc":"This class combines the functionality of [ MonadPlus ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py L24) and [ typing.Sequence ](https: docs.python.org/3/library/typing.html typing.Sequence). >>> s = Sequence([1, 2]) >>> len(s) 2 >>> s[0] 1 >>> s[-1] 2 >>> s + s  sequences emulate list behavior when added Sequence(get=[1, 2, 1, 2]) >>> [x + 1 for x in s]  sequences can be iterated over [2, 3] >>> Sequence([1, 2]) >= (lambda x: Sequence([x, -x] Sequence(get=[1, -1, 2, -2])"
},
{
"ref":"dollar_lambda.sequence.Sequence.get",
"url":3,
"doc":""
},
{
"ref":"dollar_lambda.sequence.Sequence.bind",
"url":3,
"doc":">>> Sequence([1, 2]) >= (lambda x: Sequence([x, -x] Sequence(get=[1, -1, 2, -2])",
"func":1
},
{
"ref":"dollar_lambda.sequence.Sequence.return_",
"url":3,
"doc":">>> Sequence.return_(1) Sequence(get=[1])",
"func":1
},
{
"ref":"dollar_lambda.sequence.Sequence.zero",
"url":3,
"doc":"",
"func":1
},
{
"ref":"dollar_lambda.parser",
"url":4,
"doc":"Defines parsing functions and the  Parser class that they instantiate."
},
{
"ref":"dollar_lambda.parser.Parse",
"url":4,
"doc":"A  Parse is the output of parsing. Parameters      parsed : A Component parsed by the parsed unparsed : Sequence[str] Component yet to be parsed"
},
{
"ref":"dollar_lambda.parser.Parse.parsed",
"url":4,
"doc":""
},
{
"ref":"dollar_lambda.parser.Parse.unparsed",
"url":4,
"doc":""
},
{
"ref":"dollar_lambda.parser.empty",
"url":4,
"doc":"Always returns {}, no matter the input. Mostly useful for use in  nonpositional . >>> empty().parse_args(\"any\", \"arguments\") {}",
"func":1
},
{
"ref":"dollar_lambda.parser.binary_usage",
"url":4,
"doc":"Utility for generating usage strings for binary operators.",
"func":1
},
{
"ref":"dollar_lambda.parser.Parser",
"url":4,
"doc":"Main class powering the argument parser."
},
{
"ref":"dollar_lambda.parser.Parser.f",
"url":4,
"doc":""
},
{
"ref":"dollar_lambda.parser.Parser.usage",
"url":4,
"doc":""
},
{
"ref":"dollar_lambda.parser.Parser.helps",
"url":4,
"doc":""
},
{
"ref":"dollar_lambda.parser.Parser.bind",
"url":4,
"doc":"Returns a new parser that 1. applies  self ; 2. if this succeeds, applies  f to the parsed component of the result.  bind is one of the functions that makes  Parser a [ Monad ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L16). But most users will avoid using it directly, preferring higher level combinators like  >> ( Parser.__rshift__ ),  | ( Parser.__or__ ) and  + ( Parser.__add__ ). Note that  >= as a synonym for  bind (as defined in [ pytypeclass ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L26 and we typically prefer using the infix operator to the spelled out method. Let's start with our simplest parser,  argument : >>> p1 = argument(\"some_dest\") Now let's use the  equals parser to write a function that takes the output of  p1 and fails unless the next argument is the same as the first: >>> def f(kvs: Sequence(KeyValue[str] -> Parser[Sequence[KeyValue[str ]:  . [kv] = kvs  . return equals(kv.value) >>> p = p1 >= f >>> p.parse_args(\"a\", \"a\") {'a': 'a'} >>> p.parse_args(\"a\", \"b\") Expected 'a'. Got 'b'",
"func":1
},
{
"ref":"dollar_lambda.parser.Parser.empty",
"url":4,
"doc":"Always returns {}, no matter the input. Mostly useful for use in  nonpositional . >>> empty().parse_args(\"any\", \"arguments\") {}",
"func":1
},
{
"ref":"dollar_lambda.parser.Parser.handle_error",
"url":4,
"doc":"",
"func":1
},
{
"ref":"dollar_lambda.parser.Parser.many",
"url":4,
"doc":"Applies  self zero or more times (like  in regexes). >>> from dollar_lambda import argument, flag >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args(return_dict=False) [] >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args(\"a\", return_dict=False) [('as-many-as-you-like', 'a')] >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args(\"a\", \"b\", return_dict=False)  return_dict=False allows duplicate keys [('as-many-as-you-like', 'a'), ('as-many-as-you-like', 'b')] Note that if  self contains  Parser.__or__ , the arguments can be heterogenous: >>> p = flag(\"verbose\") | flag(\"quiet\") >>> p = p.many() >>> p.parse_args(\" verbose\", \" quiet\", return_dict=False)  mix  verbose and  quiet [('verbose', True), ('quiet', True)]",
"func":1
},
{
"ref":"dollar_lambda.parser.Parser.many1",
"url":4,
"doc":"Applies  self one or more times (like  + in regexes). >>> from dollar_lambda import argument, flag >>> p = argument(\"1-or-more\").many1() >>> p.parse_args(\"1\") {'1-or-more': '1'} >>> p.parse_args(\"1\", \"2\", return_dict=False)  return_dict=False allows duplicate keys [('1-or-more', '1'), ('1-or-more', '2')] >>> p.parse_args() usage: 1-OR-MORE [1-OR-MORE  .] The following arguments are required: 1-or-more",
"func":1
},
{
"ref":"dollar_lambda.parser.Parser.optional",
"url":4,
"doc":"Allows arguments to be optional: >>> p1 = flag(\"optional\") >> done() >>> p = p1.optional() >>> p.parse_args(\" optional\") {'optional': True} >>> p.parse_args(\" misspelled\")  succeeds with no output {} >>> p1.parse_args(\" misspelled\") usage:  optional Expected ' optional'. Got ' misspelled'",
"func":1
},
{
"ref":"dollar_lambda.parser.Parser.parse",
"url":4,
"doc":"Applies the parser to the input sequence  cs .",
"func":1
},
{
"ref":"dollar_lambda.parser.Parser.parse_args",
"url":4,
"doc":"The main way the user extracts parsed results from the parser. Parameters      args : str A sequence of strings to parse. If empty, defaults to  sys.argv[1:] . return_dict : bool Returns a sequence of tuples instead of dictionary, thereby allowing duplicate keys. The tuples are  KeyValueTuple namedtuples, with fields  key and  value . check_help : bool Before running the parser, checks if the input string is   help or  -h . If it is, returns the usage message. Examples     >>> argument(\"a\").parse_args(\"-h\") usage: A >>> argument(\"a\").parse_args(\" help\") usage: A",
"func":1
},
{
"ref":"dollar_lambda.parser.Parser.return_",
"url":4,
"doc":"This method is required to make  Parser a [ Monad ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L16). It consumes none of the input and always returns  a as the result. For the most part, the user will not use this method unless building custom parsers. >>> from dollar_lambda.key_value import KeyValue >>> Parser.return_ [KeyValue(\"some-key\", \"some-value\")] .parse_args() {'some-key': 'some-value'}",
"func":1
},
{
"ref":"dollar_lambda.parser.Parser.zero",
"url":4,
"doc":"This parser always fails. This method is necessary to make  Parser a [ Monoid ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py L13). Parameters      error : Optional[ArgumentError] Customize the error returned by  zero . >>> Parser.zero().parse_args() zero >>> Parser.zero().parse_args(\"a\") zero >>> Parser.zero(error=ArgumentError(\"This is a test.\" .parse_args(\"a\") This is a test.",
"func":1
},
{
"ref":"dollar_lambda.parser.apply",
"url":4,
"doc":"Takes the output of  parser and applies  f to it. Convert any errors that arise into  ArgumentError . >>> p1 = flag(\"hello\") >>> p1.parse_args(\" hello\", return_dict=False) [('hello', True)] This will double  p1 's output: >>> p2 = apply(lambda kv: Result.return_(kv + kv), p1) >>> p2.parse_args(\" hello\", return_dict=False) [('hello', True), ('hello', True)]",
"func":1
},
{
"ref":"dollar_lambda.parser.apply_item",
"url":4,
"doc":"A shortcut for  apply(f, item(description  and spares  f the trouble of outputting a  Result object. >>> p1 = argument(\"foo\") >>> p1.parse_args(\"bar\", return_dict=False) [('foo', 'bar')] Here we use  f to directly manipulate the binding generated by  item : >>> p2 = apply_item(lambda bar: [KeyValue(bar + \"e\", bar + \"f\")], description=\"baz\") >>> p2.parse_args(\"bar\", return_dict=False) [('bare', 'barf')]",
"func":1
},
{
"ref":"dollar_lambda.parser.argument",
"url":4,
"doc":"Parses a single word and binds it to  dest . Useful for positional arguments. Parameters      dest : str The name of variable to bind to: help : Optional[str] The help message to display for the option: type : Optional[Callable str], Any Use the  type argument to convert the input to a different type: >>> argument(\"name\").parse_args(\"Alice\") {'name': 'Alice'} >>> argument(\"name\").parse_args() usage: NAME The following arguments are required: name",
"func":1
},
{
"ref":"dollar_lambda.parser.defaults",
"url":4,
"doc":"Useful for assigning default values to arguments. It ignore the input and always returns  kwargs converted into  Sequence[KeyValue] .  defaults never fails. >>> defaults(a=1, b=2).parse_args() {'a': 1, 'b': 2} >>> (flag(\"fails\") | defaults(fails=\"succeeds\" .parse_args() {'fails': 'succeeds'} Here's a more complex example derived from the tutorial: >>> p = nonpositional(  . (  . flag(\"verbose\") + defaults(quiet=False)  either  verbose and default \"quiet\" to False  . | flag(\"quiet\") + defaults(verbose=False)  or  quiet and default \"verbose\" to False  . ),  . option(\"x\", type=int, help=\"the base\"),  . option(\"y\", type=int, help=\"the exponent\"),  . ) >> done() >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\") {'x': 1, 'y': 2, 'verbose': True, 'quiet': False}",
"func":1
},
{
"ref":"dollar_lambda.parser.done",
"url":4,
"doc":" done succeds on the end of input and fails on everything else. >>> done().parse_args() {} >>> done().parse_args(\"arg\") Unrecognized argument: arg Without  done the parser will not complain about leftover (unparsed) input: >>> flag(\"verbose\").parse_args(\" verbose\", \" quiet\") {'verbose': True}   quiet is not parsed here but this does not cause the parser to fail. If we want to prevent leftover inputs, we can use  done : >>> (flag(\"verbose\") >> done( .parse_args(\" verbose\", \" quiet\") usage:  verbose Unrecognized argument:  quiet  done is usually necessary to get  nonpositional to behave in the way that you expect. See  nonpositional API docs for details.",
"func":1
},
{
"ref":"dollar_lambda.parser.equals",
"url":4,
"doc":"Checks if the next word is  s . >>> equals(\"hello\").parse_args(\"hello\") {'hello': 'hello'} >>> equals(\"hello\").parse_args(\"goodbye\") usage: hello Expected 'hello'. Got 'goodbye' Parameters      s: str The word to that input will be checked against for equality. peak : bool If  False , then the parser will consume the word and return the remaining words as  unparsed . If  True , then the parser leaves the  unparsed component unchanged. Examples     >>> p = equals(\"hello\") >> equals(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") {'hello': 'hello', 'goodbye': 'goodbye'} Look what happens when  peak=True : >>> p = equals(\"hello\", peak=True) >> equals(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") usage: hello goodbye Expected 'goodbye'. Got 'hello' The first parser didn't consume the word and so \"hello\" got passed on to  equals(\"goodbye\") . But this would work: >>> p = equals(\"hello\", peak=True) >> equals(\"hello\") >>equals(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") {'hello': 'hello', 'goodbye': 'goodbye'}",
"func":1
},
{
"ref":"dollar_lambda.parser.flag",
"url":4,
"doc":"Binds a boolean value to a variable. >>> p = flag(\"verbose\") >>> p.parse_args(\" verbose\") {'verbose': True} Parameters      dest : str The variable to which the value will be bound. default : Optional[bool] An optional default value. help : Optional[str] An optional help string. short : bool Whether to check for the short form of the flag, which uses a single dash and the first character of  dest , e.g.  -f for  foo . string : Optional[str] A custom string to use for the flag. Defaults to   {dest} . Examples     Here is an example using the  default parameter: >>> p = flag(\"verbose\", default=False) >>> p.parse_args() {'verbose': False} By default  flag fails when it does not receive expected input: >>> p = flag(\"verbose\") >>> p.parse_args() usage:  verbose The following arguments are required:  verbose Here is an example using the  help parameter: >>> p = flag(\"verbose\", help=\"Turn on verbose output.\") >>> p.parse_args(\"-h\") usage:  verbose verbose: Turn on verbose output. Here is an example using the  short parameter: >>> flag(\"verbose\", short=True).parse_args(\"-v\")  this is the default {'verbose': True} >>> flag(\"verbose\", short=False).parse_args(\"-v\")  fails usage:  verbose Expected ' verbose'. Got '-v' Here is an example using the  string parameter: >>> flag(\"value\", string=\"v\").parse_args(\"v\")  note that string does not have to start with - {'value': True}",
"func":1
},
{
"ref":"dollar_lambda.parser.help_parser",
"url":4,
"doc":"",
"func":1
},
{
"ref":"dollar_lambda.parser.wrap_help",
"url":4,
"doc":"This checks for the   help or  -h flag before applying  parser . If either of the flags is present, returns the usage message for  parser . >>> p = wrap_help(flag(\"help\", help=\"Print this help message.\" >>> p.parse_args(\" help\") usage:  help help: Print this help message. >>> p.parse_args(\"-h\") usage:  help help: Print this help message. We can use  wrap_help to print partial usage messages, e.g. for subcommands: >>> subcommand1 = equals(\"subcommand1\") >> wrap_help(option(\"option1\" >>> subcommand2 = equals(\"subcommand2\") >> wrap_help(option(\"option2\" >>> p = subcommand1 | subcommand2 >>> p.parse_args(\"subcommand1\", \"-h\") usage:  option1 OPTION1 >>> p.parse_args(\"subcommand2\", \"-h\") usage:  option2 OPTION2",
"func":1
},
{
"ref":"dollar_lambda.parser.item",
"url":4,
"doc":"Parses a single word and binds it to  dest . One of the lowest level building blocks for parsers. Parameters      help_name : Optional[str] Used for generating help text Examples     >>> p = item(\"name\", help_name=\"Your first name\") >>> p.parse_args(\"Alice\") {'name': 'Alice'} >>> p.parse_args() usage: name The following arguments are required: Your first name",
"func":1
},
{
"ref":"dollar_lambda.parser.nonpositional",
"url":4,
"doc":" nonpositional takes a sequence of parsers as arguments and attempts all permutations of them, returning the first permutations that is successful: >>> p = nonpositional(flag(\"verbose\"), flag(\"quiet\" >>> p.parse_args(\" verbose\", \" quiet\") {'verbose': True, 'quiet': True} >>> p.parse_args(\" quiet\", \" verbose\")  reverse order also works {'quiet': True, 'verbose': True} If alternatives or defaults appear among the arguments to  nonpositional , you will probably want to add  >> followed by  done (or another parser) after  nonpositional . Otherwise, the parser will not behave as expected: >>> p = nonpositional(flag(\"verbose\", default=False), flag(\"quiet\" >>> p.parse_args(\" quiet\", \" verbose\")  you expect this to set verbose to True, but it doesn't {'verbose': False, 'quiet': True} Why is happening? There are two permutions: -  flag(\"verbose\", default=False) >> flag(\"quiet\") and -  flag(\"quiet\") >> flag(\"verbose\", default=False) In our example, both permutations are actually succeeding. This first succeeds by falling back to the default, and leaving the last word of the input,   verbose , unparsed. Either interpretation is valid, and  nonpositional returns one arbitrarily  just not the one we expected. Now let's add  >> done() to the end: >>> p = nonpositional(flag(\"verbose\", default=False), flag(\"quiet\" >> done() This ensures that the first permutation will fail because the leftover   verbose input will cause the  done parser to fail: >>> p.parse_args(\" quiet\", \" verbose\") {'quiet': True, 'verbose': True}",
"func":1
},
{
"ref":"dollar_lambda.parser.option",
"url":4,
"doc":"Parses two words, binding the second to the first. Parameters      dest : str The name of variable to bind to: flag : Optional[str] The flag to use for the option. If not provided, defaults to   {dest} . default : Optional[Any] The default value to bind on failure: help : Optional[str] The help message to display for the option: short : bool Whether to check for the short form of the flag, which uses a single dash and the first character of  dest , e.g.  -c for  count . type : Callable str], Any] Use the  type argument to convert the input to a different type: Examples     >>> option(\"count\").parse_args(\" count\", \"1\") {'count': '1'} In this example, you can see that the  flag parameter allows the user to specify an arbitrary lead string, including one that doesn't start with a dash. >>> option(\"count\", flag=\"ct\").parse_args(\"ct\", \"1\") {'count': '1'} This example demonstrates the use of the  default parameter: >>> option(\"count\", default=2).parse_args() {'count': 2} Here we specify a help-string using the  help parameter: >>> option(\"count\", help=\"The number we should count to\").parse_args(\"-h\") usage:  count COUNT count: The number we should count to This example demonstrates the difference between  short=True and  short=False : >>> option(\"count\", short=True).parse_args(\"-c\", \"1\") {'count': '1'} >>> option(\"count\", short=False).parse_args(\"-c\", \"1\") usage:  count COUNT Expected ' count'. Got '-c' As with [argparse](https: docs.python.org/3/library/argparse.html argument-parsing), the  type argument allows you to convert the input to a different type using a function that takes a single string argument: >>> option(\"x\", type=int).parse_args(\"-x\", \"1\")  converts \"1\" to an int {'x': 1} >>> option(\"x\", type=lambda x: int(x) + 1).parse_args(\"-x\", \"1\") {'x': 2}",
"func":1
},
{
"ref":"dollar_lambda.parser.peak",
"url":4,
"doc":"",
"func":1
},
{
"ref":"dollar_lambda.parser.sat",
"url":4,
"doc":"Applies  parser , applies a predicate to the result and fails if this returns false. >>> p = sat(  . option(\"x\", type=int).many(),  . lambda kvs: sum([kv.value for kv in kvs]) > 0,  . lambda x: ArgumentError(f\"The values in {list(x)} must sum to more than 0.\"),  . ) >>> p.parse_args(\"-x\", \"-1\", \"-x\", \"1\")  fails usage: [-x X  .] The values in [KeyValue(key='x', value=-1), KeyValue(key='x', value=1)] must sum to more than 0. >>> p.parse_args(\"-x\", \"-1\", \"-x\", \"2\")  succeeds {'x': 2} Parameters      parser : Parser[A] The parser to apply. predicate : Callable A], bool] The predicate to apply to the result of  parser .  sat fails if this predicate returns false. on_fail : Callable A], ArgumentError] A function producing an ArgumentError to return if the predicate fails. Takes the output of  parser as an argument.",
"func":1
},
{
"ref":"dollar_lambda.parser.sat_item",
"url":4,
"doc":"A wrapper around  sat that uses  item to parse the argument and just applies  predicate to the value output by  item . >>> p = sat_item(lambda x: len(x)  1, lambda x: ArgumentError(f\"'{x}' must have exactly one character.\"), \"x\") >>> p.parse_args(\"a\")  succeeds {'x': 'a'} >>> p.parse_args(\"aa\")  fails usage: x 'aa' must have exactly one character. Parameters      predicate : Callable A], bool] The predicate to apply to the result of  item .  sat fails if this predicate returns false. on_fail : Callable A], ArgumentError] A function producing an ArgumentError to return if the predicate fails. Takes the output of  item as an argument. name: str The value to bind the result to.",
"func":1
},
{
"ref":"dollar_lambda.parser.sat_peak",
"url":4,
"doc":"",
"func":1
},
{
"ref":"dollar_lambda.parser.type_",
"url":4,
"doc":"A wrapper around  apply that simply applies  f to the value of the most recently parsed input. >>> p1 = option(\"x\") >> option(\"y\") >>> p = type_(int, p1) >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\")  converts \"1\" but not \"2\" {'y': '2', 'x': 1}",
"func":1
},
{
"ref":"dollar_lambda.result",
"url":5,
"doc":"Defines the  Result dataclass, representing success or failure, output by parsers."
},
{
"ref":"dollar_lambda.result.Result",
"url":5,
"doc":"Result(get: 'NonemptyList[A_co] | ArgumentError')"
},
{
"ref":"dollar_lambda.result.Result.get",
"url":5,
"doc":""
},
{
"ref":"dollar_lambda.result.Result.bind",
"url":5,
"doc":"",
"func":1
},
{
"ref":"dollar_lambda.result.Result.return_",
"url":5,
"doc":"  return  a -> m a  ",
"func":1
},
{
"ref":"dollar_lambda.result.Result.zero",
"url":5,
"doc":"",
"func":1
},
{
"ref":"dollar_lambda.args",
"url":6,
"doc":"Defines the  Args dataclass and associated functions."
},
{
"ref":"dollar_lambda.args.field",
"url":6,
"doc":"This is a thin wrapper around [ dataclasses.field ](https: docs.python.org/3/library/dataclasses.html dataclasses.field). Parameters      help : str An optional help string for the argument. metadata : str Identical to the  metadata argument for [ dataclasses.field ](https: docs.python.org/3/library/dataclasses.html dataclasses.field). type : Optional[type | Callable str], Any A function that takes a string and returns a value just like the  type argument for [ ArgumentParser.add_argument ](https: docs.python.org/3/library/argparse.html type). Returns    - A  dataclasses.Field object that can be used in place of a default argument as described in the [ dataclasses.Field documentation](https: docs.python.org/3/library/dataclasses.html dataclasses.field).",
"func":1
},
{
"ref":"dollar_lambda.args.Args",
"url":6,
"doc":" Args is sugar for the  nonpositional function and removes much of the boilerplate from defining parsers with many arguments. >>> @dataclass  . class MyArgs(Args):  . verbose: bool  . count: int >>> MyArgs.parse_args(\" verbose\", \" count\", \"1\") {'verbose': True, 'count': 1}  MyArgs will accept these arguments in any order: >>> MyArgs.parse_args(\" count\", \"1\", \" verbose\") {'count': 1, 'verbose': True} Note that when the default value of an argument is  True ,  Args will, by default add   no- to the front of the flag (while still assigning the value to the original key): >>> @dataclass  . class MyArgs(Args):  . tests: bool = True >>> MyArgs.parse_args(\" no-tests\") {'tests': False} >>> MyArgs.parse_args() {'tests': True} To suppress this behavior, set  flip_bools=False : >>> MyArgs.parse_args(\" tests\", flip_bools=False) {'tests': False} By using the  Args.parser() method,  Args can take advantage of all the same combinators as other parsers: >>> from dollar_lambda import argument >>> p = MyArgs.parser() >>> p1 = p >> argument(\"a\") >>> p1.parse_args(\" no-tests\", \"hello\") {'tests': False, 'a': 'hello'} To supply other metadata, like  help text and more complex  type converters, use  field : >>> @dataclass  . class MyArgs(Args):  . n: int = field(default=0, help=\"a number to increment\", type=lambda x: 1 + int(x >>> MyArgs.parse_args(\"-n\", \"1\") {'n': 2} >>> MyArgs.parse_args() {'n': 1}"
},
{
"ref":"dollar_lambda.args.Args.parser",
"url":6,
"doc":"Returns a parser for the dataclass. Converts each field to a parser ( option or  flag depending on its type). Combines these parsers using  nonpositional . Parameters      flip_bools: bool Whether to add   no-  before arguments that default to  True . Examples     >>> @dataclass  . class MyArgs(Args):  . tests: bool = True Note the leading   no- : >>> MyArgs.parse_args(\" no-tests\") {'tests': False} >>> MyArgs.parse_args() {'tests': True} To suppress this behavior, set  flip_bools=False : >>> MyArgs.parse_args(\" tests\", flip_bools=False) {'tests': False}",
"func":1
},
{
"ref":"dollar_lambda.args.Args.parse_args",
"url":6,
"doc":"Parses the arguments and returns a dictionary of the parsed values.",
"func":1
},
{
"ref":"dollar_lambda.decorators",
"url":7,
"doc":"Defines the  command decorator and the  CommandTree class."
},
{
"ref":"dollar_lambda.decorators.command",
"url":7,
"doc":"A succinct way to generate a simple  nonpositional parser.  @command derives the component parsers from the function's signature and automatically executes the function with the parsed arguments, if parsing succeeds: >>> @command(help=dict(a=\"something about a\"), types=dict(a=lambda x: int(x) + 1  . def f(a: int = 1, b: bool = False):  . return dict(a=a, b=b) >>> f(\"-a\", \"2\", \"-b\") {'a': 3, 'b': True} If the wrapped function receives no arguments (as in  f() ), the parser will take  sys.argv[1:] as the input. Note that  @command does not handle mutually exclusive arguments or alternative arguments. Parameters      flip_bools : bool For boolean arguments that default to true, this changes the flag from   {dest} to   no-{dest} : help : dict[str, str] A dictionary of help strings for the arguments. strings : dict[str, str] This dictionary maps variable names to the strings that the parser will look for in the input. types: dict[str, Callable str], Any This dictionary maps variable names to custom type converters. Examples     >>> @command()  . def f(cuda: bool = True):  . return dict(cuda=cuda) >>> f() {'cuda': True} >>> f(\" no-cuda\")  flip_bools adds  no- to the flag {'cuda': False} As the following example demonstrates, when  flip_bools=False output can be somewhat confusing: >>> @command(flip_bools=False)  . def f(cuda: bool = True):  . return dict(cuda=cuda) >>> f(\" cuda\") {'cuda': False} Here is an example using the  help parameter: >>> @command(help=dict(quiet=\"Be quiet\"  . def f(quiet: bool):  . return dict(quiet=quiet) >>> f(\" help\") usage:  quiet quiet: Be quiet Here is an example using the  strings parameter: >>> @command(strings=dict(quiet=\" quiet-mode\"  . def f(quiet: bool):  . return dict(quiet=quiet) >>> f(\" quiet-mode\") {'quiet': True} >>> f(\" quiet\") usage:  quiet-mode Expected ' quiet-mode'. Got ' quiet' Here is an example using the  type parameter: >>> @command(types=dict(x=lambda x: int(x) + 1  . def f(x: int):  . return dict(x=x) >>> f(\"-x\", \"0\") {'x': 1}",
"func":1
},
{
"ref":"dollar_lambda.decorators.CommandTree",
"url":7,
"doc":"Allows parsers to dynamically dispatch their results based on the input. For usage details, see the [ CommandTree tutorial]( commandtree-tutorial)."
},
{
"ref":"dollar_lambda.decorators.CommandTree.command",
"url":7,
"doc":"A decorator for adding a function as a child of this tree. Parameters      can_run: bool Whether the parser will permit the parser to run if no further arguments are supplied. flip_bools: bool Whether to add   no-  before arguments that default to  True . help: dict A dictionary of help strings for the arguments. strings: dict A dictionary of strings to use for the arguments. types: dict A dictionary of types to use for the arguments. Examples     With  flip_bools set to  True : >>> tree = CommandTree()  . >>> @tree.command(flip_bools=True)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage:  no-b b: (default: True) With  flip_bools set to  False : >>> tree = CommandTree()  . >>> @tree.command(flip_bools=False)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: -b b: (default: True)",
"func":1
},
{
"ref":"dollar_lambda.decorators.CommandTree.subcommand",
"url":7,
"doc":"A decorator for adding a function as a child of this tree. As a subcommand, the function's name must be invoked on the command line for the function to be called. Parameters      can_run: bool Whether the parser will permit the parser to run if no further arguments are supplied. flip_bools: bool Whether to add   no-  before arguments that default to  True . help: dict A dictionary of help strings for the arguments. strings: dict A dictionary of strings to use for the arguments. types: dict A dictionary of types to use for the arguments. Examples     With  flip_bools set to  True : >>> tree = CommandTree()  . >>> @tree.subcommand(flip_bools=True)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: f1  no-b b: (default: True) With  flip_bools set to  False : >>> tree = CommandTree()  . >>> @tree.subcommand(flip_bools=False)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: f1 -b b: (default: True)",
"func":1
}
]
