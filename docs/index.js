URLS = [
    "dollar_lambda/index.html",
    "dollar_lambda/error.html",
    "dollar_lambda/sequence.html",
    "dollar_lambda/parser.html",
    "dollar_lambda/result.html",
    "dollar_lambda/args.html",
    "dollar_lambda/decorators.html"
];
INDEX = [
    {
        "ref": "dollar_lambda",
        "url": 0,
        "doc": "This package provides an alternative to [ argparse ](https: docs.python.org/3/library/argparse.html) based on parser combinators and functional first principles. Arguably,  $\u03bb is way more expressive than any reasonable person would ever need . but even if it's not the parser that we need, it's the parser we deserve.  Installation   pip install dollar-lambda    Highlights  $\u03bb comes with syntactic sugar that came make building parsers completely boilerplate-free. For complex parsing situations that exceed the expressive capacity of this syntax, the user can also drop down to the lower-level syntax that lies behind the sugar, which can handle any reasonable amount of logical complexity.  The [ @command ]( dollar_lambda.command) decorator For the vast majority of parsing patterns,  @command is the most concise way to define a parser: >>> @command()  . def main(x: int, dev: bool = False, prod: bool = False):  . return dict(x=x, dev=dev, prod=prod) Here is the help text generated by this parser: >>> main(\"-h\") usage: -x X  dev  prod And here it is in action: >>> main(\"-x\", \"1\", \" dev\") {'x': 1, 'dev': True, 'prod': False} Ordinarily you would provide  main no arguments and it would get them from the command line. >>> parsers.TESTING = False  False by default but needs to be true for doctests >>> import sys >>> sys.argv[1:] = [\"-x\", \"1\", \" dev\"]  simulate command line input >>> main() {'x': 1, 'dev': True, 'prod': False} In this document we'll feed the strings directly for the sake of brevity. >>> parsers.TESTING = True Use the  parsers argument to add custom logic to this parser: >>> @command(parsers=dict(kwargs=(flag(\"dev\") | flag(\"prod\"   . def main(x: int,  kwargs):  . return dict(x=x,  kwargs) This parser requires either a   dev or   prod flag and maps it to the  kwargs argument: >>> main(\"-h\") usage: -x X [ dev |  prod] >>> main(\"-x\", \"1\", \" dev\") {'x': 1, 'dev': True} >>> main(\"-x\", \"1\", \" prod\") {'x': 1, 'prod': True} >>> main(\"-x\", \"1\") usage: -x X [ dev |  prod] The following arguments are required:  dev   CommandTree for dynamic dispatch For many programs, a user will want to use one entrypoint for one set of arguments, and another for another set of arguments. Returning to our example, let's say we wanted to execute  prod_function when the user provides the   prod flag, and  dev_function when the user provides the   dev flag: >>> tree = CommandTree()  . >>> @tree.command()  . def base_function(x: int):  . print(\"Ran base_function with arguments:\", dict(x=x  . >>> @base_function.command()  . def prod_function(x: int, prod: bool):  . print(\"Ran prod_function with arguments:\", dict(x=x, prod=prod  . >>> @base_function.command()  . def dev_function(x: int, dev: bool):  . print(\"Ran dev_function with arguments:\", dict(x=x, dev=dev Let's see how this parser handles different inputs. If we provide the   prod flag,  $\u03bb automatically invokes  prod_function with the parsed arguments: >>> tree(\"-x\", \"1\", \" prod\") Ran prod_function with arguments: {'x': 1, 'prod': True} If we provide the   dev flag,  $\u03bb invokes  dev_function : >>> tree(\"-x\", \"1\", \" dev\") Ran dev_function with arguments: {'x': 1, 'dev': True} With this configuration, the parser will run  base_function if neither   prod nor   dev are given: >>> tree(\"-x\", \"1\") Ran base_function with arguments: {'x': 1} As with  main in the previous example, you would ordinarily provide  tree no arguments and it would get them from the command line. There are many other ways to use  CommandTree , including some that make use of the  base_function . To learn more, we recommend the [ CommandTree tutorial]( commandtree-tutorial).  Lower-level syntax [ @command ]( dollar_lambda.command) and  CommandTree cover many use cases, but they are both syntactic sugar for a lower-level interface that is far more expressive. Suppose you want to implement a parser that first tries to parse an option (a flag that takes an argument),  -x X and if that fails, tries to parse the input as a variadic sequence of floats: >>> p = option(\"x\", type=int) | argument(\"y\", type=float).many() We go over this syntax in greater detail in the [tutorial]( tutorial). For now, suffice to say that  argument defines a positional argument, [ many ]( dollar_lambda.Parser.many) allows parsers to be applied zero or more times, and [ | ]( dollar_lambda.Parser.__or__) expresses alternatives. Here is the help text: >>> p.parse_args(\"-h\") usage: [-x X | [Y  . As promised, this succeeds: >>> p.parse_args(\"-x\", \"1\") {'x': 1} And this succeeds: >>> p.parse_args(\"1\", \"2\", \"3\") {'y': [1.0, 2.0, 3.0]} Again, you would ordinarily provide  parse_args no arguments and it would get them from the command line: >>> parsers.TESTING = False >>> sys.argv[1:] = [\"-x\", \"1\"]  simulate command line input >>> p.parse_args() {'x': 1} >>> parsers.TESTING = True  Tutorial We've already seen many of the concepts that power  $\u03bb in the [Highlights]( highlights) section. This tutorial will address these concepts one at a time and expose the reader to some nuances of usage.  An example from  argparse Many of you are already familiar with  argparse . You may even recognize this example from the  argparse docs:   import argparse parser = argparse.ArgumentParser(description=\"calculate X to the power of Y\") group = parser.add_mutually_exclusive_group() group.add_argument(\"-v\", \" verbose\", action=\"store_true\") group.add_argument(\"-q\", \" quiet\", action=\"store_true\") parser.add_argument(\"x\", type=int, help=\"the base\") parser.add_argument(\"y\", type=int, help=\"the exponent\") args = parser.parse_args()   Here is one way to express this logic in  $\u03bb : >>> @command(  . parsers=dict(kwargs=(flag(\"verbose\") | flag(\"quiet\" .optional( ,  . help=dict(x=\"the base\", y=\"the exponent\"),  . )  . def main(x: int, y: int,  kwargs):  . return dict(x=x, y=y,  kwargs)  Run program. Return can be whatever. Here is the help text for this parser: >>> main(\"-h\") usage: -x X -y Y [ verbose |  quiet] x: the base y: the exponent As indicated, this succeeds given   verbose >>> main(\"-x\", \"1\", \"-y\", \"2\", \" verbose\") {'x': 1, 'y': 2, 'verbose': True} or   quiet >>> main(\"-x\", \"1\", \"-y\", \"2\", \" quiet\") {'x': 1, 'y': 2, 'quiet': True} or neither >>> main(\"-x\", \"1\", \"-y\", \"2\") {'x': 1, 'y': 2} Ordinarily , we would not feed  main any arguments, and it would get them from the command line: >>> parsers.TESTING = False  False by default but needs to be True for doctests >>> sys.argv[1:] = [\"-x\", \"1\", \"-y\", \"2\"]  simulate command line input >>> main() {'x': 1, 'y': 2} >>> parsers.TESTING = True  Equivalent in lower-level syntax To better understand what is going on here, let's remove the syntactic sugar: >>> p = nonpositional(  . (flag(\"verbose\") | flag(\"quiet\" .optional(),  . option(\"x\", type=int, help=\"the base\"),  . option(\"y\", type=int, help=\"the exponent\"),  . )  . >>> def main(x, y,  kwargs):  . return dict(x=x, y=y,  kwargs) Now let's walk through this step by step.  High-Level Parsers In the de-sugared implementation there are two different parser constructors:  flag , which binds a boolean value to a variable, and  option , which binds an arbitrary value to a variable.   flag >>> p = flag(\"verbose\") >>> p.parse_args(\" verbose\") {'verbose': True} By default  flag fails when it does not receive expected input: >>> p.parse_args() usage:  verbose The following arguments are required:  verbose Alternately, you can set a default value: >>> flag(\"verbose\", default=False).parse_args() {'verbose': False}   option  option is similar but takes an argument: By default,  option expects a single  - for single-character variable names (as in  -x ), as opposed to    for longer names (as in   xenophon ): >>> option(\"x\").parse_args(\"-x\", \"1\") {'x': '1'} >>> option(\"xenophon\").parse_args(\" xenophon\", \"1\") {'xenophon': '1'} Use the  type argument to convert the input to a different type: >>> option(\"x\", type=int).parse_args(\"-x\", \"1\")  converts \"1\" to an int {'x': 1}  Parser Combinators Parser combinators are functions that combine multiple parsers into new, more complex parsers. Our example uses two such functions:  nonpositional and [ | ]( dollar_lambda.Parser.__or__).  [ | ]( dollar_lambda.Parser.__or__) The [ | ]( dollar_lambda.Parser.__or__) operator is used for alternatives. Specifically, it will try the first parser, and if that fails, try the second: >>> p = flag(\"verbose\") | flag(\"quiet\") >>> p.parse_args(\" quiet\")  flag(\"verbose\") fails {'quiet': True} >>> p.parse_args(\" verbose\")  flag(\"verbose\") succeeds {'verbose': True} By default one of the two flags would be required to prevent failure: >>> p.parse_args()  neither flag is provided so this fails usage: [ verbose |  quiet] The following arguments are required:  verbose We can permit the omission of both flags by using  optional , as we saw earlier, or we can supply a default value: >>> (flag(\"verbose\") | flag(\"quiet\" .optional().parse_args()  flags fail, but that's ok {} >>> (flag(\"verbose\") | flag(\"quiet\", default=False .parse_args()  flag(\"verbose\") fails but flag(\"quiet\", default=False) succeeds {'quiet': False} Users should note that unlike logical \"or\" but like Python  or , the [ | ]( dollar_lambda.Parser.__or__) operator is not commutative: >>> (flag(\"verbose\") | argument(\"x\" .parse_args(\" verbose\") {'verbose': True}  argument binds to positional arguments. If it comes first, it will think that  \" verbose\" is the expression that we want to bind to  x : >>> (argument(\"x\") | flag(\"verbose\" .parse_args(\" verbose\") {'x': ' verbose'}   nonpositional and [ + ]( dollar_lambda.Parser.__add__)  nonpositional takes a sequence of parsers as arguments and attempts all permutations of them, returning the first permutations that is successful: >>> p = nonpositional(flag(\"verbose\"), flag(\"quiet\" >>> p.parse_args(\" verbose\", \" quiet\") {'verbose': True, 'quiet': True} >>> p.parse_args(\" quiet\", \" verbose\")  reverse order also works {'quiet': True, 'verbose': True} For just two parsers you can use [ + ]( dollar_lambda.Parser.__add__) instead of  nonpositional : >>> p = flag(\"verbose\") + flag(\"quiet\") >>> p.parse_args(\" verbose\", \" quiet\") {'verbose': True, 'quiet': True} >>> p.parse_args(\" quiet\", \" verbose\")  reverse order also works {'quiet': True, 'verbose': True} This will not cover all permutations for more than two parsers: >>> p = flag(\"verbose\") + flag(\"quiet\") + option(\"x\") >>> p.parse_args(\" verbose\", \"-x\", \"1\", \" quiet\") usage:  verbose  quiet -x X Expected ' quiet'. Got '-x' To see why note the implicit parentheses: >>> p = (flag(\"verbose\") + flag(\"quiet\" + option(\"x\") In order to cover the case where  -x comes between   verbose and   quiet , use  nonpositional : >>> p = nonpositional(flag(\"verbose\"), flag(\"quiet\"), option(\"x\" >>> p.parse_args(\" verbose\", \"-x\", \"1\", \" quiet\")  works {'verbose': True, 'x': '1', 'quiet': True}  Putting it all together Let's recall the original example without the syntactic sugar: >>> p = nonpositional(  . (flag(\"verbose\") | flag(\"quiet\" .optional(),  . option(\"x\", type=int, help=\"the base\"),  . option(\"y\", type=int, help=\"the exponent\"),  . )  . >>> def main(x, y, verbose=False, quiet=False):  . return dict(x=x, y=y, verbose=verbose, quiet=quiet) As we've seen,  (flag(\"verbose\") | flag(\"quiet\" .optional() succeeds on either   verbose or   quiet or neither.  option(\"x\", type=int) succeeds on  -x X , where  X is some integer, binding that integer to the variable  \"x\" . Similarly for  option(\"y\", type=int) .  nonpositional takes the three parsers: -  (flag(\"verbose\") | flag(\"quiet\" .optional() -  option(\"x\", type=int) -  option(\"y\", type=int) and applies them in every order, until some order succeeds. Applying the syntactic sugar: >>> @command(  . parsers=dict(kwargs=(flag(\"verbose\") | flag(\"quiet\" .optional( ,  . help=dict(x=\"the base\", y=\"the exponent\"),  . )  . def main(x: int, y: int,  kwargs):  . pass  do work Here the  parsers argument reserves a function argument (in this case,  kwargs ) for a custom parser (in this case,  (flag(\"verbose\") | flag(\"quiet\" .optional() ) using our lower-level syntax. The  help argument assigns help text to the arguments (in this case  x and  y ).  Variations on the example  Positional arguments What if we wanted to supply  x and  y as positional arguments? >>> flags = flag(\"verbose\") | flag(\"quiet\") >>> p = option(\"x\", type=int) >> option(\"y\", type=int) >> flags >>> p.parse_args(\"-h\") usage: -x X -y Y [ verbose |  quiet] This introduces a new parser combinator: [ >> ]( dollar_lambda.Parser.__rshift__) which evaluates parsers in sequence. In this example, it would first evaluate the  option(\"x\", type=int) parser, and if that succeeded, it would hand the unparsed remainder on to the  option(\"y\", type=int) parser, and so on until all parsers have been evaluated or no more input remains. If any of the parsers fail, the combined parser fails: >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" quiet\")  succeeds {'x': 1, 'y': 2, 'quiet': True} >>> p.parse_args(\"-typo\", \"1\", \"-y\", \"2\", \" quiet\")  first parser fails usage: -x X -y Y [ verbose |  quiet] Expected '-x'. Got '-typo' >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" typo\")  third parser fails usage: -x X -y Y [ verbose |  quiet] Expected ' verbose'. Got ' typo' Unlike with  nonpositional in the previous section, [ >> ]( dollar_lambda.Parser.__rshift__) requires the user to provide arguments in a fixed order: >>> p.parse_args(\"-y\", \"2\", \"-x\", \"1\", \" quiet\")  fails usage: -x X -y Y [ verbose |  quiet] Expected '-x'. Got '-y' When using positional arguments, it might make sense to drop the  -x and  -y flags: >>> p = argument(\"x\", type=int) >> argument(\"y\", type=int) >> flags >>> p.parse_args(\"-h\") usage: X Y [ verbose |  quiet] >>> p.parse_args(\"1\", \"2\", \" quiet\") {'x': 1, 'y': 2, 'quiet': True}  argument will bind input to a variable without checking for any special flag strings like  -x or  -y preceding the input.  Variable numbers of arguments What if there was a special argument,  verbosity , that only makes sense if the user chooses   verbose ? >>> p = nonpositional(  .  flag(\"verbose\") + option(\"verbosity\", type=int | flag(\"quiet\" ,  . option(\"x\", type=int),  . option(\"y\", type=int),  . ) Remember that [ + ]( dollar_lambda.Parser.__add__) evaluates two parsers in both orders and stopping at the first order that succeeds. So this allows us to supply   verbose and   verbosity in any order. >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" quiet\") {'x': 1, 'y': 2, 'quiet': True} >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\", \" verbosity\", \"3\") {'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3} >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\") usage: [ verbose  verbosity VERBOSITY |  quiet] -x X -y Y Expected ' verbose'. Got '-x' We could express the same logic with the  command decorator: >>> @command(  . parsers=dict(  . kwargs=flag(\"verbose\") + option(\"verbosity\", type=int) | flag(\"quiet\")  . ),  . help=dict(x=\"the base\", y=\"the exponent\"),  . )  . def main(x: int, y: int,  kwargs):  . pass  do work This is also a case where you might want to use  CommandTree : >>> tree = CommandTree()  . >>> @tree.command(help=dict(x=\"the base\", y=\"the exponent\"  . def base_function(x: int, y: int):  . pass  do work  . >>> @base_function.command()  . def verbose_function(x: int, y: int, verbose: bool, verbosity: int):  . args = dict(x=x, y=y, verbose=verbose, verbosity=verbosity)  . print(\"invoked verbose_function with args\", args)  . >>> @base_function.command()  . def quiet_function(x: int, y: int, quiet: bool):  . pass  do work  . >>> tree(\"-x\", \"1\", \"-y\", \"2\", \" verbose\", \" verbosity\", \"3\") invoked verbose_function with args {'x': 1, 'y': 2, 'verbose': True, 'verbosity': 3}  [ many ]( dollar_lambda.Parser.many) What if we want to specify verbosity by the number of times that   verbose appears? For this we need  Parser.many . Before showing how we could use  Parser.many in this setting, let's look at how it works.  parser.many takes  parser and tries to apply it as many times as possible.  Parser.many is a bit like the  pattern, if you are familiar with regexes.  parser.many always succeeds: >>> p = flag(\"verbose\").many() >>> p.parse_args()  succeeds {} >>> p.parse_args(\" verbose\")  still succeeds {'verbose': True} >>> p.parse_args(\" verbose\", \" verbose\")  succeeds, binding list to 'verbose' {'verbose': [True, True]} Now returning to the original example: >>> p = nonpositional(  . flag(\"verbose\").many(),  . option(\"x\", type=int),  . option(\"y\", type=int),  . ) >>> args = p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\", \" verbose\") >>> args {'x': 1, 'y': 2, 'verbose': [True, True]} >>> verbosity = len(args['verbose']) >>> verbosity 2  [ many1 ]( dollar_lambda.Parser.many1) In the previous example, the parse will default to  verbosity=0 if no   verbose flags are given. What if we wanted users to be explicit about choosing a \"quiet\" setting? In other words, what if the user actually had to provide an explicit   quiet flag when no   verbose flags were given? For this, we use  Parser.many1 . This method is like  Parser.many except that it fails when on zero successes (recall that  Parser.many always succeeds). So if  Parser.many is like regex  ,  Parser.many1 is like [ + ]( dollar_lambda.Parser.__add__). Take a look: >>> p = flag(\"verbose\").many() >>> p.parse_args()  succeeds {} >>> p = flag(\"verbose\").many1()  note many1(), not many() >>> p.parse_args()  fails usage:  verbose [ verbose  .] The following arguments are required:  verbose >>> p.parse_args(\" verbose\")  succeeds {'verbose': True} To compell that   quiet flag from our users, we can do the following: >>> p = nonpositional(  .  flag(\"verbose\").many1( | flag(\"quiet\" ,  . option(\"x\", type=int),  . option(\"y\", type=int),  . ) Now omitting both   verbose and   quiet will fail: >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\") usage: [ verbose [ verbose  .] |  quiet] -x X -y Y Expected ' verbose'. Got '-x' >>> p.parse_args(\" verbose\", \"-x\", \"1\", \"-y\", \"2\")  this succeeds {'verbose': True, 'x': 1, 'y': 2} >>> p.parse_args(\" quiet\", \"-x\", \"1\", \"-y\", \"2\")  and this succeeds {'quiet': True, 'x': 1, 'y': 2}   CommandTree Tutorial  CommandTree has already shown up in the [Highlights section]( commandtree-for-dynamic-dispatch) and in the [tutorial]( variations-on-the-example). In this section we will give a more thorough treatment, exposing some of the underlying logic and covering all the variations in functionality that  CommandTree offers.  CommandTree draws inspiration from the [ Click ](https: click.palletsprojects.com/) library.  CommandTree.subcommand (discussed [here]( commandtreesubcommand closely approximates the functionality described in the [Commands and Groups](https: click.palletsprojects.com/en/8.1.x/commands/ command) section of the  Click documentation.   CommandTree.command First let's walk through the use of the  CommandTree.command decorator, one step at a time. First we define the object: >>> tree = CommandTree() Now we define at least one child function: >>> @tree.command()  . def f1(a: int):  . return dict(f1=dict(a=a  this can be whatever  CommandTree.command automatically converts the function arguments into a parser. We can run the parser and pass its output to our function  f1 by calling  tree : >>> tree(\"-h\") usage: -a A At this point the parser takes a single option  -a that binds an  int to  'a' : >>> tree(\"-a\", \"1\") {'f1': {'a': 1 Usually we would call  tree with no arguments, and it would get its input from  sys.argv[1:] . >>> parsers.TESTING = False  False by default but needs to be true for doctests >>> sys.argv[1:] = [\"-a\", \"1\"]  simulate command line input >>> tree() {'f1': {'a': 1 >>> parsers.TESTING = True Now let's add a second child function: >>> @tree.command()  . def f2(b: bool):  . return dict(f2=dict(b=b  this can also be whatever >>> tree(\"-h\") usage: [-a A | -b]  tree will execute either  f1 or  f2 based on which of the parsers succeeds. This will execute  f1 : >>> tree(\"-a\", \"1\") {'f1': {'a': 1 This will execute  f2 : >>> tree(\"-b\") {'f2': {'b': True This fails: >>> tree() usage: [-a A | -b] The following arguments are required: -a Often in cases where there are alternative sets of argument like this, there is also a set of shared arguments. We can define a parent function to make our help text more concise and to allow the user to run the parent function when the child arguments are not provided. >>> tree = CommandTree()  . >>> @tree.command()  . def f1(a: int):  this will be the parent function  . return dict(f1=dict(a=a Now define a child function,  g1 : >>> @f1.command()  note f1, not tree  . def g1(a:int, b: bool):  . return dict(g1=dict(b=b Make sure to include all the arguments of  f1 in  g1 or else  g1 will fail when it is invoked. In its current state,  tree sequences the arguments of  f1 and  g1 : >>> tree(\"-h\") usage: -a A -b As before we can define an additional child function to induce alternative argument sets: >>> @f1.command()  note f1, not tree  . def g2(a: int, c: str):  . return dict(g2=dict(c=c Note that our usage message shows  -a A preceding the brackets because it corresponds to the parent function: >>> tree(\"-h\") usage: -a A [-b | -c C] To execute  g1 , we give the  -b flag: >>> tree(\"-a\", \"1\", \"-b\") {'g1': {'b': True To execute  g2 , we give the  -c flag: >>> tree(\"-a\", \"1\", \"-c\", \"foo\") {'g2': {'c': 'foo' Also, note that  tree can have arbitrary depth: >>> @g1.command()  h1 is a child of g1  . def h1(a: int, b: bool, d: float):  . return dict(h1=dict(d=d Note the additional  -d D argument on the left side of the  | pipe: >>> tree(\"-h\") usage: -a A [-b -d D | -c C] That comes from the third argument of  h1 .   CommandTree.subcommand Often we want to explicitly specify which function to execute by naming it on the command line. This would implement functionality similar to [ ArgumentParser.add_subparsers ](https: docs.python.org/3/library/argparse.html argparse.ArgumentParser.add_subparsers) or [ Click.command ](https: click.palletsprojects.com/en/8.1.x/commands/ command). For this we would use the  CommandTree.subcommand decorator: >>> tree = CommandTree()  . >>> @tree.command()  . def f1(a: int):  . return dict(f1=dict(a=a  . >>> @f1.subcommand()  note subcommand, not command  . def g1(a:int, b: bool):  . return dict(g1=dict(b=b  . >>> @f1.subcommand()  again, subcommand, not command  . def g2(a: int, c: str):  . return dict(g2=dict(c=c Now the usage message indicates that  g1 and  g2 are required arguments: >>> tree(\"-h\") usage: -a A [g1 -b | g2 -c C] Now we would select g1 as follows: >>> tree(\"-a\", \"1\", \"g1\", \"-b\") {'g1': {'b': True And g2 as follows: >>> tree(\"-a\", \"1\", \"g2\", \"-c\", \"foo\") {'g2': {'c': 'foo' You can freely mix and match  subcommand and  command : >>> tree = CommandTree()  . >>> @tree.command()  . def f1(a: int):  . return dict(f1=dict(a=a  . >>> @f1.subcommand()  . def g1(a:int, b: bool):  . return dict(g1=dict(b=b  . >>> @f1.command()  note command, not subcommand  . def g2(a: int, c: str):  . return dict(g2=dict(c=c Note that the left side of the pipe (corresponding to the  g1 function) requires a  \"g1\" argument to run but the right side (corresponding to the  g2 function) does not: >>> tree(\"-h\") usage: -a A [g1 -b | -c C]  Use with config files A common use case is to have a config file with default values that arguments should fall back to if not provided on the command line. Instead of implementing specific functionality itself,  $\u03bb accommodates this situation by simply getting out of the way, thereby affording the user the most flexibility in terms of accessing and using the config file. Here is a simple example.    example-config.json { \"x\": 1 }   Define a parser with optional values where you want to be able to fall back to the config file: >>> p = option(\"x\", type=int).optional() >> argument(\"y\", type=int) >>> p.parse_args(\"-h\") usage: -x X Y In this example,  -x X can be omitted, falling back to the config, but the positional argument  Y will be required. Make sure that the optional arguments do not have default values or else the config value will always be overridden. Inside main, load the config and update with any arguments provided on the command line: >>> import json >>> def main( kwargs):  . with open(\"example-config.json\") as f:  . config = json.load(f)  .  . config.update(kwargs)  . return config Override the value in the config by providing an explicit argument: >>> main( p.parse_args(\"-x\", \"0\", \"1\" {'x': 0, 'y': 1} Fall back to the value in the config by not providing an argument for  x : >>> main( p.parse_args(\"2\" {'x': 1, 'y': 2} We can also write this with  @command syntax: >>> @command(  . parsers=dict(  . y=argument(\"y\", type=int),  . kwargs=option(\"x\", type=int).optional(),  . )  . )  . def main(y: int,  kwargs):  . with open(\"example-config.json\") as f:  . config = json.load(f)  .  . config.update( kwargs, y=y)  . return config >>> main(\"-x\", \"0\", \"1\")  override config value {'x': 0, 'y': 1} >>> main(2)  fall back to config value {'x': 1, 'y': 2}  Nesting output By default introducing a  . character into the name of an  argument ,  option , or  flag will induce nested output: >>> argument(\"a.b\", type=int).parse_args(\"1\") {'a': {'b': 1 >>> option(\"a.b\", type=int).parse_args(\" a.b\", \"1\") {'a': {'b': 1 >>> flag(\"a.b\").parse_args(\" a.b\") {'a': {'b': True This mechanism handles collisions: >>> nonpositional(flag(\"a.b\"), flag(\"a.c\" .parse_args(\" a.b\", \" a.c\") {'a': {'b': True, 'c': True even when mixing nested and unnested output: >>> nonpositional(flag(\"a\"), flag(\"a.b\" .parse_args(\"-a\", \" a.b\") {'a': [True, {'b': True}]} It can also go arbitrarily deep: >>> nonpositional(flag(\"a.b.c\"), flag(\"a.b.d\" .parse_args(\" a.b.c\", \" a.b.d\") {'a': {'b': {'c': True, 'd': True } This behavior can always be disabled by setting  nesting=False (or just not using  . in the name).  Ignoring arguments There may be cases in which a user wants to provide certain arguments on the command line that  $\u03bb should ignore (not return in the output of  Parser.parse_args or pass to the a decorated function). Suppose we wish to ignore any arguments starting with the   config- prefix: >>> regex = r\"config-\\S \" >>> config_parsers = flag(regex) | option(regex) In the case of ordered arguments, we simply use the  ignore method: >>> p = flag(\"x\") >> config_parsers.ignore() >> flag(\"y\") This will ignore any argument that starts with   config- and comes between  x and  y : >>> p.parse_args(\"-x\", \" config-foo\", \"-y\") {'x': True, 'y': True} Because of the way we defined  config_parsers , this also works with  option : >>> p.parse_args(\"-x\", \" config-bar\", \"1\", \"-y\") {'x': True, 'y': True} In the case of nonpositional arguments, use the  repeated keyword: >>> p = nonpositional(flag(\"x\"), flag(\"y\"), repeated=config_parsers.ignore( Now neither  config-foo nor  config-bar show up in the output: >>> p.parse_args(\"-x\", \"-y\", \" config-foo\", \" config-bar\", \"1\") {'x': True, 'y': True} This works regardless of order: >>> p.parse_args(\" config-baz\", \"1\", \"-y\", \" config-foz\", \"-x\") {'y': True, 'x': True} And no matter how many matches are found: >>> p.parse_args(  . \" config-foo\",  . \"1\",  . \" config-bar\",  . \"-y\",  . \" config-baz\",  . \"2\",  . \"-x\",  . \" config-foz\",  . ) {'y': True, 'x': True} The same technique can be used with decorators: >>> @command(repeated=config_parsers.ignore(  . def f(x: bool, y: bool):  . return dict(x=x, y=y) >>> f(\"-x\", \"-y\", \" config-foo\", \" config-bar\", \"1\") {'x': True, 'y': True} And similarly with  CommandTree .  Why  $\u03bb ?  $\u03bb can handle many kinds of argument-parsing patterns that are either very awkward, difficult, or impossible with other parsing libraries. In particular, we emphasize the following qualities:  Versatile  $\u03bb provides high-level functionality equivalent to other parsers. But unlike other parsers, it permits low-level customization to handle arbitrarily complex parsing patterns. There are many parsing patterns that  $\u03bb can handle which are not possible with other parsing libraries.  Type-safe  $\u03bb uses type annotations as much as Python allows. Types are checked using [ MyPy ]( https: mypy.readthedocs.io/en/stable/index.html ) and exported with the package so that users can also benefit from the type system. Furthermore, with rare exceptions,  $\u03bb avoids mutations and side-effects and preserves [referential transparency](https: en.wikipedia.org/wiki/Referential_transparency). This makes it easier for the type-checker _and for the user_ to reason about the code.  Concise  $\u03bb provides many syntactic shortcuts for cutting down boilerplate: - the  command decorator and the  CommandTree object for automatically building parsers from function signatures. - operators like [ >> ]( dollar_lambda.Parser.__rshift__), [ | ]( dollar_lambda.Parser.__or__), [ ^ ]( dollar_lambda.Parser.__xor__), and [ + ]( dollar_lambda.Parser.__add__) (and [ >= ]( dollar_lambda.Parser.__ge__) if you want to get fancy)  Lightweight  $\u03bb is written in pure python with no dependencies (excepting [ pytypeclass ](https: github.com/ethanabrooks/pytypeclass) which was written expressly for this library and has no dependencies).  $\u03bb will not introduce dependency conflicts and it installs in a flash."
    },
    {
        "ref": "dollar_lambda.Parser",
        "url": 0,
        "doc": "Main class powering the argument parser."
    },
    {
        "ref": "dollar_lambda.Parser.f",
        "url": 0,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.Parser.usage",
        "url": 0,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.Parser.helps",
        "url": 0,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.Parser.__add__",
        "url": 0,
        "doc": "Parse two arguments in either order. >>> p = flag(\"verbose\") + flag(\"debug\") >>> p.parse_args(\" verbose\", \" debug\") {'verbose': True, 'debug': True} >>> p.parse_args(\" debug\", \" verbose\") {'debug': True, 'verbose': True} >>> p.parse_args(\" debug\") usage:  verbose  debug Expected ' verbose'. Got ' debug' Note that if more than two arguments are chained together with  + , some combinations will not parse: >>> p = flag(\"a\") + flag(\"b\") + flag(\"c\") >>> p.parse_args(\"-c\", \"-a\", \"-b\")  this works {'c': True, 'a': True, 'b': True} >>> p.parse_args(\"-a\", \"-c\", \"-b\")  this doesn't usage: -a -b -c Expected '-b'. Got '-c' This makes more sense when one supplies the implicit parentheses: >>> p = (flag(\"a\") + flag(\"b\" + flag(\"c\") In order to chain together more than two arguments, use  nonpositional : >>> p = nonpositional(flag(\"a\"), flag(\"b\"), flag(\"c\" >>> p.parse_args(\"-a\", \"-c\", \"-b\") {'a': True, 'c': True, 'b': True}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.__ge__",
        "url": 0,
        "doc": "Return self>=value.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.__or__",
        "url": 0,
        "doc": "Tries apply the first parser. If it fails, tries the second. If that fails, the parser fails. >>> from dollar_lambda import argument, option, flag >>> p = option(\"option\") | flag(\"verbose\") >>> p.parse_args(\" option\", \"x\") {'option': 'x'} >>> p.parse_args(\" verbose\") {'verbose': True} Note that by default,  parse_args adds  >> Parser.done() to the end of parsers, causing  p to fail when both arguments are supplied: >>> p.parse_args(\" verbose\", \" option\", \"x\") usage: [ option OPTION |  verbose] Unrecognized argument:  option To disable this behavior, use  allow_unparsed : >>> p.parse_args(\" verbose\", \" option\", \"x\", allow_unparsed=True) {'verbose': True}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.rshift",
        "url": 0,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.__rshift__",
        "url": 0,
        "doc": "This applies parsers in sequence. If the first parser succeeds, the unparsed remainder gets handed off to the second parser. If either parser fails, the whole thing fails. >>> from dollar_lambda import argument, flag >>> p = argument(\"first\") >> argument(\"second\") >>> p.parse_args(\"a\", \"b\") {'first': 'a', 'second': 'b'} >>> p.parse_args(\"a\") usage: FIRST SECOND The following arguments are required: second >>> p.parse_args(\"b\") usage: FIRST SECOND The following arguments are required: second",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.__xor__",
        "url": 0,
        "doc": "This is the same as  __or__ , but it succeeds only if one of the two parsers fails. >>> p = argument(\"int\", type=int) ^ argument(\"div\", type=lambda x: 1 / float(x >>> p.parse_args(\"inf\")  succeeds because int(\"inf\") fails {'div': 0.0} >>> p.parse_args(\"0\")  succeeds because 1 / 0 throws an error {'int': 0} >>> p.parse_args(\"1\")  fails because both parsers succeed Both parsers succeeded. This causes ^ to fail.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.apply",
        "url": 0,
        "doc": "Takes the output of  parser and applies  f to it. Convert any errors that arise into  ArgumentError . >>> p1 = flag(\"hello\") >>> p1.parse_args(\" hello\") {'hello': True} This will double  p1 's output: >>> p2 = p1.apply(lambda out: Result.return_(out + out >>> p2.parse_args(\" hello\") {'hello': [True, True]}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.bind",
        "url": 0,
        "doc": "Returns a new parser that 1. applies  self ; 2. if this succeeds, applies  f to the parsed component of the result.  bind is one of the functions that makes  Parser a [ Monad ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L16). But most users will avoid using it directly, preferring higher level combinators like  >> ( Parser.__rshift__ ),  | ( Parser.__or__ ) and  + ( Parser.__add__ ). Note that  >= as a synonym for  bind (as defined in [ pytypeclass ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L26 and we typically prefer using the infix operator to the spelled out method. Let's start with our simplest parser,  argument : >>> p1 = argument(\"some_dest\") Now let's use the  matches parser to write a function that takes the output of  p1 and fails unless the next argument is the same as the first: >>> def f(out: Output[Sequence[KeyValue[Any ]) -> Parser[Output[str :  .  _, kv = out.get  . return matches(kv.value) >>> p = p1 >= f >>> p.parse_args(\"a\", \"a\") {'a': 'a'} >>> p.parse_args(\"a\", \"b\") Expected 'a'. Got 'b'",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.done",
        "url": 0,
        "doc": " done succeds on the end of input and fails on everything else. >>> Parser.done().parse_args() {} >>> Parser.done().parse_args(\"arg\") Unrecognized argument: arg Without  done the parser will not complain about leftover (unparsed) input: >>> flag(\"verbose\").parse_args(\" verbose\", \" quiet\", allow_unparsed=True) {'verbose': True} When  allow_unparsed=False (the default),  parse_args adds  >> Parser.done() to the end of the parser:",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.empty",
        "url": 0,
        "doc": "Always returns {}, no matter the input. Mostly useful for use in  nonpositional . >>> Parser.empty().parse_args(\"any\", \"arguments\", allow_unparsed=True) {}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.fails",
        "url": 0,
        "doc": "Succeeds only if self fails. Does not consume any input. >>> flag(\"x\").fails().parse_args(\"not x\", allow_unparsed=True)  succeeds {} >>> flag(\"x\").fails().parse_args(\"-x\", allow_unparsed=True)  fails Parser unexpectedly succeeded.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.handle_error",
        "url": 0,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.ignore",
        "url": 0,
        "doc": "Ignores the output from a parser. This is useful when you expect to give arguments to the command line that some other utility will handle. >>> p = flag(\"hello\").ignore() This will not bind any value to  \"hello\" : >>> p.parse_args(\" hello\") {} But   hello is still required: >>> p.parse_args() The following arguments are required:  hello",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.many",
        "url": 0,
        "doc": "Applies  self zero or more times (like  in regexes). Parameters      max: int Limits the number of times  many is applied in order to prevent  RecursionError s. The default for this can be increased by either setting  parser.MAX_MANY or the environment variable  DOLLAR_LAMBDA_MAX_MANY . >>> from dollar_lambda import argument, flag >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args() {} >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args(\"a\") {'as-many-as-you-like': 'a'} >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args(\"a\", \"b\") {'as-many-as-you-like': ['a', 'b']} Note that if  self contains  Parser.__or__ , the arguments can be heterogenous: >>> p = flag(\"verbose\") | flag(\"quiet\") >>> p = p.many() >>> p.parse_args(\" verbose\", \" quiet\")  mix  verbose and  quiet {'verbose': True, 'quiet': True}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.many1",
        "url": 0,
        "doc": "Applies  self one or more times (like  + in regexes). Parameters      max: int Limits the number of times  many1 is applied in order to prevent  RecursionError s. The default for this can be increased by either setting  parser.MAX_MANY or the environment variable  DOLLAR_LAMBDA_MAX_MANY . >>> from dollar_lambda import argument, flag >>> p = argument(\"1-or-more\").many1() >>> p.parse_args(\"1\") {'1-or-more': '1'} >>> p.parse_args(\"1\", \"2\") {'1-or-more': ['1', '2']} >>> p.parse_args() usage: 1-OR-MORE [1-OR-MORE  .] The following arguments are required: 1-or-more",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.map_error",
        "url": 0,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.optional",
        "url": 0,
        "doc": "Allows arguments to be optional: >>> p1 = flag(\"optional\") >>> p = p1.optional() >>> p.parse_args(\" optional\") {'optional': True} >>> p.parse_args(\" misspelled\", allow_unparsed=True)  succeeds with no output {} >>> p1.parse_args(\" misspelled\") usage:  optional Expected ' optional'. Got ' misspelled'",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.parse",
        "url": 0,
        "doc": "Applies the parser to the input sequence  cs .",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.parse_args",
        "url": 0,
        "doc": "The main way the user extracts parsed results from the parser. Parameters      args : str A sequence of strings to parse. If empty, defaults to  sys.argv[1:] . allow_unparsed : bool Whether to cause parser to fail if there are unparsed inputs. Note that setting this to false may cause unexpected behavior when using  nonpositional or  Args . check_help : bool Before running the parser, checks if the input string is   help or  -h . If it is, returns the usage message. Examples     >>> argument(\"a\").parse_args(\"-h\") usage: A >>> argument(\"a\").parse_args(\" help\") usage: A",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.return_",
        "url": 0,
        "doc": "This method is required to make  Parser a [ Monad ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L16). It consumes none of the input and always returns  a as the result. For the most part, the user will not use this method unless building custom parsers. >>> Parser.return_(Output.from_dict(some_key=\"some_value\" .parse_args() {'some_key': 'some_value'}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.sat",
        "url": 0,
        "doc": "Applies  parser , applies a predicate to the result and fails if this returns false. >>> p = option(\"x\", type=int).many().sat(  . lambda out: sum(out.get.values( > 0,  . lambda out: ArgumentError(f\"The values in {list(out.get.values( } must sum to more than 0.\"),  . ) >>> p.parse_args(\"-x\", \"-1\", \"-x\", \"1\")  fails usage: [-x X  .] The values in [-1, 1] must sum to more than 0. >>> p.parse_args(\"-x\", \"-1\", \"-x\", \"2\")  succeeds {'x': [-1, 2]} Parameters      parser : Parser[A] The parser to apply. predicate : Callable A], bool] The predicate to apply to the result of  parser .  sat fails if this predicate returns false. on_fail : Callable A], ArgumentError] A function producing an ArgumentError to return if the predicate fails. Takes the output of  parser as an argument.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.nesting",
        "url": 0,
        "doc": "Breaks the output of the wrapped parser into nested outputs. See the [ Nesting output ]( nesting-output) section of the documentation for more information.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.type",
        "url": 0,
        "doc": "A wrapper around  apply that simply applies  f to the value of the most recently parsed input. >>> p1 = option(\"x\") >> option(\"y\") >>> p = p1.type(int) >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\")  converts \"1\" but not \"2\" {'x': '1', 'y': 2}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.wrap_error",
        "url": 0,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.wrap_help",
        "url": 0,
        "doc": "This checks for the   help or  -h flag before applying  parser . If either of the flags is present, returns the usage message for  parser . >>> p = flag(\"help\", help=\"Print this help message.\").wrap_help() >>> p.parse_args(\" help\") usage:  help help: Print this help message. >>> p.parse_args(\"-h\") usage:  help help: Print this help message. We can use  wrap_help to print partial usage messages, e.g. for subcommands: >>> subcommand1 = matches(\"subcommand1\") >> option(\"option1\").wrap_help() >>> subcommand2 = matches(\"subcommand2\") >> option(\"option2\").wrap_help() >>> p = subcommand1 | subcommand2 >>> p.parse_args(\"subcommand1\", \"-h\") usage:  option1 OPTION1 >>> p.parse_args(\"subcommand2\", \"-h\") usage:  option2 OPTION2",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Parser.zero",
        "url": 0,
        "doc": "This parser always fails. This method is necessary to make  Parser a [ Monoid ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py L13). Parameters      error : Optional[ArgumentError] Customize the error returned by  zero . >>> Parser.zero().parse_args() zero >>> Parser.zero().parse_args(\"a\") zero >>> Parser.zero(error=ArgumentError(\"This is a test.\" .parse_args(\"a\") This is a test.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.apply",
        "url": 0,
        "doc": "A shortcut for   item(description).apply(f)   and spares  f the trouble of outputting a  Result object. Here is an example of usage. First we define a simple  argument parser: >>> p1 = argument(\"foo\") >>> p1.parse_args(\"bar\") {'foo': 'bar'} Here we use  f to directly manipulate the binding generated by  item : >>> p2 = apply(lambda bar: Output.from_dict( {bar + \"e\": bar + \"f\"}), description=\"baz\") >>> p2.parse_args(\"bar\") {'bare': 'barf'}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.argument",
        "url": 0,
        "doc": "Parses a single word and binds it to  dest . Useful for positional arguments. Parameters      dest : str The name of variable to bind to: nesting : bool If  True , then the parser will split the parsed output on  . yielding nested output. See Examples for more details. help : Optional[str] The help message to display for the option: type : Optional[Callable str], Any Use the  type argument to convert the input to a different type: >>> argument(\"name\").parse_args(\"Dante\") {'name': 'Dante'} >>> argument(\"name\").parse_args() usage: NAME The following arguments are required: name Here are some examples that take advantage of  nesting=True : >>> argument(\"config.name\").parse_args(\"-h\") usage: CONFIG.NAME >>> argument(\"config.name\").parse_args(\"Dante\") {'config': {'name': 'Dante' Of course, you can disable this by setting  nesting=False : >>> argument(\"config.name\", nesting=False).parse_args(\"Dante\") {'config.name': 'Dante'} >>> (argument(\"config.first.name\") >> argument(\"config.last.name\" .parse_args(\"Dante\", \"Alighieri\") {'config': {'first': {'name': 'Dante'}, 'last': {'name': 'Alighieri' }",
        "func": 1
    },
    {
        "ref": "dollar_lambda.matches",
        "url": 0,
        "doc": "Checks if the next word is  s . >>> matches(\"hello\").parse_args(\"hello\") {'hello': 'hello'} >>> matches(\"hello\").parse_args(\"goodbye\") usage: hello Expected 'hello'. Got 'goodbye' Parameters      s: str The word to that input will be checked against for equality. peak : bool If  False , then the parser will consume the word and return the remaining words as  unparsed . If  True , then the parser leaves the  unparsed component unchanged. regex : bool Whether to treat  s as a regular expression. If  False , then the parser will only succeed on string equality. Examples     >>> p = matches(\"hello\") >> matches(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") {'hello': 'hello', 'goodbye': 'goodbye'} Look what happens when  peak=True : >>> p = matches(\"hello\", peak=True) >> matches(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") usage: hello goodbye Expected 'goodbye'. Got 'hello' The first parser didn't consume the word and so \"hello\" got passed on to  equals(\"goodbye\") . But this would work: >>> p = matches(\"hello\", peak=True) >> matches(\"hello\") >> matches(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") {'hello': ['hello', 'hello'], 'goodbye': 'goodbye'}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.flag",
        "url": 0,
        "doc": "Binds a boolean value to a variable. >>> p = flag(\"verbose\") >>> p.parse_args(\" verbose\") {'verbose': True} Parameters      dest : str The variable to which the value will be bound. default : Optional[bool] An optional default value. help : Optional[str] An optional help string. nesting : bool If  True , then the parser will split the parsed output on  . yielding nested output. See Examples for more details. regex : bool If  True , then the parser will use a regex to match the flag string. short : bool Whether to check for the short form of the flag, which uses a single dash and the first character of  dest , e.g.  -f for  foo . string : Optional[str] A custom string to use for the flag. Defaults to   {dest} . Examples     Here is an example using the  default parameter: >>> p = flag(\"verbose\", default=False) >>> p.parse_args(\"-h\") usage:  verbose >>> p.parse_args() {'verbose': False} By default  flag fails when it does not receive expected input: >>> p = flag(\"verbose\") >>> p.parse_args() usage:  verbose The following arguments are required:  verbose Here is an example using the  help parameter: >>> p = flag(\"verbose\", help=\"Turn on verbose output.\") >>> p.parse_args(\"-h\") usage:  verbose verbose: Turn on verbose output. Here is an example using the  short parameter: >>> flag(\"verbose\", short=True).parse_args(\"-v\")  this is the default {'verbose': True} >>> flag(\"verbose\", short=False).parse_args(\"-v\")  fails usage:  verbose Expected ' verbose'. Got '-v' Here is an example using the  string parameter: >>> flag(\"value\", string=\"v\").parse_args(\"v\")  note that string does not have to start with - {'value': True} >>> flag(\"config.value\").parse_args(\" config.value\") {'config': {'value': True ",
        "func": 1
    },
    {
        "ref": "dollar_lambda.item",
        "url": 0,
        "doc": "Parses a single word and binds it to  dest . One of the lowest level building blocks for parsers. Parameters      usage_name : Optional[str] Used for generating usage text Examples     >>> p = item(\"name\", usage_name=\"Your first name\") >>> p.parse_args(\"Alice\") {'name': 'Alice'} >>> p.parse_args() usage: name The following arguments are required: Your first name",
        "func": 1
    },
    {
        "ref": "dollar_lambda.nonpositional",
        "url": 0,
        "doc": " nonpositional takes a sequence of parsers as arguments and attempts all permutations of them, returning the first permutations that is successful: >>> p = nonpositional(flag(\"verbose\"), flag(\"quiet\" >>> p.parse_args(\" verbose\", \" quiet\") {'verbose': True, 'quiet': True} >>> p.parse_args(\" quiet\", \" verbose\")  reverse order also works {'quiet': True, 'verbose': True} Parameters      max: int Limits the number of times  repeated is applied in order to prevent  RecursionError s. The default for this can be increased by either setting  parser.MAX_MANY or the environment variable  DOLLAR_LAMBDA_MAX_MANY . repeated : Optional[Parser[Sequence[A ] If provided, this parser gets applied repeatedly (zero or more times) at all positions. Examples     >>> p = nonpositional(repeated=flag(\"x\" >>> p.parse_args() {} >>> p.parse_args(\"-x\") {'x': True} >>> p.parse_args(\"-x\", \"-x\") {'x': [True, True]} >>> p = nonpositional(flag(\"y\"), repeated=flag(\"x\" >>> p.parse_args(\"-y\") {'y': True} >>> p.parse_args(\"-y\", \"-x\") {'y': True, 'x': True} >>> p.parse_args(\"-x\", \"-y\") {'x': True, 'y': True} >>> p.parse_args(\"-y\", \"-x\", \"-x\") {'y': True, 'x': [True, True]} >>> p.parse_args(\"-x\", \"-y\", \"-x\") {'x': [True, True], 'y': True} >>> p.parse_args(\"-x\", \"-x\", \"-y\") {'x': [True, True], 'y': True} >>> p = nonpositional(flag(\"y\"), repeated=(flag(\"x\") | flag(\"z\" .ignore( >>> p.parse_args(\"-x\", \"-y\", \"-z\") {'y': True}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.option",
        "url": 0,
        "doc": "Parses two words, binding the second to the first. Parameters      dest : str The name of variable to bind to: default : Optional[Any] The default value to bind on failure: flag : Optional[str] The flag to use for the option. If not provided, defaults to   {dest} . help : Optional[str] The help message to display for the option: nesting : bool If  True , then the parser will split the parsed output on  . yielding nested output. See Examples for more details. regex : bool If  True , then the parser will match the flag string as a regex. short : bool Whether to check for the short form of the flag, which uses a single dash and the first character of  dest , e.g.  -c for  count . type : Callable str], Any] Use the  type argument to convert the input to a different type: Examples     >>> option(\"count\").parse_args(\" count\", \"1\") {'count': '1'} In this example, you can see that the  flag parameter allows the user to specify an arbitrary lead string, including one that doesn't start with a dash. >>> option(\"count\", flag=\"ct\").parse_args(\"ct\", \"1\") {'count': '1'} This example demonstrates the use of the  default parameter: >>> p = option(\"count\", default=2) >>> p.parse_args(\"-h\") usage:  count COUNT count: (default: 2) >>> p.parse_args() {'count': 2} Here we specify a help-string using the  help parameter: >>> option(\"count\", help=\"The number we should count to\").parse_args(\"-h\") usage:  count COUNT count: The number we should count to This example demonstrates the difference between  short=True and  short=False : >>> option(\"count\", short=True).parse_args(\"-c\", \"1\") {'count': '1'} >>> option(\"count\", short=False).parse_args(\"-c\", \"1\") usage:  count COUNT Expected ' count'. Got '-c' As with [argparse](https: docs.python.org/3/library/argparse.html argument-parsing), the  type argument allows you to convert the input to a different type using a function that takes a single string argument: >>> option(\"x\", type=int).parse_args(\"-x\", \"1\")  converts \"1\" to an int {'x': 1} >>> option(\"x\", type=lambda x: int(x) + 1).parse_args(\"-x\", \"1\") {'x': 2} >>> option(\"config.x\").parse_args(\" config.x\", \"a\") {'config': {'x': 'a' ",
        "func": 1
    },
    {
        "ref": "dollar_lambda.sat",
        "url": 0,
        "doc": "A wrapper around  Parser.sat that uses  item to parse the argument and just applies  predicate to the value output by  item . >>> p = sat(lambda x: len(x)  1, lambda x: ArgumentError(f\"'{x}' must have exactly one character.\"), \"x\") >>> p.parse_args(\"a\")  succeeds {'x': 'a'} >>> p.parse_args(\"aa\")  fails usage: x 'aa' must have exactly one character. Parameters      predicate : Callable A], bool] The predicate to apply to the result of  item .  sat fails if this predicate returns false. on_fail : Callable A], ArgumentError] A function producing an ArgumentError to return if the predicate fails. Takes the output of  item as an argument. name: str The value to bind the result to.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Args",
        "url": 0,
        "doc": " Args is sugar for the  nonpositional function and removes much of the boilerplate from defining parsers with many arguments. >>> @dataclass  . class MyArgs(Args):  . verbose: bool  . count: int >>> MyArgs.parse_args(\" verbose\", \" count\", \"1\") {'verbose': True, 'count': 1}  MyArgs will accept these arguments in any order: >>> MyArgs.parse_args(\" count\", \"1\", \" verbose\") {'count': 1, 'verbose': True} Note that when the default value of an argument is  True ,  Args will, by default add   no- to the front of the flag (while still assigning the value to the original key): >>> @dataclass  . class MyArgs(Args):  . tests: bool = True >>> MyArgs.parse_args(\" no-tests\") {'tests': False} >>> MyArgs.parse_args() {'tests': True} To suppress this behavior, set  flip_bools=False : >>> MyArgs.parse_args(\" tests\", flip_bools=False) {'tests': False} By using the  Args.parser() method,  Args can take advantage of all the same combinators as other parsers: >>> from dollar_lambda import argument >>> p = MyArgs.parser() >>> p1 = p >> argument(\"a\") >>> p1.parse_args(\" no-tests\", \"hello\") {'tests': False, 'a': 'hello'} To supply other metadata, like  help text or custom parsers, use  field : @dataclass >>> @dataclass  . class MyArgs(Args):  . x: int = field(default=0, help=\"a number\")  . y: int = field(  . default=1,  . parser=option(\"y\", type=lambda s: int(s) + 1, help=\"a number to increment\"),  . ) >>> MyArgs.parse_args(\"-h\") usage: -x X -y Y x: a number y: a number to increment This supplies defaults for  y when omitted: >>> MyArgs.parse_args(\"-x\", \"10\") {'x': 10, 'y': 1} It also applies the custom type to  y when  \"-y\" is given >>> MyArgs.parse_args() {'x': 0, 'y': 1}"
    },
    {
        "ref": "dollar_lambda.Args.parser",
        "url": 0,
        "doc": "Returns a parser for the dataclass. Converts each field to a parser ( option or  flag depending on its type). Combines these parsers using  nonpositional . Parameters      flip_bools: bool Whether to add   no-  before arguments that default to  True . Examples     >>> @dataclass  . class MyArgs(Args):  . tests: bool = True Note the leading   no- : >>> MyArgs.parse_args(\" no-tests\") {'tests': False} >>> MyArgs.parse_args() {'tests': True} To suppress this behavior, set  flip_bools=False : >>> MyArgs.parse_args(\" tests\", flip_bools=False) {'tests': False}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.Args.parse_args",
        "url": 0,
        "doc": "Parses the arguments and returns a dictionary of the parsed values.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.defaults",
        "url": 0,
        "doc": "Useful for assigning default values to arguments. It ignore the input and always returns  kwargs converted into  CollisionDict .  defaults never failsekpoi >>> defaults(a=1, b=2).parse_args() {'a': 1, 'b': 2} >>> (flag(\"fails\") | defaults(fails=\"succeeds\" .parse_args() {'fails': 'succeeds'} Here's a more complex example derived from the tutorial: >>> p = nonpositional(  . (  . flag(\"verbose\") + defaults(quiet=False)  either  verbose and default \"quiet\" to False  . | flag(\"quiet\") + defaults(verbose=False)  or  quiet and default \"verbose\" to False  . ),  . option(\"x\", type=int, help=\"the base\"),  . option(\"y\", type=int, help=\"the exponent\"),  . ) >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\") {'x': 1, 'y': 2, 'verbose': True, 'quiet': False}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.field",
        "url": 0,
        "doc": "This is a thin wrapper around [ dataclasses.field ](https: docs.python.org/3/library/dataclasses.html dataclasses.field). Parameters      help : str An optional help string for the argument. metadata : str Identical to the  metadata argument for [ dataclasses.field ](https: docs.python.org/3/library/dataclasses.html dataclasses.field). type : Optional[type | Callable str], Any A function that takes a string and returns a value just like the  type argument for [ ArgumentParser.add_argument ](https: docs.python.org/3/library/argparse.html type). Returns    - A  dataclasses.Field object that can be used in place of a default argument as described in the [ dataclasses.Field documentation](https: docs.python.org/3/library/dataclasses.html dataclasses.field).",
        "func": 1
    },
    {
        "ref": "dollar_lambda.command",
        "url": 0,
        "doc": "A succinct way to generate a simple  nonpositional parser.  @command derives the component parsers from the function's signature and automatically executes the function with the parsed arguments, if parsing succeeds: >>> @command(help=dict(a=\"something about a\"  . def f(a: int = 1, b: bool = False):  . return dict(a=a, b=b) >>> f(\"-a\", \"2\", \"-b\") {'a': 2, 'b': True} If the wrapped function receives no arguments (as in  f() ), the parser will take  sys.argv[1:] as the input. Note that  @command does not handle mutually exclusive arguments or alternative arguments. Parameters      flip_bools : bool For boolean arguments that default to true, this changes the flag from   {dest} to   no-{dest} : help : dict[str, str] A dictionary of help strings for the arguments. repeated: Optional[Parser[Sequence[KeyValue[Any  If provided, this parser gets applied repeatedly (zero or more times) at all positions. strings : dict[str, str] This dictionary maps variable names to the strings that the parser will look for in the input. Examples     >>> @command()  . def f(cuda: bool = True):  . return dict(cuda=cuda) >>> f() {'cuda': True} >>> f(\" no-cuda\")  flip_bools adds  no- to the flag {'cuda': False} As the following example demonstrates, when  flip_bools=False output can be somewhat confusing: >>> @command(flip_bools=False)  . def f(cuda: bool = True):  . return dict(cuda=cuda) >>> f(\" cuda\") {'cuda': False} Here is an example using the  help parameter: >>> @command(help=dict(quiet=\"Be quiet\"  . def f(quiet: bool):  . return dict(quiet=quiet) >>> f(\" help\") usage:  quiet quiet: Be quiet Here is an example using the  parser parameter: TODO!",
        "func": 1
    },
    {
        "ref": "dollar_lambda.CommandTree",
        "url": 0,
        "doc": "Allows parsers to dynamically dispatch their results based on the input. For usage details, see the [ CommandTree tutorial]( commandtree-tutorial)."
    },
    {
        "ref": "dollar_lambda.CommandTree.command",
        "url": 0,
        "doc": "A decorator for adding a function as a child of this tree. Parameters      can_run: bool Whether the parser will permit the decorated function to run if no further arguments are supplied. flip_bools: bool Whether to add   no-  before arguments that default to  True . help: dict A dictionary of help strings for the arguments. repeated: Optional[Parser[Sequence[KeyValue[Any  If provided, this parser gets applied repeatedly (zero or more times) at all positions. parsers: dict TODO Examples     With  flip_bools set to  True : >>> tree = CommandTree()  . >>> @tree.command(flip_bools=True)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage:  no-b b: (default: True) With  flip_bools set to  False : >>> tree = CommandTree()  . >>> @tree.command(flip_bools=False)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: -b b: (default: True) With  can_run set to  True (the default), we can run  f1 by not passing arguments for the  f1 's children: >>> tree = CommandTree()  . >>> @tree.command(can_run=True)   >> @f1.command()  . def g1(n: int):  . return dict(g1=dict(b=b, n=n  . >>> tree(\"-h\") usage: -b -n N >>> tree(\"-b\") {'f1': {'b': True With  can_run set to  False , the parser will fail if the child function arguments are not supplied: >>> tree = CommandTree()  . >>> @tree.command(can_run=False)   >> @f1.command()  . def g1(n: int):  . return dict(g1=dict(b=b, n=n  . >>> tree(\"-h\") usage: -b -n N >>> tree(\"f1\", \"-b\") usage: -b -n N Expected '-b'. Got 'f1'",
        "func": 1
    },
    {
        "ref": "dollar_lambda.CommandTree.subcommand",
        "url": 0,
        "doc": "A decorator for adding a function as a child of this tree. As a subcommand, the function's name must be invoked on the command line for the function to be called. Parameters      can_run: bool Whether the parser will permit the decorated function to run if no further arguments are supplied. flip_bools: bool Whether to add   no-  before arguments that default to  True . help: Dict[str, str] A dictionary of help strings for the arguments. repeated: Optional[Parser[Sequence[KeyValue[Any  If provided, this parser gets applied repeatedly (zero or more times) at all positions. See  nonpositional for examples. parsers: Dict[str, Parser] A dictionary reserving arguments for custom parsers. See below for examples. See  command for examples. Examples     With  flip_bools set to  True : >>> tree = CommandTree()  . >>> @tree.subcommand(flip_bools=True)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: f1  no-b b: (default: True) With  flip_bools set to  False : >>> tree = CommandTree()  . >>> @tree.subcommand(flip_bools=False)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: f1 -b b: (default: True) With  can_run set to  True (the default), we can run  f1 by not passing arguments for the  f1 's children: >>> tree = CommandTree()  . >>> @tree.subcommand(can_run=True)   >> @f1.subcommand()  . def g1(b: bool, n: int):  . return dict(g1=dict(b=b, n=n  . >>> tree(\"-h\") usage: f1 -b g1 -n N >>> tree(\"f1\", \"-b\") {'f1': {'b': True With  can_run set to  False , the parser will fail if the child function arguments are not supplied: >>> tree = CommandTree()  . >>> @tree.subcommand(can_run=False)   >> @f1.subcommand()  . def g1(b: bool, n: int):  . return dict(g1=dict(b=b, n=n  . >>> tree(\"-h\") usage: f1 -b g1 -n N >>> tree(\"f1\", \"-b\") usage: f1 -b g1 -n N The following arguments are required: g1",
        "func": 1
    },
    {
        "ref": "dollar_lambda.error",
        "url": 1,
        "doc": "Defines errors which can be raised by parsers."
    },
    {
        "ref": "dollar_lambda.error.ArgumentError",
        "url": 1,
        "doc": "ArgumentError(usage: str)"
    },
    {
        "ref": "dollar_lambda.error.ArgumentError.usage",
        "url": 1,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.error.BinaryError",
        "url": 1,
        "doc": "BinaryError(usage: str, error1: dollar_lambda.error.ArgumentError, error2: dollar_lambda.error.ArgumentError)"
    },
    {
        "ref": "dollar_lambda.error.BinaryError.error1",
        "url": 1,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.error.BinaryError.error2",
        "url": 1,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.error.ExceptionError",
        "url": 1,
        "doc": "ExceptionError(usage: str, exception: Exception)"
    },
    {
        "ref": "dollar_lambda.error.ExceptionError.exception",
        "url": 1,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.error.UnequalError",
        "url": 1,
        "doc": "UnequalError(usage: str, left: ~A, right: ~A)"
    },
    {
        "ref": "dollar_lambda.error.UnequalError.left",
        "url": 1,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.error.UnequalError.right",
        "url": 1,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.error.MissingError",
        "url": 1,
        "doc": "MissingError(usage: str, missing: str)"
    },
    {
        "ref": "dollar_lambda.error.MissingError.missing",
        "url": 1,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.error.ZeroError",
        "url": 1,
        "doc": "ZeroError(usage: str)"
    },
    {
        "ref": "dollar_lambda.error.UnexpectedError",
        "url": 1,
        "doc": "UnexpectedError(usage: str, unexpected: str)"
    },
    {
        "ref": "dollar_lambda.error.UnexpectedError.unexpected",
        "url": 1,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.error.HelpError",
        "url": 1,
        "doc": "HelpError(usage: str)"
    },
    {
        "ref": "dollar_lambda.data_structures",
        "url": 2,
        "doc": "Defines  Sequence , a strongly-typed immutable list that implements  MonadPlus ."
    },
    {
        "ref": "dollar_lambda.data_structures.Colliding",
        "url": 2,
        "doc": "A more or less complete user-defined wrapper around list objects."
    },
    {
        "ref": "dollar_lambda.data_structures.partition",
        "url": 2,
        "doc": "Use a predicate to partition entries into false entries and true entries",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.TreePath",
        "url": 2,
        "doc": "TreePath(parents: 'NonemptyList[str]', leaf: 'A')"
    },
    {
        "ref": "dollar_lambda.data_structures.TreePath.parents",
        "url": 2,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.data_structures.TreePath.leaf",
        "url": 2,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.data_structures.TreePath.make",
        "url": 2,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.TreePath.merge",
        "url": 2,
        "doc": "Merge a list of paths into a nested dictionary, handling collisions with  Sequence.to_dict (which uses  Sequence.to_collision_dict ). >>> tp1 = TreePath.make(\"a\", leaf=1) >>> tp2 = TreePath.make(\"b\", leaf=2) >>> TreePath.merge(tp1, tp2) {'a': 1, 'b': 2} >>> tp1 = TreePath.make(\"a\", leaf=1) >>> tp2 = TreePath.make(\"a\", leaf=2) >>> TreePath.merge(tp1, tp2) {'a': [1, 2]} >>> tp1 = TreePath.make(\"a\", \"b\", leaf=1) >>> tp2 = TreePath.make(\"a\", \"c\", leaf=2) >>> TreePath.merge(tp1, tp2) {'a': {'b': 1, 'c': 2 >>> tp1 = TreePath.make(\"a\", \"b\", leaf=1) >>> tp2 = TreePath.make(\"a\", \"b\", leaf=2) >>> TreePath.merge(tp1, tp2) {'a': {'b': [1, 2] >>> tp1 = TreePath.make(\"a\", \"b\", leaf=1) >>> tp2 = TreePath.make(\"b\", leaf=1) >>> TreePath.merge(tp1, tp2) {'a': {'b': 1}, 'b': 1} >>> tp1 = TreePath.make(\"a\", \"b\", leaf=1) >>> tp2 = TreePath.make(\"a\", leaf=2) >>> TreePath.merge(tp1, tp2) {'a': [2, {'b': 1}]} >>> tp1 = TreePath.make(\"a\", \"b\", leaf=1) >>> tp2 = TreePath.make(\"a\", leaf=\"b\") >>> TreePath.merge(tp1, tp2) {'a': ['b', {'b': 1}]} >>> tp1 = TreePath.make(\"a\", \"b\", leaf=1) >>> tp2 = TreePath.make(\"a\", \"b\", leaf=2) >>> tp3 = TreePath.make(\"a\", leaf=2) >>> TreePath.merge(tp1, tp2, tp3) {'a': [2, {'b': [1, 2]}]}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.KeyValue",
        "url": 2,
        "doc": "KeyValue(key: 'str', value: 'A_co')"
    },
    {
        "ref": "dollar_lambda.data_structures.KeyValue.key",
        "url": 2,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.data_structures.KeyValue.value",
        "url": 2,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.data_structures.Sequence",
        "url": 2,
        "doc": "This class combines the functionality of [ MonadPlus ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py L24) and [ typing.Sequence ](https: docs.python.org/3/library/typing.html typing.Sequence). >>> s = Sequence([1, 2]) >>> len(s) 2 >>> s[0] 1 >>> s[-1] 2 >>> s + s  sequences emulate list behavior when added Sequence(get=[1, 2, 1, 2]) >>> [x + 1 for x in s]  sequences can be iterated over [2, 3] >>> Sequence([1, 2]) >= (lambda x: Sequence([x, -x] Sequence(get=[1, -1, 2, -2])"
    },
    {
        "ref": "dollar_lambda.data_structures.Sequence.get",
        "url": 2,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.data_structures.Sequence.bind",
        "url": 2,
        "doc": ">>> Sequence([1, 2]) >= (lambda x: Sequence([x, -x] Sequence(get=[1, -1, 2, -2])",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.Sequence.from_dict",
        "url": 2,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.Sequence.keys",
        "url": 2,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.Sequence.return_",
        "url": 2,
        "doc": ">>> Sequence.return_(1) Sequence(get=[1])",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.Sequence.to_colliding_dict",
        "url": 2,
        "doc": "Handles collisions at the root level of the tree. Does not handle  TreePath s. >>> Sequence([KeyValue(\"a\", 1), KeyValue(\"b\", 2), KeyValue(\"a\", 3)]).to_colliding_dict() {'a': [1, 3], 'b': 2} >>> Sequence([KeyValue(\"a\", [1]), KeyValue(\"b\", 2), KeyValue(\"a\", [3])]).to_colliding_dict() {'a':  1], [3 , 'b': 2}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.Sequence.to_dict",
        "url": 2,
        "doc": "Expand a sequence of key-value pairs into a dictionary. Handles collidions and  TreePath s. >>> Sequence([KeyValue(\"a\", 1), KeyValue(\"b\", 2), KeyValue(\"a\", 3)]).to_dict() {'a': [1, 3], 'b': 2} >>> Sequence([KeyValue(\"a\", [1]), KeyValue(\"b\", 2), KeyValue(\"a\", [3])]).to_dict() {'a':  1], [3 , 'b': 2} >>> Sequence([KeyValue(\"a\", TreePath.make(\"b\", leaf=\"c\" ]).to_dict() {'a': {'b': 'c' >>> Sequence(  . [  . KeyValue(\"a\", \"b\"),  . KeyValue(\"a\", TreePath.make(\"b\", leaf=\"c\" ,  . KeyValue(\"a\", TreePath.make(\"b\", \"c\", leaf=1 ,  . KeyValue(\"a\", TreePath.make(\"b\", \"c\", leaf=2 ,  . ]  . ).to_dict() {'a': ['b', {'b': ['c', {'c': [1, 2]}]}]}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.Sequence.values",
        "url": 2,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.Sequence.zero",
        "url": 2,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.Output",
        "url": 2,
        "doc": "Output(get: 'A_co_monoid')"
    },
    {
        "ref": "dollar_lambda.data_structures.Output.get",
        "url": 2,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.data_structures.Output.from_dict",
        "url": 2,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.data_structures.Output.zero",
        "url": 2,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser",
        "url": 3,
        "doc": "Defines parsing functions and the  Parser class that they instantiate."
    },
    {
        "ref": "dollar_lambda.parser.Parse",
        "url": 3,
        "doc": "A  Parse is the output of parsing. Parameters      parsed : A Component parsed by the parsed unparsed : Sequence[str] Component yet to be parsed"
    },
    {
        "ref": "dollar_lambda.parser.Parse.parsed",
        "url": 3,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.parser.Parse.unparsed",
        "url": 3,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.parser.SuccessError",
        "url": 3,
        "doc": "SuccessError(usage: str, input: 'Sequence[str]', output: 'NonemptyList[Parse[A_monoid ')"
    },
    {
        "ref": "dollar_lambda.parser.SuccessError.input",
        "url": 3,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.parser.SuccessError.output",
        "url": 3,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.parser.binary_usage",
        "url": 3,
        "doc": "Utility for generating usage strings for binary operators.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser",
        "url": 3,
        "doc": "Main class powering the argument parser."
    },
    {
        "ref": "dollar_lambda.parser.Parser.f",
        "url": 3,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.parser.Parser.usage",
        "url": 3,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.parser.Parser.helps",
        "url": 3,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.parser.Parser.rshift",
        "url": 3,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.apply",
        "url": 3,
        "doc": "Takes the output of  parser and applies  f to it. Convert any errors that arise into  ArgumentError . >>> p1 = flag(\"hello\") >>> p1.parse_args(\" hello\") {'hello': True} This will double  p1 's output: >>> p2 = p1.apply(lambda out: Result.return_(out + out >>> p2.parse_args(\" hello\") {'hello': [True, True]}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.bind",
        "url": 3,
        "doc": "Returns a new parser that 1. applies  self ; 2. if this succeeds, applies  f to the parsed component of the result.  bind is one of the functions that makes  Parser a [ Monad ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L16). But most users will avoid using it directly, preferring higher level combinators like  >> ( Parser.__rshift__ ),  | ( Parser.__or__ ) and  + ( Parser.__add__ ). Note that  >= as a synonym for  bind (as defined in [ pytypeclass ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L26 and we typically prefer using the infix operator to the spelled out method. Let's start with our simplest parser,  argument : >>> p1 = argument(\"some_dest\") Now let's use the  matches parser to write a function that takes the output of  p1 and fails unless the next argument is the same as the first: >>> def f(out: Output[Sequence[KeyValue[Any ]) -> Parser[Output[str :  .  _, kv = out.get  . return matches(kv.value) >>> p = p1 >= f >>> p.parse_args(\"a\", \"a\") {'a': 'a'} >>> p.parse_args(\"a\", \"b\") Expected 'a'. Got 'b'",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.done",
        "url": 3,
        "doc": " done succeds on the end of input and fails on everything else. >>> Parser.done().parse_args() {} >>> Parser.done().parse_args(\"arg\") Unrecognized argument: arg Without  done the parser will not complain about leftover (unparsed) input: >>> flag(\"verbose\").parse_args(\" verbose\", \" quiet\", allow_unparsed=True) {'verbose': True} When  allow_unparsed=False (the default),  parse_args adds  >> Parser.done() to the end of the parser:",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.empty",
        "url": 3,
        "doc": "Always returns {}, no matter the input. Mostly useful for use in  nonpositional . >>> Parser.empty().parse_args(\"any\", \"arguments\", allow_unparsed=True) {}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.fails",
        "url": 3,
        "doc": "Succeeds only if self fails. Does not consume any input. >>> flag(\"x\").fails().parse_args(\"not x\", allow_unparsed=True)  succeeds {} >>> flag(\"x\").fails().parse_args(\"-x\", allow_unparsed=True)  fails Parser unexpectedly succeeded.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.handle_error",
        "url": 3,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.ignore",
        "url": 3,
        "doc": "Ignores the output from a parser. This is useful when you expect to give arguments to the command line that some other utility will handle. >>> p = flag(\"hello\").ignore() This will not bind any value to  \"hello\" : >>> p.parse_args(\" hello\") {} But   hello is still required: >>> p.parse_args() The following arguments are required:  hello",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.many",
        "url": 3,
        "doc": "Applies  self zero or more times (like  in regexes). Parameters      max: int Limits the number of times  many is applied in order to prevent  RecursionError s. The default for this can be increased by either setting  parser.MAX_MANY or the environment variable  DOLLAR_LAMBDA_MAX_MANY . >>> from dollar_lambda import argument, flag >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args() {} >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args(\"a\") {'as-many-as-you-like': 'a'} >>> p = argument(\"as-many-as-you-like\").many() >>> p.parse_args(\"a\", \"b\") {'as-many-as-you-like': ['a', 'b']} Note that if  self contains  Parser.__or__ , the arguments can be heterogenous: >>> p = flag(\"verbose\") | flag(\"quiet\") >>> p = p.many() >>> p.parse_args(\" verbose\", \" quiet\")  mix  verbose and  quiet {'verbose': True, 'quiet': True}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.many1",
        "url": 3,
        "doc": "Applies  self one or more times (like  + in regexes). Parameters      max: int Limits the number of times  many1 is applied in order to prevent  RecursionError s. The default for this can be increased by either setting  parser.MAX_MANY or the environment variable  DOLLAR_LAMBDA_MAX_MANY . >>> from dollar_lambda import argument, flag >>> p = argument(\"1-or-more\").many1() >>> p.parse_args(\"1\") {'1-or-more': '1'} >>> p.parse_args(\"1\", \"2\") {'1-or-more': ['1', '2']} >>> p.parse_args() usage: 1-OR-MORE [1-OR-MORE  .] The following arguments are required: 1-or-more",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.map_error",
        "url": 3,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.optional",
        "url": 3,
        "doc": "Allows arguments to be optional: >>> p1 = flag(\"optional\") >>> p = p1.optional() >>> p.parse_args(\" optional\") {'optional': True} >>> p.parse_args(\" misspelled\", allow_unparsed=True)  succeeds with no output {} >>> p1.parse_args(\" misspelled\") usage:  optional Expected ' optional'. Got ' misspelled'",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.parse",
        "url": 3,
        "doc": "Applies the parser to the input sequence  cs .",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.parse_args",
        "url": 3,
        "doc": "The main way the user extracts parsed results from the parser. Parameters      args : str A sequence of strings to parse. If empty, defaults to  sys.argv[1:] . allow_unparsed : bool Whether to cause parser to fail if there are unparsed inputs. Note that setting this to false may cause unexpected behavior when using  nonpositional or  Args . check_help : bool Before running the parser, checks if the input string is   help or  -h . If it is, returns the usage message. Examples     >>> argument(\"a\").parse_args(\"-h\") usage: A >>> argument(\"a\").parse_args(\" help\") usage: A",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.return_",
        "url": 3,
        "doc": "This method is required to make  Parser a [ Monad ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monad.py L16). It consumes none of the input and always returns  a as the result. For the most part, the user will not use this method unless building custom parsers. >>> Parser.return_(Output.from_dict(some_key=\"some_value\" .parse_args() {'some_key': 'some_value'}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.sat",
        "url": 3,
        "doc": "Applies  parser , applies a predicate to the result and fails if this returns false. >>> p = option(\"x\", type=int).many().sat(  . lambda out: sum(out.get.values( > 0,  . lambda out: ArgumentError(f\"The values in {list(out.get.values( } must sum to more than 0.\"),  . ) >>> p.parse_args(\"-x\", \"-1\", \"-x\", \"1\")  fails usage: [-x X  .] The values in [-1, 1] must sum to more than 0. >>> p.parse_args(\"-x\", \"-1\", \"-x\", \"2\")  succeeds {'x': [-1, 2]} Parameters      parser : Parser[A] The parser to apply. predicate : Callable A], bool] The predicate to apply to the result of  parser .  sat fails if this predicate returns false. on_fail : Callable A], ArgumentError] A function producing an ArgumentError to return if the predicate fails. Takes the output of  parser as an argument.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.nesting",
        "url": 3,
        "doc": "Breaks the output of the wrapped parser into nested outputs. See the [ Nesting output ]( nesting-output) section of the documentation for more information.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.type",
        "url": 3,
        "doc": "A wrapper around  apply that simply applies  f to the value of the most recently parsed input. >>> p1 = option(\"x\") >> option(\"y\") >>> p = p1.type(int) >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\")  converts \"1\" but not \"2\" {'x': '1', 'y': 2}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.wrap_error",
        "url": 3,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.wrap_help",
        "url": 3,
        "doc": "This checks for the   help or  -h flag before applying  parser . If either of the flags is present, returns the usage message for  parser . >>> p = flag(\"help\", help=\"Print this help message.\").wrap_help() >>> p.parse_args(\" help\") usage:  help help: Print this help message. >>> p.parse_args(\"-h\") usage:  help help: Print this help message. We can use  wrap_help to print partial usage messages, e.g. for subcommands: >>> subcommand1 = matches(\"subcommand1\") >> option(\"option1\").wrap_help() >>> subcommand2 = matches(\"subcommand2\") >> option(\"option2\").wrap_help() >>> p = subcommand1 | subcommand2 >>> p.parse_args(\"subcommand1\", \"-h\") usage:  option1 OPTION1 >>> p.parse_args(\"subcommand2\", \"-h\") usage:  option2 OPTION2",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.Parser.zero",
        "url": 3,
        "doc": "This parser always fails. This method is necessary to make  Parser a [ Monoid ](https: github.com/ethanabrooks/pytypeclass/blob/fe6813e69c1def160c77dea1752f4235820793df/pytypeclass/monoid.py L13). Parameters      error : Optional[ArgumentError] Customize the error returned by  zero . >>> Parser.zero().parse_args() zero >>> Parser.zero().parse_args(\"a\") zero >>> Parser.zero(error=ArgumentError(\"This is a test.\" .parse_args(\"a\") This is a test.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.apply",
        "url": 3,
        "doc": "A shortcut for   item(description).apply(f)   and spares  f the trouble of outputting a  Result object. Here is an example of usage. First we define a simple  argument parser: >>> p1 = argument(\"foo\") >>> p1.parse_args(\"bar\") {'foo': 'bar'} Here we use  f to directly manipulate the binding generated by  item : >>> p2 = apply(lambda bar: Output.from_dict( {bar + \"e\": bar + \"f\"}), description=\"baz\") >>> p2.parse_args(\"bar\") {'bare': 'barf'}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.argument",
        "url": 3,
        "doc": "Parses a single word and binds it to  dest . Useful for positional arguments. Parameters      dest : str The name of variable to bind to: nesting : bool If  True , then the parser will split the parsed output on  . yielding nested output. See Examples for more details. help : Optional[str] The help message to display for the option: type : Optional[Callable str], Any Use the  type argument to convert the input to a different type: >>> argument(\"name\").parse_args(\"Dante\") {'name': 'Dante'} >>> argument(\"name\").parse_args() usage: NAME The following arguments are required: name Here are some examples that take advantage of  nesting=True : >>> argument(\"config.name\").parse_args(\"-h\") usage: CONFIG.NAME >>> argument(\"config.name\").parse_args(\"Dante\") {'config': {'name': 'Dante' Of course, you can disable this by setting  nesting=False : >>> argument(\"config.name\", nesting=False).parse_args(\"Dante\") {'config.name': 'Dante'} >>> (argument(\"config.first.name\") >> argument(\"config.last.name\" .parse_args(\"Dante\", \"Alighieri\") {'config': {'first': {'name': 'Dante'}, 'last': {'name': 'Alighieri' }",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.defaults",
        "url": 3,
        "doc": "Useful for assigning default values to arguments. It ignore the input and always returns  kwargs converted into  CollisionDict .  defaults never failsekpoi >>> defaults(a=1, b=2).parse_args() {'a': 1, 'b': 2} >>> (flag(\"fails\") | defaults(fails=\"succeeds\" .parse_args() {'fails': 'succeeds'} Here's a more complex example derived from the tutorial: >>> p = nonpositional(  . (  . flag(\"verbose\") + defaults(quiet=False)  either  verbose and default \"quiet\" to False  . | flag(\"quiet\") + defaults(verbose=False)  or  quiet and default \"verbose\" to False  . ),  . option(\"x\", type=int, help=\"the base\"),  . option(\"y\", type=int, help=\"the exponent\"),  . ) >>> p.parse_args(\"-x\", \"1\", \"-y\", \"2\", \" verbose\") {'x': 1, 'y': 2, 'verbose': True, 'quiet': False}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.flag",
        "url": 3,
        "doc": "Binds a boolean value to a variable. >>> p = flag(\"verbose\") >>> p.parse_args(\" verbose\") {'verbose': True} Parameters      dest : str The variable to which the value will be bound. default : Optional[bool] An optional default value. help : Optional[str] An optional help string. nesting : bool If  True , then the parser will split the parsed output on  . yielding nested output. See Examples for more details. regex : bool If  True , then the parser will use a regex to match the flag string. short : bool Whether to check for the short form of the flag, which uses a single dash and the first character of  dest , e.g.  -f for  foo . string : Optional[str] A custom string to use for the flag. Defaults to   {dest} . Examples     Here is an example using the  default parameter: >>> p = flag(\"verbose\", default=False) >>> p.parse_args(\"-h\") usage:  verbose >>> p.parse_args() {'verbose': False} By default  flag fails when it does not receive expected input: >>> p = flag(\"verbose\") >>> p.parse_args() usage:  verbose The following arguments are required:  verbose Here is an example using the  help parameter: >>> p = flag(\"verbose\", help=\"Turn on verbose output.\") >>> p.parse_args(\"-h\") usage:  verbose verbose: Turn on verbose output. Here is an example using the  short parameter: >>> flag(\"verbose\", short=True).parse_args(\"-v\")  this is the default {'verbose': True} >>> flag(\"verbose\", short=False).parse_args(\"-v\")  fails usage:  verbose Expected ' verbose'. Got '-v' Here is an example using the  string parameter: >>> flag(\"value\", string=\"v\").parse_args(\"v\")  note that string does not have to start with - {'value': True} >>> flag(\"config.value\").parse_args(\" config.value\") {'config': {'value': True ",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.help_parser",
        "url": 3,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.item",
        "url": 3,
        "doc": "Parses a single word and binds it to  dest . One of the lowest level building blocks for parsers. Parameters      usage_name : Optional[str] Used for generating usage text Examples     >>> p = item(\"name\", usage_name=\"Your first name\") >>> p.parse_args(\"Alice\") {'name': 'Alice'} >>> p.parse_args() usage: name The following arguments are required: Your first name",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.matches",
        "url": 3,
        "doc": "Checks if the next word is  s . >>> matches(\"hello\").parse_args(\"hello\") {'hello': 'hello'} >>> matches(\"hello\").parse_args(\"goodbye\") usage: hello Expected 'hello'. Got 'goodbye' Parameters      s: str The word to that input will be checked against for equality. peak : bool If  False , then the parser will consume the word and return the remaining words as  unparsed . If  True , then the parser leaves the  unparsed component unchanged. regex : bool Whether to treat  s as a regular expression. If  False , then the parser will only succeed on string equality. Examples     >>> p = matches(\"hello\") >> matches(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") {'hello': 'hello', 'goodbye': 'goodbye'} Look what happens when  peak=True : >>> p = matches(\"hello\", peak=True) >> matches(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") usage: hello goodbye Expected 'goodbye'. Got 'hello' The first parser didn't consume the word and so \"hello\" got passed on to  equals(\"goodbye\") . But this would work: >>> p = matches(\"hello\", peak=True) >> matches(\"hello\") >> matches(\"goodbye\") >>> p.parse_args(\"hello\", \"goodbye\") {'hello': ['hello', 'hello'], 'goodbye': 'goodbye'}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.nonpositional",
        "url": 3,
        "doc": " nonpositional takes a sequence of parsers as arguments and attempts all permutations of them, returning the first permutations that is successful: >>> p = nonpositional(flag(\"verbose\"), flag(\"quiet\" >>> p.parse_args(\" verbose\", \" quiet\") {'verbose': True, 'quiet': True} >>> p.parse_args(\" quiet\", \" verbose\")  reverse order also works {'quiet': True, 'verbose': True} Parameters      max: int Limits the number of times  repeated is applied in order to prevent  RecursionError s. The default for this can be increased by either setting  parser.MAX_MANY or the environment variable  DOLLAR_LAMBDA_MAX_MANY . repeated : Optional[Parser[Sequence[A ] If provided, this parser gets applied repeatedly (zero or more times) at all positions. Examples     >>> p = nonpositional(repeated=flag(\"x\" >>> p.parse_args() {} >>> p.parse_args(\"-x\") {'x': True} >>> p.parse_args(\"-x\", \"-x\") {'x': [True, True]} >>> p = nonpositional(flag(\"y\"), repeated=flag(\"x\" >>> p.parse_args(\"-y\") {'y': True} >>> p.parse_args(\"-y\", \"-x\") {'y': True, 'x': True} >>> p.parse_args(\"-x\", \"-y\") {'x': True, 'y': True} >>> p.parse_args(\"-y\", \"-x\", \"-x\") {'y': True, 'x': [True, True]} >>> p.parse_args(\"-x\", \"-y\", \"-x\") {'x': [True, True], 'y': True} >>> p.parse_args(\"-x\", \"-x\", \"-y\") {'x': [True, True], 'y': True} >>> p = nonpositional(flag(\"y\"), repeated=(flag(\"x\") | flag(\"z\" .ignore( >>> p.parse_args(\"-x\", \"-y\", \"-z\") {'y': True}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.option",
        "url": 3,
        "doc": "Parses two words, binding the second to the first. Parameters      dest : str The name of variable to bind to: default : Optional[Any] The default value to bind on failure: flag : Optional[str] The flag to use for the option. If not provided, defaults to   {dest} . help : Optional[str] The help message to display for the option: nesting : bool If  True , then the parser will split the parsed output on  . yielding nested output. See Examples for more details. regex : bool If  True , then the parser will match the flag string as a regex. short : bool Whether to check for the short form of the flag, which uses a single dash and the first character of  dest , e.g.  -c for  count . type : Callable str], Any] Use the  type argument to convert the input to a different type: Examples     >>> option(\"count\").parse_args(\" count\", \"1\") {'count': '1'} In this example, you can see that the  flag parameter allows the user to specify an arbitrary lead string, including one that doesn't start with a dash. >>> option(\"count\", flag=\"ct\").parse_args(\"ct\", \"1\") {'count': '1'} This example demonstrates the use of the  default parameter: >>> p = option(\"count\", default=2) >>> p.parse_args(\"-h\") usage:  count COUNT count: (default: 2) >>> p.parse_args() {'count': 2} Here we specify a help-string using the  help parameter: >>> option(\"count\", help=\"The number we should count to\").parse_args(\"-h\") usage:  count COUNT count: The number we should count to This example demonstrates the difference between  short=True and  short=False : >>> option(\"count\", short=True).parse_args(\"-c\", \"1\") {'count': '1'} >>> option(\"count\", short=False).parse_args(\"-c\", \"1\") usage:  count COUNT Expected ' count'. Got '-c' As with [argparse](https: docs.python.org/3/library/argparse.html argument-parsing), the  type argument allows you to convert the input to a different type using a function that takes a single string argument: >>> option(\"x\", type=int).parse_args(\"-x\", \"1\")  converts \"1\" to an int {'x': 1} >>> option(\"x\", type=lambda x: int(x) + 1).parse_args(\"-x\", \"1\") {'x': 2} >>> option(\"config.x\").parse_args(\" config.x\", \"a\") {'config': {'x': 'a' ",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.peak",
        "url": 3,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.sat",
        "url": 3,
        "doc": "A wrapper around  Parser.sat that uses  item to parse the argument and just applies  predicate to the value output by  item . >>> p = sat(lambda x: len(x)  1, lambda x: ArgumentError(f\"'{x}' must have exactly one character.\"), \"x\") >>> p.parse_args(\"a\")  succeeds {'x': 'a'} >>> p.parse_args(\"aa\")  fails usage: x 'aa' must have exactly one character. Parameters      predicate : Callable A], bool] The predicate to apply to the result of  item .  sat fails if this predicate returns false. on_fail : Callable A], ArgumentError] A function producing an ArgumentError to return if the predicate fails. Takes the output of  item as an argument. name: str The value to bind the result to.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.parser.sat_peak",
        "url": 3,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.result",
        "url": 4,
        "doc": "Defines the  Result dataclass, representing success or failure, output by parsers."
    },
    {
        "ref": "dollar_lambda.result.Result",
        "url": 4,
        "doc": "Result(get: \"'NonemptyList[A_co] | ArgumentError'\")"
    },
    {
        "ref": "dollar_lambda.result.Result.get",
        "url": 4,
        "doc": ""
    },
    {
        "ref": "dollar_lambda.result.Result.bind",
        "url": 4,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.result.Result.return_",
        "url": 4,
        "doc": "  return  a -> m a  ",
        "func": 1
    },
    {
        "ref": "dollar_lambda.result.Result.zero",
        "url": 4,
        "doc": "",
        "func": 1
    },
    {
        "ref": "dollar_lambda.args",
        "url": 5,
        "doc": "Defines the  Args dataclass and associated functions."
    },
    {
        "ref": "dollar_lambda.args.field",
        "url": 5,
        "doc": "This is a thin wrapper around [ dataclasses.field ](https: docs.python.org/3/library/dataclasses.html dataclasses.field). Parameters      help : str An optional help string for the argument. metadata : str Identical to the  metadata argument for [ dataclasses.field ](https: docs.python.org/3/library/dataclasses.html dataclasses.field). type : Optional[type | Callable str], Any A function that takes a string and returns a value just like the  type argument for [ ArgumentParser.add_argument ](https: docs.python.org/3/library/argparse.html type). Returns    - A  dataclasses.Field object that can be used in place of a default argument as described in the [ dataclasses.Field documentation](https: docs.python.org/3/library/dataclasses.html dataclasses.field).",
        "func": 1
    },
    {
        "ref": "dollar_lambda.args.Args",
        "url": 5,
        "doc": " Args is sugar for the  nonpositional function and removes much of the boilerplate from defining parsers with many arguments. >>> @dataclass  . class MyArgs(Args):  . verbose: bool  . count: int >>> MyArgs.parse_args(\" verbose\", \" count\", \"1\") {'verbose': True, 'count': 1}  MyArgs will accept these arguments in any order: >>> MyArgs.parse_args(\" count\", \"1\", \" verbose\") {'count': 1, 'verbose': True} Note that when the default value of an argument is  True ,  Args will, by default add   no- to the front of the flag (while still assigning the value to the original key): >>> @dataclass  . class MyArgs(Args):  . tests: bool = True >>> MyArgs.parse_args(\" no-tests\") {'tests': False} >>> MyArgs.parse_args() {'tests': True} To suppress this behavior, set  flip_bools=False : >>> MyArgs.parse_args(\" tests\", flip_bools=False) {'tests': False} By using the  Args.parser() method,  Args can take advantage of all the same combinators as other parsers: >>> from dollar_lambda import argument >>> p = MyArgs.parser() >>> p1 = p >> argument(\"a\") >>> p1.parse_args(\" no-tests\", \"hello\") {'tests': False, 'a': 'hello'} To supply other metadata, like  help text or custom parsers, use  field : @dataclass >>> @dataclass  . class MyArgs(Args):  . x: int = field(default=0, help=\"a number\")  . y: int = field(  . default=1,  . parser=option(\"y\", type=lambda s: int(s) + 1, help=\"a number to increment\"),  . ) >>> MyArgs.parse_args(\"-h\") usage: -x X -y Y x: a number y: a number to increment This supplies defaults for  y when omitted: >>> MyArgs.parse_args(\"-x\", \"10\") {'x': 10, 'y': 1} It also applies the custom type to  y when  \"-y\" is given >>> MyArgs.parse_args() {'x': 0, 'y': 1}"
    },
    {
        "ref": "dollar_lambda.args.Args.parser",
        "url": 5,
        "doc": "Returns a parser for the dataclass. Converts each field to a parser ( option or  flag depending on its type). Combines these parsers using  nonpositional . Parameters      flip_bools: bool Whether to add   no-  before arguments that default to  True . Examples     >>> @dataclass  . class MyArgs(Args):  . tests: bool = True Note the leading   no- : >>> MyArgs.parse_args(\" no-tests\") {'tests': False} >>> MyArgs.parse_args() {'tests': True} To suppress this behavior, set  flip_bools=False : >>> MyArgs.parse_args(\" tests\", flip_bools=False) {'tests': False}",
        "func": 1
    },
    {
        "ref": "dollar_lambda.args.Args.parse_args",
        "url": 5,
        "doc": "Parses the arguments and returns a dictionary of the parsed values.",
        "func": 1
    },
    {
        "ref": "dollar_lambda.decorators",
        "url": 6,
        "doc": "Defines the  command decorator and the  CommandTree class."
    },
    {
        "ref": "dollar_lambda.decorators.command",
        "url": 6,
        "doc": "A succinct way to generate a simple  nonpositional parser.  @command derives the component parsers from the function's signature and automatically executes the function with the parsed arguments, if parsing succeeds: >>> @command(help=dict(a=\"something about a\"  . def f(a: int = 1, b: bool = False):  . return dict(a=a, b=b) >>> f(\"-a\", \"2\", \"-b\") {'a': 2, 'b': True} If the wrapped function receives no arguments (as in  f() ), the parser will take  sys.argv[1:] as the input. Note that  @command does not handle mutually exclusive arguments or alternative arguments. Parameters      flip_bools : bool For boolean arguments that default to true, this changes the flag from   {dest} to   no-{dest} : help : dict[str, str] A dictionary of help strings for the arguments. repeated: Optional[Parser[Sequence[KeyValue[Any  If provided, this parser gets applied repeatedly (zero or more times) at all positions. strings : dict[str, str] This dictionary maps variable names to the strings that the parser will look for in the input. Examples     >>> @command()  . def f(cuda: bool = True):  . return dict(cuda=cuda) >>> f() {'cuda': True} >>> f(\" no-cuda\")  flip_bools adds  no- to the flag {'cuda': False} As the following example demonstrates, when  flip_bools=False output can be somewhat confusing: >>> @command(flip_bools=False)  . def f(cuda: bool = True):  . return dict(cuda=cuda) >>> f(\" cuda\") {'cuda': False} Here is an example using the  help parameter: >>> @command(help=dict(quiet=\"Be quiet\"  . def f(quiet: bool):  . return dict(quiet=quiet) >>> f(\" help\") usage:  quiet quiet: Be quiet Here is an example using the  parser parameter: TODO!",
        "func": 1
    },
    {
        "ref": "dollar_lambda.decorators.CommandTree",
        "url": 6,
        "doc": "Allows parsers to dynamically dispatch their results based on the input. For usage details, see the [ CommandTree tutorial]( commandtree-tutorial)."
    },
    {
        "ref": "dollar_lambda.decorators.CommandTree.command",
        "url": 6,
        "doc": "A decorator for adding a function as a child of this tree. Parameters      can_run: bool Whether the parser will permit the decorated function to run if no further arguments are supplied. flip_bools: bool Whether to add   no-  before arguments that default to  True . help: dict A dictionary of help strings for the arguments. repeated: Optional[Parser[Sequence[KeyValue[Any  If provided, this parser gets applied repeatedly (zero or more times) at all positions. parsers: dict TODO Examples     With  flip_bools set to  True : >>> tree = CommandTree()  . >>> @tree.command(flip_bools=True)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage:  no-b b: (default: True) With  flip_bools set to  False : >>> tree = CommandTree()  . >>> @tree.command(flip_bools=False)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: -b b: (default: True) With  can_run set to  True (the default), we can run  f1 by not passing arguments for the  f1 's children: >>> tree = CommandTree()  . >>> @tree.command(can_run=True)   >> @f1.command()  . def g1(n: int):  . return dict(g1=dict(b=b, n=n  . >>> tree(\"-h\") usage: -b -n N >>> tree(\"-b\") {'f1': {'b': True With  can_run set to  False , the parser will fail if the child function arguments are not supplied: >>> tree = CommandTree()  . >>> @tree.command(can_run=False)   >> @f1.command()  . def g1(n: int):  . return dict(g1=dict(b=b, n=n  . >>> tree(\"-h\") usage: -b -n N >>> tree(\"f1\", \"-b\") usage: -b -n N Expected '-b'. Got 'f1'",
        "func": 1
    },
    {
        "ref": "dollar_lambda.decorators.CommandTree.subcommand",
        "url": 6,
        "doc": "A decorator for adding a function as a child of this tree. As a subcommand, the function's name must be invoked on the command line for the function to be called. Parameters      can_run: bool Whether the parser will permit the decorated function to run if no further arguments are supplied. flip_bools: bool Whether to add   no-  before arguments that default to  True . help: Dict[str, str] A dictionary of help strings for the arguments. repeated: Optional[Parser[Sequence[KeyValue[Any  If provided, this parser gets applied repeatedly (zero or more times) at all positions. See  nonpositional for examples. parsers: Dict[str, Parser] A dictionary reserving arguments for custom parsers. See below for examples. See  command for examples. Examples     With  flip_bools set to  True : >>> tree = CommandTree()  . >>> @tree.subcommand(flip_bools=True)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: f1  no-b b: (default: True) With  flip_bools set to  False : >>> tree = CommandTree()  . >>> @tree.subcommand(flip_bools=False)  . def f1(b: bool = True):  . return dict(f1=dict(b=b  . >>> tree(\"-h\") usage: f1 -b b: (default: True) With  can_run set to  True (the default), we can run  f1 by not passing arguments for the  f1 's children: >>> tree = CommandTree()  . >>> @tree.subcommand(can_run=True)   >> @f1.subcommand()  . def g1(b: bool, n: int):  . return dict(g1=dict(b=b, n=n  . >>> tree(\"-h\") usage: f1 -b g1 -n N >>> tree(\"f1\", \"-b\") {'f1': {'b': True With  can_run set to  False , the parser will fail if the child function arguments are not supplied: >>> tree = CommandTree()  . >>> @tree.subcommand(can_run=False)   >> @f1.subcommand()  . def g1(b: bool, n: int):  . return dict(g1=dict(b=b, n=n  . >>> tree(\"-h\") usage: f1 -b g1 -n N >>> tree(\"f1\", \"-b\") usage: f1 -b g1 -n N The following arguments are required: g1",
        "func": 1
    }
]
