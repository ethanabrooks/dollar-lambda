<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dollar_lambda.decorators API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dollar_lambda.decorators</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import operator
import sys
from dataclasses import dataclass, field, replace
from functools import reduce
from inspect import Parameter, signature
from typing import Any, Callable, Dict, Iterator, List, Optional, TypeVar, cast

from pytypeclass.nonempty_list import NonemptyList

from dollar_lambda import parser as parser_mod
from dollar_lambda.args import ArgsField
from dollar_lambda.error import ArgumentError
from dollar_lambda.key_value import KeyValue
from dollar_lambda.parser import Parse, Parser, done, empty, equals, wrap_help
from dollar_lambda.result import Result
from dollar_lambda.sequence import Sequence

A = TypeVar(&#34;A&#34;)
B = TypeVar(&#34;B&#34;)
A_co = TypeVar(&#34;A_co&#34;, covariant=True)


def func_to_parser(
    func: Callable,
    exclude: Optional[List[str]] = None,
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Parser[Sequence[KeyValue[Any]]]:
    _help = {} if help is None else help
    _types = {} if types is None else types
    _exclude = [] if exclude is None else exclude

    return ArgsField.nonpositional(
        *[
            ArgsField(
                name=k,
                default=None if v.default == Parameter.empty else v.default,
                help=_help.get(k),
                type=_types.get(k, v.annotation),
            )
            for k, v in signature(func).parameters.items()
            if k not in _exclude
        ],
        flip_bools=flip_bools,
    )


def command(
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable[[Callable], Callable]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; @command(help=dict(a=&#34;something about a&#34;), types=dict(a=lambda x: int(x) + 1))
    ... def f(a: int = 1, b: bool = False):
    ...     print(dict(a=a, b=b))
    &gt;&gt;&gt; f(&#34;-a&#34;, &#34;2&#34;, &#34;-b&#34;)
    {&#39;a&#39;: 3, &#39;b&#39;: True}
    &#34;&#34;&#34;

    def wrapper(func: Callable) -&gt; Callable:
        p = func_to_parser(func, flip_bools=flip_bools, help=help, types=types)
        p = wrap_help(p)

        def wrapped(*args) -&gt; Any:
            parsed = p.parse_args(*args)
            if parsed is None:
                return
            assert isinstance(parsed, Dict), parsed
            return func(**parsed)

        return wrapped

    return wrapper


@dataclass
class FunctionPair(Sequence[A]):
    function: Callable

    def __or__(self, other: Sequence[B]) -&gt; &#34;FunctionPair[A | B]&#34;:
        function = other.function if isinstance(other, FunctionPair) else self.function
        return FunctionPair(get=[*self, *other], function=function)


def command_parser(
    func: Callable,
    usage: Optional[str] = None,
    help: Optional[Dict[str, str]] = None,
) -&gt; Parser[FunctionPair[A]]:
    _help = {} if help is None else help
    return Parser[FunctionPair[A]](
        lambda cs: Result.return_(
            Parse(parsed=FunctionPair(Sequence[A]([]), func), unparsed=cs)
        ),
        usage=usage,
        helps=_help,
    )


def subcommand_parser(
    func: Callable,
    usage: Optional[str] = None,
    help: Optional[Dict[str, str]] = None,
) -&gt; Parser[FunctionPair[KeyValue[str]]]:
    _help = {} if help is None else help

    # def f(
    #     _: Sequence[KeyValue[str]],
    # ) -&gt; Parser[FunctionPair[KeyValue[str]]]:
    #     return Parser[FunctionPair[KeyValue[str]]](g, usage=usage, helps=_help)

    def g(
        cs: Sequence[str],
    ) -&gt; Result[Parse[FunctionPair[KeyValue[str]]]]:
        return Result.return_(
            Parse(parsed=FunctionPair(Sequence([]), func), unparsed=cs)
        )

    eq = equals(func.__name__)
    p = eq &gt;= (
        lambda _: Parser[FunctionPair[KeyValue[str]]](g, usage=usage, helps=_help)
    )
    return replace(p, usage=eq.usage, helps=eq.helps)


@dataclass
class Node:
    function: Callable
    flip_bools: bool
    help: Optional[Dict[str, str]]
    required: bool
    types: Optional[Dict[str, Callable[[str], Any]]]
    subcommand: bool
    tree: Optional[&#34;CommandTree&#34;]

    def parser(self, *exclude: str) -&gt; Parser[FunctionPair[KeyValue[Any]]]:
        p1 = (
            subcommand_parser(self.function)
            if self.subcommand
            else command_parser(self.function)
        )
        p2 = func_to_parser(
            self.function,
            exclude=list(exclude),
            flip_bools=self.flip_bools,
            help=self.help,
            types=self.types,
        )
        return p1 &gt;&gt; p2  # type: ignore[return-value]

    def variable_names(self) -&gt; Iterator[str]:
        yield from signature(self.function).parameters.keys()


@dataclass
class CommandTree:
    &#34;&#34;&#34;
    &gt;&gt;&gt; tree = CommandTree()

    &gt;&gt;&gt; @tree.command()
    ... def f1(a: int):
    ...     return dict(f1=dict(a=a))

    &gt;&gt;&gt; @tree.subcommand()
    ... def f2(b: bool):
    ...     return dict(f2=dict(b=b))

    &gt;&gt;&gt; tree.main(&#34;-h&#34;)
    usage: [-a A | f2 -b]
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;)
    {&#39;f1&#39;: {&#39;a&#39;: 1}}
    &gt;&gt;&gt; tree.main(&#34;f2&#34;, &#34;-b&#34;)
    {&#39;f2&#39;: {&#39;b&#39;: True}}

    &gt;&gt;&gt; tree = CommandTree()

    &gt;&gt;&gt; @tree.command()
    ... def f1(a: int):
    ...     return dict(f1=dict(a=a))

    &gt;&gt;&gt; @f1.subcommand(required=False)
    ... def f2(a: int, b: bool):
    ...     return dict(f2=dict(a=a, b=b))

    &gt;&gt;&gt; @f1.subcommand(required=False)
    ... def f3(a: int, c: str):
    ...     return dict(f3=dict(a=a, c=c))

    &gt;&gt;&gt; tree.main(&#34;-h&#34;)
    usage: -a A [f2 -b | f3 -c C]
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;)
    {&#39;f1&#39;: {&#39;a&#39;: 1}}
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;, &#34;f2&#34;, &#34;-b&#34;)
    {&#39;f2&#39;: {&#39;a&#39;: 1, &#39;b&#39;: True}}
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;, &#34;f3&#34;, &#34;-c&#34;, &#34;x&#34;)
    {&#39;f3&#39;: {&#39;a&#39;: 1, &#39;c&#39;: &#39;x&#39;}}
    &#34;&#34;&#34;

    children: List[Node] = field(default_factory=list)
    required: bool = False

    def command(
        self,
        flip_bools: bool = True,
        help: Optional[Dict[str, str]] = None,
        required: bool = False,
        types: Optional[Dict[str, Callable[[str], Any]]] = None,
    ) -&gt; Callable:
        return self.decorator(
            flip_bools=flip_bools,
            help=help,
            required=required,
            types=types,
            subcommand=False,
        )

    def decorator(self, **kwargs) -&gt; Callable:
        def wrapper(function: Callable):
            tree = CommandTree()
            self.children.append(Node(function=function, tree=tree, **kwargs))
            return tree

        return wrapper

    def parser(self, *variables: str) -&gt; Parser[FunctionPair[KeyValue[Any]]]:
        if not self.children:
            raise RuntimeError(
                &#34;You must assign children to a CommandTree object in order to use it as a parser.&#34;
            )

        def get_alternatives() -&gt; Iterator[Parser[FunctionPair[KeyValue[Any]]]]:
            if not self.required:
                yield cast(Parser[FunctionPair[KeyValue[Any]]], empty())
            for child in self.children:
                parser: Parser[FunctionPair[KeyValue[Any]]] = child.parser(*variables)
                if child.tree is not None and child.tree.children:
                    parser = cast(
                        Parser[FunctionPair[KeyValue[Any]]],
                        parser
                        &gt;&gt; child.tree.parser(*variables, *child.variable_names()),
                    )
                yield parser

        return wrap_help(reduce(operator.or_, get_alternatives()))

    def main(self, *args: str) -&gt; Any:
        _args = args if args or parser_mod.TESTING else sys.argv[1:]
        p = self.parser() &gt;&gt; done()
        result = p.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            p.handle_error(result)
            if parser_mod.TESTING:
                return  # type: ignore[return-value]
            else:
                exit()
        assert isinstance(result, NonemptyList)
        pair = cast(FunctionPair, result.head.parsed)
        return pair.function(**{kv.key: kv.value for kv in pair.get})

    def subcommand(
        self,
        flip_bools: bool = True,
        help: Optional[Dict[str, str]] = None,
        required: bool = False,
        types: Optional[Dict[str, Callable[[str], Any]]] = None,
    ) -&gt; Callable:
        return self.decorator(
            flip_bools=flip_bools,
            help=help,
            required=required,
            types=types,
            subcommand=True,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dollar_lambda.decorators.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>flip_bools: bool = True, help: Optional[Dict[str, str]] = None, types: Optional[Dict[str, Callable[[str], Any]]] = None) ‑> Callable[[Callable], Callable]</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; @command(help=dict(a=&quot;something about a&quot;), types=dict(a=lambda x: int(x) + 1))
... def f(a: int = 1, b: bool = False):
...     print(dict(a=a, b=b))
&gt;&gt;&gt; f(&quot;-a&quot;, &quot;2&quot;, &quot;-b&quot;)
{'a': 3, 'b': True}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable[[Callable], Callable]:
    &#34;&#34;&#34;
    &gt;&gt;&gt; @command(help=dict(a=&#34;something about a&#34;), types=dict(a=lambda x: int(x) + 1))
    ... def f(a: int = 1, b: bool = False):
    ...     print(dict(a=a, b=b))
    &gt;&gt;&gt; f(&#34;-a&#34;, &#34;2&#34;, &#34;-b&#34;)
    {&#39;a&#39;: 3, &#39;b&#39;: True}
    &#34;&#34;&#34;

    def wrapper(func: Callable) -&gt; Callable:
        p = func_to_parser(func, flip_bools=flip_bools, help=help, types=types)
        p = wrap_help(p)

        def wrapped(*args) -&gt; Any:
            parsed = p.parse_args(*args)
            if parsed is None:
                return
            assert isinstance(parsed, Dict), parsed
            return func(**parsed)

        return wrapped

    return wrapper</code></pre>
</details>
</dd>
<dt id="dollar_lambda.decorators.command_parser"><code class="name flex">
<span>def <span class="ident">command_parser</span></span>(<span>func: Callable, usage: Optional[str] = None, help: Optional[Dict[str, str]] = None) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.decorators.FunctionPair" href="#dollar_lambda.decorators.FunctionPair">FunctionPair</a>[~A]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_parser(
    func: Callable,
    usage: Optional[str] = None,
    help: Optional[Dict[str, str]] = None,
) -&gt; Parser[FunctionPair[A]]:
    _help = {} if help is None else help
    return Parser[FunctionPair[A]](
        lambda cs: Result.return_(
            Parse(parsed=FunctionPair(Sequence[A]([]), func), unparsed=cs)
        ),
        usage=usage,
        helps=_help,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.decorators.func_to_parser"><code class="name flex">
<span>def <span class="ident">func_to_parser</span></span>(<span>func: Callable, exclude: Optional[List[str]] = None, flip_bools: bool = True, help: Optional[Dict[str, str]] = None, types: Optional[Dict[str, Callable[[str], Any]]] = None) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def func_to_parser(
    func: Callable,
    exclude: Optional[List[str]] = None,
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Parser[Sequence[KeyValue[Any]]]:
    _help = {} if help is None else help
    _types = {} if types is None else types
    _exclude = [] if exclude is None else exclude

    return ArgsField.nonpositional(
        *[
            ArgsField(
                name=k,
                default=None if v.default == Parameter.empty else v.default,
                help=_help.get(k),
                type=_types.get(k, v.annotation),
            )
            for k, v in signature(func).parameters.items()
            if k not in _exclude
        ],
        flip_bools=flip_bools,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.decorators.subcommand_parser"><code class="name flex">
<span>def <span class="ident">subcommand_parser</span></span>(<span>func: Callable, usage: Optional[str] = None, help: Optional[Dict[str, str]] = None) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.decorators.FunctionPair" href="#dollar_lambda.decorators.FunctionPair">FunctionPair</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[str]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subcommand_parser(
    func: Callable,
    usage: Optional[str] = None,
    help: Optional[Dict[str, str]] = None,
) -&gt; Parser[FunctionPair[KeyValue[str]]]:
    _help = {} if help is None else help

    # def f(
    #     _: Sequence[KeyValue[str]],
    # ) -&gt; Parser[FunctionPair[KeyValue[str]]]:
    #     return Parser[FunctionPair[KeyValue[str]]](g, usage=usage, helps=_help)

    def g(
        cs: Sequence[str],
    ) -&gt; Result[Parse[FunctionPair[KeyValue[str]]]]:
        return Result.return_(
            Parse(parsed=FunctionPair(Sequence([]), func), unparsed=cs)
        )

    eq = equals(func.__name__)
    p = eq &gt;= (
        lambda _: Parser[FunctionPair[KeyValue[str]]](g, usage=usage, helps=_help)
    )
    return replace(p, usage=eq.usage, helps=eq.helps)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dollar_lambda.decorators.CommandTree"><code class="flex name class">
<span>class <span class="ident">CommandTree</span></span>
<span>(</span><span>children: List[<a title="dollar_lambda.decorators.Node" href="#dollar_lambda.decorators.Node">Node</a>] = &lt;factory&gt;, required: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.subcommand()
... def f2(b: bool):
...     return dict(f2=dict(b=b))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree.main(&quot;-h&quot;)
usage: [-a A | f2 -b]
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
&gt;&gt;&gt; tree.main(&quot;f2&quot;, &quot;-b&quot;)
{'f2': {'b': True}}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree = CommandTree()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @tree.command()
... def f1(a: int):
...     return dict(f1=dict(a=a))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @f1.subcommand(required=False)
... def f2(a: int, b: bool):
...     return dict(f2=dict(a=a, b=b))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; @f1.subcommand(required=False)
... def f3(a: int, c: str):
...     return dict(f3=dict(a=a, c=c))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; tree.main(&quot;-h&quot;)
usage: -a A [f2 -b | f3 -c C]
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;)
{'f1': {'a': 1}}
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;, &quot;f2&quot;, &quot;-b&quot;)
{'f2': {'a': 1, 'b': True}}
&gt;&gt;&gt; tree.main(&quot;-a&quot;, &quot;1&quot;, &quot;f3&quot;, &quot;-c&quot;, &quot;x&quot;)
{'f3': {'a': 1, 'c': 'x'}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class CommandTree:
    &#34;&#34;&#34;
    &gt;&gt;&gt; tree = CommandTree()

    &gt;&gt;&gt; @tree.command()
    ... def f1(a: int):
    ...     return dict(f1=dict(a=a))

    &gt;&gt;&gt; @tree.subcommand()
    ... def f2(b: bool):
    ...     return dict(f2=dict(b=b))

    &gt;&gt;&gt; tree.main(&#34;-h&#34;)
    usage: [-a A | f2 -b]
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;)
    {&#39;f1&#39;: {&#39;a&#39;: 1}}
    &gt;&gt;&gt; tree.main(&#34;f2&#34;, &#34;-b&#34;)
    {&#39;f2&#39;: {&#39;b&#39;: True}}

    &gt;&gt;&gt; tree = CommandTree()

    &gt;&gt;&gt; @tree.command()
    ... def f1(a: int):
    ...     return dict(f1=dict(a=a))

    &gt;&gt;&gt; @f1.subcommand(required=False)
    ... def f2(a: int, b: bool):
    ...     return dict(f2=dict(a=a, b=b))

    &gt;&gt;&gt; @f1.subcommand(required=False)
    ... def f3(a: int, c: str):
    ...     return dict(f3=dict(a=a, c=c))

    &gt;&gt;&gt; tree.main(&#34;-h&#34;)
    usage: -a A [f2 -b | f3 -c C]
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;)
    {&#39;f1&#39;: {&#39;a&#39;: 1}}
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;, &#34;f2&#34;, &#34;-b&#34;)
    {&#39;f2&#39;: {&#39;a&#39;: 1, &#39;b&#39;: True}}
    &gt;&gt;&gt; tree.main(&#34;-a&#34;, &#34;1&#34;, &#34;f3&#34;, &#34;-c&#34;, &#34;x&#34;)
    {&#39;f3&#39;: {&#39;a&#39;: 1, &#39;c&#39;: &#39;x&#39;}}
    &#34;&#34;&#34;

    children: List[Node] = field(default_factory=list)
    required: bool = False

    def command(
        self,
        flip_bools: bool = True,
        help: Optional[Dict[str, str]] = None,
        required: bool = False,
        types: Optional[Dict[str, Callable[[str], Any]]] = None,
    ) -&gt; Callable:
        return self.decorator(
            flip_bools=flip_bools,
            help=help,
            required=required,
            types=types,
            subcommand=False,
        )

    def decorator(self, **kwargs) -&gt; Callable:
        def wrapper(function: Callable):
            tree = CommandTree()
            self.children.append(Node(function=function, tree=tree, **kwargs))
            return tree

        return wrapper

    def parser(self, *variables: str) -&gt; Parser[FunctionPair[KeyValue[Any]]]:
        if not self.children:
            raise RuntimeError(
                &#34;You must assign children to a CommandTree object in order to use it as a parser.&#34;
            )

        def get_alternatives() -&gt; Iterator[Parser[FunctionPair[KeyValue[Any]]]]:
            if not self.required:
                yield cast(Parser[FunctionPair[KeyValue[Any]]], empty())
            for child in self.children:
                parser: Parser[FunctionPair[KeyValue[Any]]] = child.parser(*variables)
                if child.tree is not None and child.tree.children:
                    parser = cast(
                        Parser[FunctionPair[KeyValue[Any]]],
                        parser
                        &gt;&gt; child.tree.parser(*variables, *child.variable_names()),
                    )
                yield parser

        return wrap_help(reduce(operator.or_, get_alternatives()))

    def main(self, *args: str) -&gt; Any:
        _args = args if args or parser_mod.TESTING else sys.argv[1:]
        p = self.parser() &gt;&gt; done()
        result = p.parse(Sequence(list(_args))).get
        if isinstance(result, ArgumentError):
            p.handle_error(result)
            if parser_mod.TESTING:
                return  # type: ignore[return-value]
            else:
                exit()
        assert isinstance(result, NonemptyList)
        pair = cast(FunctionPair, result.head.parsed)
        return pair.function(**{kv.key: kv.value for kv in pair.get})

    def subcommand(
        self,
        flip_bools: bool = True,
        help: Optional[Dict[str, str]] = None,
        required: bool = False,
        types: Optional[Dict[str, Callable[[str], Any]]] = None,
    ) -&gt; Callable:
        return self.decorator(
            flip_bools=flip_bools,
            help=help,
            required=required,
            types=types,
            subcommand=True,
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.decorators.CommandTree.children"><code class="name">var <span class="ident">children</span> : List[<a title="dollar_lambda.decorators.Node" href="#dollar_lambda.decorators.Node">Node</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.decorators.CommandTree.required"><code class="name">var <span class="ident">required</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.decorators.CommandTree.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self, flip_bools: bool = True, help: Optional[Dict[str, str]] = None, required: bool = False, types: Optional[Dict[str, Callable[[str], Any]]] = None) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(
    self,
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    required: bool = False,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable:
    return self.decorator(
        flip_bools=flip_bools,
        help=help,
        required=required,
        types=types,
        subcommand=False,
    )</code></pre>
</details>
</dd>
<dt id="dollar_lambda.decorators.CommandTree.decorator"><code class="name flex">
<span>def <span class="ident">decorator</span></span>(<span>self, **kwargs) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decorator(self, **kwargs) -&gt; Callable:
    def wrapper(function: Callable):
        tree = CommandTree()
        self.children.append(Node(function=function, tree=tree, **kwargs))
        return tree

    return wrapper</code></pre>
</details>
</dd>
<dt id="dollar_lambda.decorators.CommandTree.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, *args: str) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self, *args: str) -&gt; Any:
    _args = args if args or parser_mod.TESTING else sys.argv[1:]
    p = self.parser() &gt;&gt; done()
    result = p.parse(Sequence(list(_args))).get
    if isinstance(result, ArgumentError):
        p.handle_error(result)
        if parser_mod.TESTING:
            return  # type: ignore[return-value]
        else:
            exit()
    assert isinstance(result, NonemptyList)
    pair = cast(FunctionPair, result.head.parsed)
    return pair.function(**{kv.key: kv.value for kv in pair.get})</code></pre>
</details>
</dd>
<dt id="dollar_lambda.decorators.CommandTree.parser"><code class="name flex">
<span>def <span class="ident">parser</span></span>(<span>self, *variables: str) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.decorators.FunctionPair" href="#dollar_lambda.decorators.FunctionPair">FunctionPair</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parser(self, *variables: str) -&gt; Parser[FunctionPair[KeyValue[Any]]]:
    if not self.children:
        raise RuntimeError(
            &#34;You must assign children to a CommandTree object in order to use it as a parser.&#34;
        )

    def get_alternatives() -&gt; Iterator[Parser[FunctionPair[KeyValue[Any]]]]:
        if not self.required:
            yield cast(Parser[FunctionPair[KeyValue[Any]]], empty())
        for child in self.children:
            parser: Parser[FunctionPair[KeyValue[Any]]] = child.parser(*variables)
            if child.tree is not None and child.tree.children:
                parser = cast(
                    Parser[FunctionPair[KeyValue[Any]]],
                    parser
                    &gt;&gt; child.tree.parser(*variables, *child.variable_names()),
                )
            yield parser

    return wrap_help(reduce(operator.or_, get_alternatives()))</code></pre>
</details>
</dd>
<dt id="dollar_lambda.decorators.CommandTree.subcommand"><code class="name flex">
<span>def <span class="ident">subcommand</span></span>(<span>self, flip_bools: bool = True, help: Optional[Dict[str, str]] = None, required: bool = False, types: Optional[Dict[str, Callable[[str], Any]]] = None) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subcommand(
    self,
    flip_bools: bool = True,
    help: Optional[Dict[str, str]] = None,
    required: bool = False,
    types: Optional[Dict[str, Callable[[str], Any]]] = None,
) -&gt; Callable:
    return self.decorator(
        flip_bools=flip_bools,
        help=help,
        required=required,
        types=types,
        subcommand=True,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dollar_lambda.decorators.FunctionPair"><code class="flex name class">
<span>class <span class="ident">FunctionPair</span></span>
<span>(</span><span>get: typing.Sequence[A], function: Callable)</span>
</code></dt>
<dd>
<div class="desc"><p>FunctionPair(get: 'typing.Sequence[A]', function: Callable)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FunctionPair(Sequence[A]):
    function: Callable

    def __or__(self, other: Sequence[B]) -&gt; &#34;FunctionPair[A | B]&#34;:
        function = other.function if isinstance(other, FunctionPair) else self.function
        return FunctionPair(get=[*self, *other], function=function)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a></li>
<li>pytypeclass.monoid.MonadPlus</li>
<li>pytypeclass.monad.Monad</li>
<li>pytypeclass.monoid.Monoid</li>
<li>typing.Protocol</li>
<li>collections.abc.Sequence</li>
<li>typing.Generic</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.decorators.FunctionPair.function"><code class="name">var <span class="ident">function</span> : Callable</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dollar_lambda.sequence.Sequence" href="sequence.html#dollar_lambda.sequence.Sequence">Sequence</a></b></code>:
<ul class="hlist">
<li><code><a title="dollar_lambda.sequence.Sequence.bind" href="sequence.html#dollar_lambda.sequence.Sequence.bind">bind</a></code></li>
<li><code><a title="dollar_lambda.sequence.Sequence.return_" href="sequence.html#dollar_lambda.sequence.Sequence.return_">return_</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dollar_lambda.decorators.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>function: Callable, flip_bools: bool, help: Optional[Dict[str, str]], required: bool, types: Optional[Dict[str, Callable[[str], Any]]], subcommand: bool, tree: Optional[ForwardRef('<a title="dollar_lambda.decorators.CommandTree" href="#dollar_lambda.decorators.CommandTree">CommandTree</a>')])</span>
</code></dt>
<dd>
<div class="desc"><p>Node(function: Callable, flip_bools: bool, help: Optional[Dict[str, str]], required: bool, types: Optional[Dict[str, Callable[[str], Any]]], subcommand: bool, tree: Optional[ForwardRef('CommandTree')])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Node:
    function: Callable
    flip_bools: bool
    help: Optional[Dict[str, str]]
    required: bool
    types: Optional[Dict[str, Callable[[str], Any]]]
    subcommand: bool
    tree: Optional[&#34;CommandTree&#34;]

    def parser(self, *exclude: str) -&gt; Parser[FunctionPair[KeyValue[Any]]]:
        p1 = (
            subcommand_parser(self.function)
            if self.subcommand
            else command_parser(self.function)
        )
        p2 = func_to_parser(
            self.function,
            exclude=list(exclude),
            flip_bools=self.flip_bools,
            help=self.help,
            types=self.types,
        )
        return p1 &gt;&gt; p2  # type: ignore[return-value]

    def variable_names(self) -&gt; Iterator[str]:
        yield from signature(self.function).parameters.keys()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dollar_lambda.decorators.Node.flip_bools"><code class="name">var <span class="ident">flip_bools</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.decorators.Node.function"><code class="name">var <span class="ident">function</span> : Callable</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.decorators.Node.help"><code class="name">var <span class="ident">help</span> : Optional[Dict[str, str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.decorators.Node.required"><code class="name">var <span class="ident">required</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.decorators.Node.subcommand"><code class="name">var <span class="ident">subcommand</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.decorators.Node.tree"><code class="name">var <span class="ident">tree</span> : Optional[<a title="dollar_lambda.decorators.CommandTree" href="#dollar_lambda.decorators.CommandTree">CommandTree</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dollar_lambda.decorators.Node.types"><code class="name">var <span class="ident">types</span> : Optional[Dict[str, Callable[[str], Any]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dollar_lambda.decorators.Node.parser"><code class="name flex">
<span>def <span class="ident">parser</span></span>(<span>self, *exclude: str) ‑> <a title="dollar_lambda.parser.Parser" href="parser.html#dollar_lambda.parser.Parser">Parser</a>[<a title="dollar_lambda.decorators.FunctionPair" href="#dollar_lambda.decorators.FunctionPair">FunctionPair</a>[<a title="dollar_lambda.key_value.KeyValue" href="key_value.html#dollar_lambda.key_value.KeyValue">KeyValue</a>[typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parser(self, *exclude: str) -&gt; Parser[FunctionPair[KeyValue[Any]]]:
    p1 = (
        subcommand_parser(self.function)
        if self.subcommand
        else command_parser(self.function)
    )
    p2 = func_to_parser(
        self.function,
        exclude=list(exclude),
        flip_bools=self.flip_bools,
        help=self.help,
        types=self.types,
    )
    return p1 &gt;&gt; p2  # type: ignore[return-value]</code></pre>
</details>
</dd>
<dt id="dollar_lambda.decorators.Node.variable_names"><code class="name flex">
<span>def <span class="ident">variable_names</span></span>(<span>self) ‑> Iterator[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variable_names(self) -&gt; Iterator[str]:
    yield from signature(self.function).parameters.keys()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dollar_lambda" href="index.html">dollar_lambda</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dollar_lambda.decorators.command" href="#dollar_lambda.decorators.command">command</a></code></li>
<li><code><a title="dollar_lambda.decorators.command_parser" href="#dollar_lambda.decorators.command_parser">command_parser</a></code></li>
<li><code><a title="dollar_lambda.decorators.func_to_parser" href="#dollar_lambda.decorators.func_to_parser">func_to_parser</a></code></li>
<li><code><a title="dollar_lambda.decorators.subcommand_parser" href="#dollar_lambda.decorators.subcommand_parser">subcommand_parser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dollar_lambda.decorators.CommandTree" href="#dollar_lambda.decorators.CommandTree">CommandTree</a></code></h4>
<ul class="two-column">
<li><code><a title="dollar_lambda.decorators.CommandTree.children" href="#dollar_lambda.decorators.CommandTree.children">children</a></code></li>
<li><code><a title="dollar_lambda.decorators.CommandTree.command" href="#dollar_lambda.decorators.CommandTree.command">command</a></code></li>
<li><code><a title="dollar_lambda.decorators.CommandTree.decorator" href="#dollar_lambda.decorators.CommandTree.decorator">decorator</a></code></li>
<li><code><a title="dollar_lambda.decorators.CommandTree.main" href="#dollar_lambda.decorators.CommandTree.main">main</a></code></li>
<li><code><a title="dollar_lambda.decorators.CommandTree.parser" href="#dollar_lambda.decorators.CommandTree.parser">parser</a></code></li>
<li><code><a title="dollar_lambda.decorators.CommandTree.required" href="#dollar_lambda.decorators.CommandTree.required">required</a></code></li>
<li><code><a title="dollar_lambda.decorators.CommandTree.subcommand" href="#dollar_lambda.decorators.CommandTree.subcommand">subcommand</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.decorators.FunctionPair" href="#dollar_lambda.decorators.FunctionPair">FunctionPair</a></code></h4>
<ul class="">
<li><code><a title="dollar_lambda.decorators.FunctionPair.function" href="#dollar_lambda.decorators.FunctionPair.function">function</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dollar_lambda.decorators.Node" href="#dollar_lambda.decorators.Node">Node</a></code></h4>
<ul class="two-column">
<li><code><a title="dollar_lambda.decorators.Node.flip_bools" href="#dollar_lambda.decorators.Node.flip_bools">flip_bools</a></code></li>
<li><code><a title="dollar_lambda.decorators.Node.function" href="#dollar_lambda.decorators.Node.function">function</a></code></li>
<li><code><a title="dollar_lambda.decorators.Node.help" href="#dollar_lambda.decorators.Node.help">help</a></code></li>
<li><code><a title="dollar_lambda.decorators.Node.parser" href="#dollar_lambda.decorators.Node.parser">parser</a></code></li>
<li><code><a title="dollar_lambda.decorators.Node.required" href="#dollar_lambda.decorators.Node.required">required</a></code></li>
<li><code><a title="dollar_lambda.decorators.Node.subcommand" href="#dollar_lambda.decorators.Node.subcommand">subcommand</a></code></li>
<li><code><a title="dollar_lambda.decorators.Node.tree" href="#dollar_lambda.decorators.Node.tree">tree</a></code></li>
<li><code><a title="dollar_lambda.decorators.Node.types" href="#dollar_lambda.decorators.Node.types">types</a></code></li>
<li><code><a title="dollar_lambda.decorators.Node.variable_names" href="#dollar_lambda.decorators.Node.variable_names">variable_names</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
